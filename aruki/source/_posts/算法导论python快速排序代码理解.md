---
title: 算法导论python快速排序代码理解
date: 2020-1-25
categories: 学习笔记
tags:
    - Python
---

写易班2020新年专栏项目的时候, 想给文章按照列表里文章的点赞数和评论数的和来从大到小排序, 毕竟是网站, 为了用户体验, 访问速度肯定是不能慢的。

但是Python这语言本身执行效率就堪忧...以前做题目的时候, 发现同样是2千万次循环, 同样的算法, Java几百毫秒就解决了, Python用了7秒？
<!--more-->
想让排序快点就只能选择快速排序了, 虽然看学校数据结构的书有看到快速排序的思想, 但实际没有去实现过所以去网上找了关于快速排序的Python代码

偶然在一篇文章看到了《算法导论》中的快速排序, 当时觉得, 哇塞, 代码居然这么精简(虽然后来看到了更加精简的代码, 我还是太菜了, 还够不到大佬的后脚跟~), 当时为了赶时间就从这个代码下手理解了。

```Python
# 据说是《算法导论》中的快速排序

def quick_sort(array, l, r):
    if l < r:
        q = partition(array, l, r)
        quick_sort(array, l, q - 1)
        quick_sort(array, q + 1, r)

def partition(array, l, r):
    x = array[r]
    i = l - 1
    for j in range(l, r):
        if array[j] <= x:
            i += 1
            array[i], array[j] = array[j], array[i]
    array[i + 1], array[r] = array[r], array[i + 1]
    return i + 1
```

怎么理解这个快速排序的代码呢？

嘛, 首先是要知道快速排序的思路, 忘记的不知道的先去补课。

从这个代码可以看出, 每次排序用了一次循环, 代码中的l就是left, r就是right, 分别代表操作的列表的左下标和右下标, 初始传入的下标就是0和len(array)-1

partition是分片的意思, 其实在分片的时候, 就是进行了一次排序了。

partition函数中把列表最右边的值作为划分值, 交换点下标为传入列表最右边-1, 为什么是-1, 而不是l呢, 因为这个代码后面每一次交换位置分点的下标都会向右移, 为了防止漏掉l下标, 所以要先减一, 第一次交换的时候+1就变成l下标了。当然代码也可以改成下面这种直接把l赋值给i的形式

```Python
def partition(array, l, r):
    x = array[r]
    i = l
    for j in range(l, r):
        if array[j] <= x:
            array[i], array[j] = array[j], array[i]
            i += 1
    array[i], array[r] = array[r], array[i]
    return i
```

for循环是遍历下标从l到r-1的元素, 由于下标为r的元素是我们的分片点, 所以不需要进行比较, 当遍历到的元素值小于划分值, 就把这个元素向左边的i移动, 这样到最后, 所有小于划分值的元素都会在i下标位置的左边, 而i下标位置右边的, 都是大于划分值的, 但是此时i下标的元素仍然是大于划分值的, 我们要把划分的元素放到划分点, 所以最后要把i下标的元素和划分元素(最右边那个没有被遍历到的元素)交换位置, 这样就完成了分片, 然后返回分片点的下标, 然后回到quick_sort函数继续递归。

在quick_sort函数中的q是partition函数返回是划分点下标, 所以已经不需要进行排序了, 只需要对分片后的两边列表进行排序就行了, 所以调用quick_sort函数(`quick_sort(array, l, q - 1)`和`quick_sort(array, q + 1, r)`), 继续对两边子列表进行排序, 直到最后分片的两个元素排序好返回分片点下标, 由于就剩下两个元素, 所以排序完返回的下标肯定是这两个元素其中一个, 这时传入q-1和另外一个下标到quick_sort已经无法满足`if l < r`了, 所以该子列表排序完成, 结束递归, 等所有子列表都排序完, 整个列表就从小到大排序好了。

当然我们也可以吧partition里的`<=`改成`>=`, 这样就是所有大于划分值的元素都在i下标位置的左边, 列表将从大到小排序。

由于快速排序是原地排序, 在Python里直接采取原列表交换元素的方式, 按照Python语言的特性不需要进行返回, 原本传入的列表就会被排序好, 当然也就无法传入元组(tuple)了
