---
title: 数据结构基础
date: 2019-9-11
categories: 学习笔记
---

基本概念和术语
---

**数据(Data)：**客观事物的符号表示，是所有能输入到计算机中并被计算机程序处理的符号的总称

**数据元素(Data Element)：**数据的基本单位，在计算机中通常作为一个整体进行考虑和处理

**数据项(Data Item)：**组成数据元素的、有独立含义的、不可分割的最小单位

**数据对象(Data Object)：**是性质相同的数据元素的集合，是数据的一个子集


数据是什么？如何理解数据对象？什么是性质相同的数据元素的集合？
数据对象相当于数据的一部分内容，而这部分内容里面的元素都有相同的特点，举个例子：
```text
数据                                            一个班级里面的学生
数据对象                                        一个班里学生的信息表
数据元素                                        学生信息表的每一条数据都是数据元素
数据项                                          学生信息表里面的每一项信息
```
这里面，学生的信息表是学生的一个部分内容，学生可以包含很多内容，除了信息表，还有成绩单，身份内容，这些都算是学生这个数据的一部分，也就是数据的子集，即数据对象。而学生信息表里面会含有很多个信息项，例如姓名学号、专业、性别等等，这些信息项就是数据项，有着独立的含义。信息表里面的每一个学生的数据，都算是一个数据元素，这些学生的数据构和数据项构造成了信息表，所以数据对象是数据元素的集合。


### 数据结构

**数据结构(Data Stucture)：是相互之间存在一种或多种特定关系的数据元素的集合。**
数据结构其实就是带有“结构”的数据元素的集合。不过说是数据元素的集合，我们平时的理解更多的是倾向于结构，学得主要也是结构，但这个名词本身指的还是集合！
数据结构包括逻辑结构和储存结构两个层次。

#### 逻辑结构

**逻辑结构是对于数据来讲的，从逻辑关系上描述数据，和数据的储存无关，独立于计算机。**
**数据的逻辑结构分为：线性结构和非线性结构。**

四类基本逻辑结构：

**集合结构：**数据元素除了属于同一集合外，没有其他关系
**线性结构：**数据元素之间存在一对一的关系
**树结构：**数据元素之间存在一对多的关系
**图结构或网状结构：**数据元素之间存在多对多的关系

下面图示，会更容易理解

![数据的逻辑结构层次图](/images/数据的逻辑结构.png)

#### 储存结构

**储存结构也称为物理结构，指的是数据对象在计算机中的存储方式。**
通常要求数据对象在存入计算机时既要存储数据元素的数据，也要存储数据元素之间的逻辑关系，数据元素在计算机内用一个结点来表示。

数据元素在计算机中的两种基本储存结构：

**顺序存储结构：**借助元素在存储器中的相对位置来表示数据元素之间的逻辑关系，要求所有的元素依次存放在一片连续的存储空间中

**链式存储结构：**无需占用一整块存储空间，为了表示结点之间的关系，给每个结点附加指针字段，用于存放后继元素的存储地址。

```Text
课外补充：
逻辑结构与数据元素本身的形式、内容、相对位置、个数无关。
一些表面上很不相同的数据可以有相同的逻辑结构
通常要求同一逻辑结构中的所有数据元素具有相同的特性，这意味着不仅数据元素所包含的数据项的个数要相同，而且对应数据项的类型要一致
```

## 算法和算法分析

**算法：**是为了解决某类问题而规定的一个有限长的操作序列
一个算法必须满足的五个重要特征：**有穷性、确定性、可行性、输入、输出**。

一个算法的优劣评价的方面：**正确性、可读性、健壮性、高效性**。
高效性包括时间和空间两个方面：
时间高效是指算法设计合理，执行效率高，可以用**时间复杂度**来度量
空间高效是指算法占用存储容量合理，可以用**空间复杂度**来度量
**时间复杂度和空间复杂度是衡量算法的两个主要指标。**

衡量算法效率的方法主要有两种：事后统计法和事前分析估算法。
通常采用事前分析估算法，通过计算算法的渐进复杂度来衡量算法的效率。

### 渐进时间复杂度

**一般情况下对于算法中基本语句的执行的是问题规模n的某个函数f(n)，我们用"O"来表示数量级，算法的时间量度记作**
**T(n) = O(f(n))**
**它表示随问题规模n的增大，算法执行时间的增长率和 f(n) 的增长率相同，称做算法的渐渐时间复杂度，简称时间复杂度(Time Complexity).**

**问题规模：**问题规模是算法求解问题输入量的多少，是问题大小的本质表示，一般用整数n表示
**语句频度：**一条语句的重复执行次数

「 以下代码来自书中 」

**一个算法的执行时间大致上等于所有语句执行时间的总和，而语句的执行时间则为该条语句的财富执行次数和执行一次所需时间的乘积。**

```C
两个n阶矩阵的乘积算法
设每条语句执行一次所需时间均为单位时间，n为执行规模

for(i=1; i<=n; i++)                                                     //频度为 n+1
    for(j=1; j<=n; j++){                                                //频度为 n*(n+1)
        c[i][j] = 0;                                                    //频度为 n^2
        for(k=1; k<=n; k++)                                             //频度为 n^2 * (n+1)
        c[i][j] = c[i][j] + a[i][k] * b[k][j];                          //频度为 n^3
    }

该算法中所有语句频度的和 f(n) = 2n^3 + 3n^2 + 2n + 1
```

**为了客观反映一个算法的执行时间，可以通过算法中“基本语句”(重复执行次数和算法的执行时间成正比的语句，它对算法运行时间的贡献最大) 执行次数来度量算法的工作量。**
**通常，算法的执行时间随问题规模增长而增长，因此对算法的评价只需考虑其随问题规模增长的趋势。**

```Markdown
上面那个例子,当执行规模n趋向无穷大时
f(n) / n^3  的极限等于2
也就是当n充分大时，f(n) 和 n^3 的比是一个不等于0的常数
即 f(n) 和 n^3 同阶(数量级Order of Magnitude相同)
时间复杂度T(n) = O(f(n)) = O(n^3)
```

```Text
关于常量阶
当语句频度为1时，算法执行时间是一个与问题规模n无关的常数，即T(n) = O(1)，称为常量阶。
只要算法执行时间不随问题规模n增长而增长，算法中语句的频度就是某个常数，无论这个常数多大，算法的时间复杂度都是O(1)。
例如：for(i=0;i<10000;i++){x++;s=0;}


关于线性阶
循环体内两条基本语句的频度均为 f(n)=n，算法的时间复杂度为 T(n) = O(n)，称为线性阶。
当算法的基本语句频度最大为 n^2 时，T(n) = O(n^2)， 则为平方阶；
同样，当频度最大为 n^3 时，则为立方阶。


对数阶示例

i = 1;
while (i <= n)
    i = i*3;

设循环体里面的基本语句的频度为 f(n)
也就是执行了 f(n) 次 i*3
所以执行完 i的值为 3^f(n)
由于 i<=n，所以 3^f(n) <= n
可得到 f(n) <= log_3 n
所以这个程序的时间复杂度为f(log3 n)


最好、最坏、平均时间复杂度
对于某些问题，算法的基本语句的频度不仅仅和问题的规模有关，还依赖于其他因素，例如：未知的输入值、随机的初始化等等。
这些问题的算法，在计算时间复杂度的时候需要考虑各种情况。
称算法在最好情况下的时间复杂度为最好时间复杂度；最坏情况下算法的时间复杂度为最坏时间复杂度，分别指的是算法计算量可能达到的最小值和最大值。
算法的平均时间复杂度是指算法在所有情况下，按照输入实例以等概率出现时，算法计算量的加权平均值。
一般来说，人们更关心的是平均情况下和最坏情况下的时间复杂度，但是算法的平均时间复杂度难以确定。
```

### 渐进空间复杂度

**和时间复杂度类似，渐进空间复杂度(Space Complexity)作为算法所需存储空间的量度，它也是问题规模n的函数，记作S(n) = O(f(n))**
在分析时，输入数据所占的具体存储量取决于问题，和算法无关，所以秩序分析该算法在实现是所需要的辅助空间就行了。
若算法实现时所需的辅助存储空间相对于输入数据量而言是个常数，与问题本身无关，则称这个算法为原地工作，辅助空间为O(1)。

```C
示例：

for(i=0;i<n/2;i++){
    t = a[i];
    a[i] = a[n-i-1];
    a[n-i-1] = t;
}

由于算法只需借助一个变量t，与问题规模n的大小无关，所以其空间复杂度为O(1)


for(i=0;i<n;i++)
    b[i] = a[n-i-1];
for(i=0;i<n/2;i++)
    a[i] = b[i];

算法需要借助一个大小为n的辅助数组b，所以其空间复杂度为O(n)
```

>参考：人民邮电出版社《数据结构    C语言版|第二版》严蔚敏
