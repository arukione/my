<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ARUKI&#39;S BLOG</title>
  
  <subtitle>有机少年</subtitle>
  <link href="/arukione.github.io/atom.xml" rel="self"/>
  
  <link href="http://arukione.com/"/>
  <updated>2019-09-15T09:19:16.765Z</updated>
  <id>http://arukione.com/</id>
  
  <author>
    <name>aruki</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Welcome</title>
    <link href="http://arukione.com/2019/09/15/Welcome/"/>
    <id>http://arukione.com/2019/09/15/Welcome/</id>
    <published>2019-09-15T06:36:09.644Z</published>
    <updated>2019-09-15T09:19:16.765Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 15 2019 23:34:41 GMT+0800 (GMT+08:00) --><p><strong>欢迎来到ARUKI’ BLOG,你可以在这里寻找对您有帮助的文章。</strong><br><strong>目前博客仍在建设中，如果对本博客有任何意见，欢迎联系我并提出您的问题！！</strong></p><p><strong>Welcome to my blog! You can find articles that useful for you.</strong><br><strong>At present, the blog is still under construction, if you have any comments on this blog, please contact me and raise your questions!!</strong></p><p><strong>ようこそ　ARUKI’ BLOG、ここで君の役に立つ文章を探すことができます。</strong><br><strong>现在、ブログ建设中ですが、もしこのブログに何か意见があれば、私を连络して问题を提出してくだいさい! !</strong></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Sep 15 2019 23:34:41 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;&lt;strong&gt;欢迎来到ARUKI’ BLOG,你可以在这里寻找对您有帮助的文章。&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;目前博客仍在建设中，
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>数据结构基础</title>
    <link href="http://arukione.com/2019/09/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/"/>
    <id>http://arukione.com/2019/09/11/数据结构基础/</id>
    <published>2019-09-10T16:00:00.000Z</published>
    <updated>2019-09-15T15:40:29.161Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 15 2019 23:42:01 GMT+0800 (GMT+08:00) --><h2 id="基本概念和术语"><a href="#基本概念和术语" class="headerlink" title="基本概念和术语"></a>基本概念和术语</h2><p><strong>数据(Data)：</strong>客观事物的符号表示，是所有能输入到计算机中并被计算机程序处理的符号的总称 (别问我这个解释，我也看不太懂，只可意会不可言传)</p><p><strong>数据元素(Data Element)：</strong>数据的基本单位，在计算机中通常作为一个整体进行考虑和处理</p><p><strong>数据项(Data Item)：</strong>组成数据元素的、有独立含义的、不可分割的最小单位</p><p><strong>数据对象(Data Object)：</strong>是性质相同的数据元素的集合，是数据的一个子集</p><div class="note info"><p>数据是什么？如何理解数据对象？什么是性质相同的数据元素的集合？<br>数据对象相当于数据的一部分内容，而这部分内容里面的元素都有相同的特点，举个例子：</p><p>数据 一个班级里面的学生<br>数据对象 一个班里学生的信息表<br>数据元素 学生信息表的每一条数据都是数据元素<br>数据项 学生信息表里面的每一项信息</p><p>这里面，学生的信息表是学生的一个部分内容，学生可以包含很多内容，除了信息表，还有成绩单，身份内容，这些都算是学生这个数据的一部分，也就是数据的子集，即数据对象。而学生信息表里面会含有很多个信息项，例如姓名学号、专业、性别等等，这些信息项就是数据项，有着独立的含义。信息表里面的每一个学生的数据，都算是一个数据元素，这些学生的数据构和数据项构造成了信息表，所以数据对象是数据元素的集合。</p></div><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p><strong>数据结构(Data Stucture)：是相互之间存在一种或多种特定关系的数据元素的集合。</strong><br>数据结构其实就是带有“结构”的数据元素的集合。不过说是数据元素的集合，我们平时的理解更多的是倾向于结构，学得主要也是结构，但这个名词本身指的还是集合！<br>数据结构包括逻辑结构和储存结构两个层次。</p><h4 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h4><p><strong>逻辑结构是对于数据来讲的，从逻辑关系上描述数据，和数据的储存无关，独立于计算机。</strong><br><strong>数据的逻辑结构分为：线性结构和非线性结构。</strong></p><p>四类基本逻辑结构：</p><p><strong>集合结构：</strong>数据元素除了属于同一集合外，没有其他关系<br><strong>线性结构：</strong>数据元素之间存在一对一的关系<br><strong>树结构：</strong>数据元素之间存在一对多的关系<br><strong>图结构或网状结构：</strong>数据元素之间存在多对多的关系</p><p>下面图示，会更容易理解</p><p><img src="/images/数据的逻辑结构.png" alt="数据的逻辑结构层次图"></p><h4 id="储存结构"><a href="#储存结构" class="headerlink" title="储存结构"></a>储存结构</h4><p><strong>储存结构也称为物理结构，指的是数据对象在计算机中的存储方式。</strong><br>通常要求数据对象在存入计算机时既要存储数据元素的数据，也要存储数据元素之间的逻辑关系，数据元素在计算机内用一个结点来表示。</p><p>数据元素在计算机中的两种基本储存结构：</p><p><strong>顺序存储结构：</strong>借助元素在存储器中的相对位置来表示数据元素之间的逻辑关系，要求所有的元素依次存放在一片连续的存储空间中</p><p><strong>链式存储结构：</strong>无需占用一整块存储空间，为了表示结点之间的关系，给每个结点附加指针字段，用于存放后继元素的存储地址。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">课外补充：</span><br><span class="line">逻辑结构与数据元素本身的形式、内容、相对位置、个数无关。</span><br><span class="line">一些表面上很不相同的数据可以有相同的逻辑结构</span><br><span class="line">通常要求同一逻辑结构中的所有数据元素具有相同的特性，这意味着不仅数据元素所包含的数据项的个数要相同，而且对应数据项的类型要一致</span><br></pre></td></tr></table></figure><h2 id="算法和算法分析"><a href="#算法和算法分析" class="headerlink" title="算法和算法分析"></a>算法和算法分析</h2><p><strong>算法：</strong>是为了解决某类问题而规定的一个有限长的操作序列<br>一个算法必须满足的五个重要特征：<strong>有穷性、确定性、可行性、输入、输出</strong>。</p><p>一个算法的优劣评价的方面：<strong>正确性、可读性、健壮性、高效性</strong>。<br>高效性包括时间和空间两个方面：<br>时间高效是指算法设计合理，执行效率高，可以用<strong>时间复杂度</strong>来度量<br>空间高效是指算法占用存储容量合理，可以用<strong>空间复杂度</strong>来度量<br><strong>时间复杂度和空间复杂度是衡量算法的两个主要指标。</strong></p><p>衡量算法效率的方法主要有两种：事后统计法和事前分析估算法。<br>通常采用事前分析估算法，通过计算算法的渐进复杂度来衡量算法的效率。</p><h3 id="渐进时间复杂度"><a href="#渐进时间复杂度" class="headerlink" title="渐进时间复杂度"></a>渐进时间复杂度</h3><p><strong>一般情况下对于算法中基本语句的执行的是问题规模n的某个函数f(n)，我们用”O”来表示数量级，算法的时间量度记作</strong><br><strong>T(n) = O(f(n))</strong><br><strong>它表示随问题规模n的增大，算法执行时间的增长率和 f(n) 的增长率相同，称做算法的渐渐时间复杂度，简称时间复杂度(Time Complexity).</strong></p><p><strong>问题规模：</strong>问题规模是算法求解问题输入量的多少，是问题大小的本质表示，一般用整数n表示<br><strong>语句频度：</strong>一条语句的重复执行次数</p><p>「 以下代码来自书中 」</p><p><strong>一个算法的执行时间大致上等于所有语句执行时间的总和，而语句的执行时间则为该条语句的财富执行次数和执行一次所需时间的乘积。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">两个n阶矩阵的乘积算法</span><br><span class="line">设每条语句执行一次所需时间均为单位时间，n为执行规模</span><br><span class="line"></span><br><span class="line">for(i=1; i&lt;=n; i++)                                                     //频度为 n+1</span><br><span class="line">    for(j=1; j&lt;=n; j++)&#123;                                                //频度为 n*(n+1)</span><br><span class="line">        c[i][j] = 0;                                                    //频度为 n^2</span><br><span class="line">        for(k=1; k&lt;=n; k++)                                             //频度为 n^2 * (n+1)</span><br><span class="line">        c[i][j] = c[i][j] + a[i][k] * b[k][j];                          //频度为 n^3</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">该算法中所有语句频度的和 f(n) = 2n^3 + 3n^2 + 2n + 1</span><br></pre></td></tr></table></figure><p><strong>为了客观反映一个算法的执行时间，可以通过算法中“基本语句”(重复执行次数和算法的执行时间成正比的语句，它对算法运行时间的贡献最大) 执行次数来度量算法的工作量。</strong><br><strong>通常，算法的执行时间随问题规模增长而增长，因此对算法的评价只需考虑其随问题规模增长的趋势。</strong><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">上面那个例子,当执行规模n趋向无穷大时</span><br><span class="line">f(n) / n^3  的极限等于2</span><br><span class="line">也就是当n充分大时，f(n) 和 n^3 的比是一个不等于0的常数</span><br><span class="line">即 f(n) 和 n^3 同阶(数量级Order of Magnitude相同)</span><br><span class="line">时间复杂度T(n) = O(f(n)) = O(n^3)</span><br></pre></td></tr></table></figure><p></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">关于常量阶</span><br><span class="line">当语句频度为1时，算法执行时间是一个与问题规模n无关的常数，即T(n) = O(1)，称为常量阶。</span><br><span class="line">只要算法执行时间不随问题规模n增长而增长，算法中语句的频度就是某个常数，无论这个常数多大，算法的时间复杂度都是O(1)。</span><br><span class="line">例如：for(i=0;i&lt;10000;i++)&#123;x++;s=0;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">关于线性阶</span><br><span class="line">循环体内两条基本语句的频度均为 f(n)=n，算法的时间复杂度为 T(n) = O(n)，称为线性阶。</span><br><span class="line">当算法的基本语句频度最大为 n^2 时，T(n) = O(n^2)， 则为平方阶；</span><br><span class="line">同样，当频度最大为 n^3 时，则为立方阶。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">对数阶示例</span><br><span class="line"></span><br><span class="line">i = 1;</span><br><span class="line">while (i &lt;= n)</span><br><span class="line">    i = i*3;</span><br><span class="line"></span><br><span class="line">设循环体里面的基本语句的频度为 f(n)</span><br><span class="line">也就是执行了 f(n) 次 i*3</span><br><span class="line">所以执行完 i的值为 3^f(n)</span><br><span class="line">由于 i&lt;=n，所以 3^f(n) &lt;= n</span><br><span class="line">可得到 f(n) &lt;= log_3 n</span><br><span class="line">所以这个程序的时间复杂度为f(log3 n)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">最好、最坏、平均时间复杂度</span><br><span class="line">对于某些问题，算法的基本语句的频度不仅仅和问题的规模有关，还依赖于其他因素，例如：未知的输入值、随机的初始化等等。</span><br><span class="line">这些问题的算法，在计算时间复杂度的时候需要考虑各种情况。</span><br><span class="line">称算法在最好情况下的时间复杂度为最好时间复杂度；最坏情况下算法的时间复杂度为最坏时间复杂度，分别指的是算法计算量可能达到的最小值和最大值。</span><br><span class="line">算法的平均时间复杂度是指算法在所有情况下，按照输入实例以等概率出现时，算法计算量的加权平均值。</span><br><span class="line">一般来说，人们更关心的是平均情况下和最坏情况下的时间复杂度，但是算法的平均时间复杂度难以确定。</span><br></pre></td></tr></table></figure><h3 id="渐进空间复杂度"><a href="#渐进空间复杂度" class="headerlink" title="渐进空间复杂度"></a>渐进空间复杂度</h3><p><strong>和时间复杂度类似，渐进空间复杂度(Space Complexity)作为算法所需存储空间的量度，它也是问题规模n的函数，记作S(n) = O(f(n))</strong><br>在分析时，输入数据所占的具体存储量取决于问题，和算法无关，所以秩序分析该算法在实现是所需要的辅助空间就行了。<br>若算法实现时所需的辅助存储空间相对于输入数据量而言是个常数，与问题本身无关，则称这个算法为原地工作，辅助空间为O(1)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line"></span><br><span class="line">for(i=0;i&lt;n/2;i++)&#123;</span><br><span class="line">    t = a[i];</span><br><span class="line">    a[i] = a[n-i-1];</span><br><span class="line">    a[n-i-1] = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">由于算法只需借助一个变量t，与问题规模n的大小无关，所以其空间复杂度为O(1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for(i=0;i&lt;n;i++)</span><br><span class="line">    b[i] = a[n-i-1];</span><br><span class="line">for(i=0;i&lt;n/2;i++)</span><br><span class="line">    a[i] = b[i];</span><br><span class="line"></span><br><span class="line">算法需要借助一个大小为n的辅助数组b，所以其空间复杂度为O(n)</span><br></pre></td></tr></table></figure><blockquote><p>参考：人民邮电出版社《数据结构 C语言版|第二版》严蔚敏</p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Sep 15 2019 23:42:01 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;基本概念和术语&quot;&gt;&lt;a href=&quot;#基本概念和术语&quot; class=&quot;headerlink&quot; title=&quot;基本概念和术语&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
    
      <category term="学习旅程" scheme="http://arukione.com/categories/%E5%AD%A6%E4%B9%A0%E6%97%85%E7%A8%8B/"/>
    
    
      <category term="-编程学习 -数据结构" scheme="http://arukione.com/tags/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>城院智能路由器</title>
    <link href="http://arukione.com/2019/08/26/%E5%9F%8E%E9%99%A2%E6%99%BA%E8%83%BD%E8%B7%AF%E7%94%B1%E5%99%A8/"/>
    <id>http://arukione.com/2019/08/26/城院智能路由器/</id>
    <published>2019-08-25T16:00:00.000Z</published>
    <updated>2019-09-15T08:48:32.779Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 15 2019 23:34:41 GMT+0800 (GMT+08:00) --><p><strong>度过了一年城院生活，宿舍最想吐槽的，就是网络了！</strong><br>一年400块钱，只有20M，还不稳定！？<br>使用时间是早上6：00 ~ 晚上00：07，周末不断网，时间还非常精准，<br><strong>每次使用都要登录dr认证页面和天翼认证页面，5分钟不连wifi就断开验证</strong>，要重新连接，这就很烦了。<br>不能多个人连接，就算买了路由器，也<strong>同一条网线只能连接一台电脑和两个设备连接</strong>，那我还买路由器干嘛？直接电脑连了网络放热点不好吗…<br>值得注意的是<strong>当你的电脑使用WIFI接入网络时会被判定为设备</strong>,如果再有两台手机接入就会被强制注销。<br><strong>超过连接数限制就会被强制注销</strong>，一段时间不能连接网络，关键是，不超限制，<strong>偶尔还被注销了</strong>。</p><p>可能有一些新生会觉得，这种校园网网上破解方法不是很多吗？<br>其实那些方法都和城院的校园网不对点，所以在城院内根本行不通<br>以前我也尝试弄过破解，因为学校的限制是学生弄的，所以我觉得应该会有什么漏洞可以钻，<br>所以我上网查了很多方法，例如安装锐捷等网络插件，或者使用55号端口偷跑网络，我甚至还试过用自己的服务器绕过验证<br>但是都失败了……现在感觉那时候挺傻的，根本就是浪费时间，要想破解校园网还是得针对学校网络敲代码<br><img src="/images/表情包/像素瘫倒.jpg" alt="像素瘫倒"><br><strong>以上是吐槽，还好在师兄的研究下，写了破解程序，推出了校园智能路由器，可以解决上面那些问题！</strong><br>(没错，我就是来帮忙宣传路由器的！反正你们打不到我…)<br><img src="/images/表情包/别打了.jpg" alt="别打了"></p><p><strong>下面是校园智能路由器的宣传</strong></p><h2><a href="#" class="headerlink"></a><b></b></h2><p></p><h6 align="center"><b><p></p><h3>校园智能路由器出售</h3><p>================<br>还在为校园网天天手动验证而烦恼吗？<br>还在为校园网只能连有限设备烦恼吗？<br>莫得关系，这些都不是问题</p><p>=================================<br>智能路由器function<br>①循环验证校园网，拒绝手动验证<br>②可连接多台设备，<br>③更多功能私聊我，详细为你解答</p><p>=================================<br>智能路由器将采用刷机级路由器<br>同时采用集成多功能潘多拉固件<br>两大殿堂级的碰撞给你最好的上网体验<br>路由器并不是针对wifi进行破解，而是针对学校的限制和网页登录<br>对于wifi质量完全没影响！！！</p><p>=================================<br>智能路由器的两大版本<br>①标准版：2.4G频率支持，usb接口，百兆端口，小巧玲珑<br><img src="/images/路由器/路由器1.jpg" alt="路由器图片"><img src="/images/路由器/路由器2.jpg" alt="路由器图片"><br>②pro版：独立型四天线，双核cpu，双频wifi<br>512m内存，32m闪存，4lan，千兆端口，同时配备usb3.0接口<br><img src="/images/路由器/路由器3.jpg" alt="路由器图片"><img src="/images/路由器/路由器4.jpg" alt="路由器图片"><br>欢迎联系咨询</p><h2 id="-1"><a href="#-1" class="headerlink"></a></h2></b></h6><p>emmmm….<br>看起来好像和普通的路由器没什么区别，其实是师兄们在路由器写入了破解程序，所以功能比普通的路由器多，<br>有了这个路由器就<strong>不用手动登录校园网了，而且一个wifi可以给多台设备使用，不会被强制注销</strong>。<br>这样就不用花 <strong>4x400=1600(四人间) 或者 6x400=2400(六人间)</strong> 块钱去每个人办理一条宽带了(还没算上买非破解路由器的钱)。<br>一个宿舍办理<strong>一条宽带 + 一个破解路由器</strong>，这样可以把支出降低到<strong>700以下</strong>，<br>就算是6人间办理两条宽带买两个路由器花的钱也<strong>不会超过1500</strong>，<br><strong>比起原先没破解的时候，现在弄了破解可以省下很多钱了。</strong></p><p>附上师兄的联系方式：</p><p>微信号：jiehaobin （晚上活动白天睡觉）<br>如果这位师兄联系不上<del>(猝死了)</del>可以加另外一位师兄的微信：ChenShisan_13<br><img src="/images/路由器/路由器微信.jpg" alt="二维码" title="微信二维码"></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Sep 15 2019 23:34:41 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;&lt;strong&gt;度过了一年城院生活，宿舍最想吐槽的，就是网络了！&lt;/strong&gt;&lt;br&gt;一年400块钱，只有20M，还不稳定！？&lt;br&gt;使用时
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Python程序打包成exe可执行文件</title>
    <link href="http://arukione.com/2019/06/02/python%E7%A8%8B%E5%BA%8F%E6%89%93%E5%8C%85%E6%88%90exe%E6%96%87%E4%BB%B6/"/>
    <id>http://arukione.com/2019/06/02/python程序打包成exe文件/</id>
    <published>2019-06-01T16:00:00.000Z</published>
    <updated>2019-09-15T15:41:36.838Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 15 2019 23:42:01 GMT+0800 (GMT+08:00) --><h3 id="本教程是使用Pyinstaller来将Python程序打包成exe可执行文件"><a href="#本教程是使用Pyinstaller来将Python程序打包成exe可执行文件" class="headerlink" title="本教程是使用Pyinstaller来将Python程序打包成exe可执行文件"></a>本教程是使用Pyinstaller来将Python程序打包成exe可执行文件</h3><h3 id="实现步骤："><a href="#实现步骤：" class="headerlink" title="实现步骤："></a><strong>实现步骤：</strong></h3><p><strong>首先要安装Pyinstaller包，在命令行窗口使用pip指令就可以完成：</strong><br><code>pip install pyinstaller</code><br><strong>安装成功后就可以进行打包了</strong><br><strong>首先在命令行进入要打包的python程序的目录下面</strong><br><strong>接着使用</strong> <code>pyinstaller file.py</code> <strong>就可以打包了(file.py是指你要打包的python文件)</strong><br><strong>这个指令也可以附带其他属性：</strong><br></p><div class="note info"><p><strong>-F 表示生成单个可执行文件</strong></p><p><strong>-D 创建一个目录，包含exe文件和依赖很多文件（默认选项）</strong></p><p><strong>-w 表示去掉控制台窗口，这样执行exe文件的时候不会出现窗口，但会在后台运行，用命令行还是可以看见执行情况的</strong></p><p><strong>-c 使用控制台，无界面(默认)；</strong></p><p><strong>-p 表示你自己自定义需要加载的类路径</strong></p><p><strong>-i 表示可执行文件的图标。</strong></p></div><br><strong>例如我要生成一个带图标的exe文件，没有其他依赖文件的，那么就是使用指令：</strong><br><code>pyinstaller -F -i image.ico file.py</code> <strong>（image.ico表示图标的路径，file.py表示要打包的python文件）</strong><br><strong>打包后会生成dict文件夹和buid文件夹还有一个.spec文件，其中dict就是放置我们要的exe文件的文件夹，其他两个是生成exe文件的过程中的中间产物，可以删掉。</strong><br><strong>pyinstaller打包的时候会自动把其他依赖的包和其他python文件引入，所以不用担心调用的问题。</strong><br><strong>但是其他要使用到的文件并不会被添加进去，例如要使用的图片或者文档，所以要自己把文件添加到打包完的exe文件的目录下面相应的路径，否则会出现闪退或者文件执行失败。</strong><br><strong>另外就是，如果py文件的编码是utf8，但是文件里面又有中文的话，那么使用windows的命令行打包会出现编码错误。</strong><br><strong>解决的方法就是先使用chcp指令进入其他编码的命令行</strong><br><div class="note info"><p><strong>以下是几种常用的编码:</strong><br><strong>GBK(一般情况下为默认编码) 936</strong><br><strong>美国英语 437</strong><br><strong>utf-8 65001</strong></p></div><br><strong>在这里我们要使用utf-8的编码，所以使用命令:</strong><br><code>chcp 65001</code><br><strong>设置编码后再进行打包就不会出现编码错误的情况了</strong><p></p><p><strong>最后就是，第一次打包出来的程序经常会出现各种问题，建议在命令行执行exe文件，这样可以看到报错的内容，以便结合情况解决问题。</strong></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Sep 15 2019 23:42:01 GMT+0800 (GMT+08:00) --&gt;&lt;h3 id=&quot;本教程是使用Pyinstaller来将Python程序打包成exe可执行文件&quot;&gt;&lt;a href=&quot;#本教程是使用Pyinstaller
      
    
    </summary>
    
    
      <category term="Python" scheme="http://arukione.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://arukione.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>天翼校园网验证码识别</title>
    <link href="http://arukione.com/2019/05/25/%E5%A4%A9%E7%BF%BC%E6%A0%A1%E5%9B%AD%E7%BD%91%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB/"/>
    <id>http://arukione.com/2019/05/25/天翼校园网验证码识别/</id>
    <published>2019-05-24T16:00:00.000Z</published>
    <updated>2019-09-15T06:36:09.659Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 15 2019 23:34:41 GMT+0800 (GMT+08:00) --><p><strong>本菜鸡能力有限，本文章主要目的是为了完成自动登录校园网，不是为了教学……</strong><br><strong>依靠之前学的一个神经网络，尝试写一个识别天翼验证码的代码</strong><br>其实是为了破解那个不得不吐槽的校园网，不得不捣鼓的东西……</p><p><strong>如果不懂爬虫，神经网络的构造，梯度下降算法和反向传播算法，请先找资料学习相关知识，网上有很多讲解的文章，B站也有很多视频</strong></p><p><strong>首先训练神经网络需要一点训练数据，而且，写的那个神经网络也不是靠深度学习框架的，所以识别的时候是采取分别识别验证码里面的4个数字的方式。</strong><br><strong>幸好，天翼的验证码里的数字，非常简单，没有那些奇奇怪怪的加工，每个数字都是一样的，所以训练数据也不用那么多。</strong><br><strong>写一个爬虫抓取一下验证码图片，然后把图片分割一下，就可以得到训练数据了。</strong><br><strong>因为验证码里面的数字都长得一样，这里我每个数字就只用了10张图片来训练</strong><br><img src="\images\天翼验证码训练集图片.png" alt="训练数据数字0~9"></p><p><strong>接下来是训练神经网络</strong><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">class neuralNetwork():</span><br><span class="line"></span><br><span class="line">    # 初始化神经网络</span><br><span class="line">    def __init__(self):</span><br><span class="line">        # 定义输入层节点数量</span><br><span class="line">        self.inputnodes = 13 * 9</span><br><span class="line">        # 定义隐藏层节点数量</span><br><span class="line">        self.hiddennodes = 300</span><br><span class="line">        # 定义输出层节点数量</span><br><span class="line">        self.outnodes = 10</span><br><span class="line">        # 随机初始化权重</span><br><span class="line">        self.input_hidden_weight = random.normal(0.0, pow(self.hiddennodes, -0.5), (self.hiddennodes, self.inputnodes))</span><br><span class="line">        self.hidden_out_weight = random.normal(0.0, pow(self.outnodes, -0.5), (self.outnodes, self.hiddennodes))</span><br><span class="line">        # 设置学习率</span><br><span class="line">        self.learning_rate = 0.1</span><br><span class="line">        # 定义激活函数</span><br><span class="line">        self.activation_function = lambda x: expit(x)</span><br><span class="line"></span><br><span class="line">    def train(self, inputs, targets):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :param inputs: 输入的图片数组</span><br><span class="line">        :param targets: 预测得到的结果</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        # 转化输入的数据</span><br><span class="line">        inputs = nparray(inputs, ndmin=2).T</span><br><span class="line">        # 转化预测的数据</span><br><span class="line">        targets = nparray(targets, ndmin=2).T</span><br><span class="line">        # 神经网络的识别结果</span><br><span class="line">        hidden_inputs = dot(self.input_hidden_weight, inputs)</span><br><span class="line">        hidden_outputs = self.activation_function(hidden_inputs)</span><br><span class="line">        out_inputs = dot(self.hidden_out_weight, hidden_outputs)</span><br><span class="line">        final_outputs = self.activation_function(out_inputs)</span><br><span class="line">        # 分配输出层、隐藏层的各节的损失值</span><br><span class="line">        out_error = targets - final_outputs</span><br><span class="line">        hidden_error = dot(self.hidden_out_weight.T, out_error)</span><br><span class="line">        # 更新权重</span><br><span class="line">        self.hidden_out_weight += self.learning_rate * dot((out_error * final_outputs * (1.0 - final_outputs)),</span><br><span class="line">                                                           hidden_outputs.T)</span><br><span class="line">        self.input_hidden_weight += self.learning_rate * dot((hidden_error * hidden_outputs * (1.0 - hidden_outputs)),</span><br><span class="line">                                                             inputs.T)</span><br><span class="line"></span><br><span class="line">    def query(self, inputs):</span><br><span class="line">        inputs = nparray(inputs, ndmin=2).T</span><br><span class="line">        hidden_inputs = dot(self.input_hidden_weight, inputs)</span><br><span class="line">        hidden_outputs = self.activation_function(hidden_inputs)</span><br><span class="line">        out_inputs = dot(self.hidden_out_weight, hidden_outputs)</span><br><span class="line">        final_outputs = self.activation_function(out_inputs)</span><br><span class="line">        max = argmax(final_outputs)</span><br><span class="line">        return max</span><br></pre></td></tr></table></figure><p></p><p><strong>用这个类代表神经网络，激活函数是使用sigmoid函数,这个函数在python里面已经内置在scipy库里面了，直接调用scipy.special的expit()函数就可以了</strong><br><strong>query函数是神经网络识别图片函数，train函数是训练神经网络的函数，训练时用的算法是梯度下降和反向传播。</strong><br><strong>把分割的数字图片转化为numpy数据传入train方法就可以对神经网络进行训练。</strong><br><strong>权重更新方式使用梯度下降算法来获取更优的权重</strong><br><strong>以下是图片的转化函数</strong><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">def get_data(image, select):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    转化图片数据</span><br><span class="line">    :param image: 图片</span><br><span class="line">    :param select: 0代表输入整张验证码，返回4个数字的3维numpy数组    1代表输入一个数字，返回一个2维的numpy数组</span><br><span class="line">    :return: data or imdata</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    if select == 0:</span><br><span class="line">        # 分割图片</span><br><span class="line">        numdata = []</span><br><span class="line">        number = image.crop((7, 3, 55, 16)).convert(&apos;L&apos;)</span><br><span class="line">        num1 = number.crop((0, 0, 9, 13))</span><br><span class="line">        num2 = number.crop((13, 0, 22, 13))</span><br><span class="line">        num3 = number.crop((26, 0, 35, 13))</span><br><span class="line">        num4 = number.crop((39, 0, 48, 13))</span><br><span class="line">        numlist = [num1, num2, num3, num4]</span><br><span class="line">        for num in numlist:</span><br><span class="line">            two = num.convert(&apos;1&apos;)</span><br><span class="line">            array = nparray(two)</span><br><span class="line">            list = array.tolist()</span><br><span class="line">            data = []</span><br><span class="line">            for l in list:</span><br><span class="line">                for i in l:</span><br><span class="line">                    data.append(i)</span><br><span class="line">            numdata.append(data)</span><br><span class="line">        data = nparray(numdata) * 0.89 + 0.1</span><br><span class="line">        return data</span><br><span class="line">    if select == 1:</span><br><span class="line">        two = image.convert(&apos;1&apos;)</span><br><span class="line">        array = nparray(two)</span><br><span class="line">        list = array.tolist()</span><br><span class="line">        data = []</span><br><span class="line">        for l in list:</span><br><span class="line">            for i in l:</span><br><span class="line">                data.append(i)</span><br><span class="line">        imdata = nparray(data) * 0.89 + 0.1</span><br><span class="line">        return imdata</span><br></pre></td></tr></table></figure><p></p><p><strong>以下是我用到的训练函数</strong><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">def network_train(network):</span><br><span class="line">    for ii in range(0, 11):</span><br><span class="line">        for i in range(0, 10):</span><br><span class="line">            image = Image.open(&quot;number/&quot; + str(i) + &quot;/&quot; + str(ii) + &quot;.jpg&quot;)</span><br><span class="line">            inputs = get_data(image, 1)</span><br><span class="line">            targes = zeros(10) + 0.1</span><br><span class="line">            targes[i] = 0.99</span><br><span class="line">            network.train(inputs, targes)</span><br><span class="line">    try:</span><br><span class="line">        os.remove(&apos;input_hidden_weight.txt&apos;)</span><br><span class="line">        os.remove(&apos;hidden_out_weight.txt&apos;)</span><br><span class="line">        print(&apos;重置权重文件&apos;)</span><br><span class="line">    except:</span><br><span class="line">        print(&apos;创建权重文件&apos;)</span><br><span class="line">    savetxt(&quot;input_hidden_weight.txt&quot;, network.input_hidden_weight)</span><br><span class="line">    savetxt(&quot;hidden_out_weight.txt&quot;, network.hidden_out_weight)</span><br></pre></td></tr></table></figure><p></p><p><strong>因为这个验证码很简单，所以我没打算分测试数据，把全部图片训练完，这个神经网络就可以调用query方法来识别验证码了。</strong><br><strong>为了不用每次识别验证码都训练一次，我在把训练出来的模型的权重保存在文件里面，以便以后直接拿文件里面的模型来用。</strong></p><p><strong>代码文件、训练数据、模型权重文件，我都放在github里面</strong></p><p>github代码链接：<br><a href="https://github.com/arukione/verification-code/tree/master/%E5%A4%A9%E7%BF%BC%E6%A0%A1%E5%9B%AD%E7%BD%91%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB" target="_blank" rel="noopener">https://github.com/arukione/verification-code/tree/master/%E5%A4%A9%E7%BF%BC%E6%A0%A1%E5%9B%AD%E7%BD%91%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Sep 15 2019 23:34:41 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;&lt;strong&gt;本菜鸡能力有限，本文章主要目的是为了完成自动登录校园网，不是为了教学……&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;依靠之前学的一
      
    
    </summary>
    
    
      <category term="AI" scheme="http://arukione.com/categories/AI/"/>
    
    
      <category term="Python" scheme="http://arukione.com/tags/Python/"/>
    
      <category term="神经网络" scheme="http://arukione.com/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>MySQL安装到登陆的问题</title>
    <link href="http://arukione.com/2019/04/08/MySQL%E5%AE%89%E8%A3%85%E5%88%B0%E7%99%BB%E9%99%86%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://arukione.com/2019/04/08/MySQL安装到登陆的问题/</id>
    <published>2019-04-07T16:00:00.000Z</published>
    <updated>2019-09-15T06:36:09.640Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 15 2019 23:34:41 GMT+0800 (GMT+08:00) --><div class="note warning"><p><strong>经过一晚上的折腾，我终于登陆进数据库了！！这期间遇到了不少问题，虽然网上有很多解决方案，但要找到适用的真的不容易，每个问题都花了很长时间去尝试那些指令，绕了很多弯路才解决。</strong></p></div><h3 id="端口冲突"><a href="#端口冲突" class="headerlink" title="端口冲突"></a>端口冲突</h3><p><strong>安装完遇到的第一个问题就是，没办法打开mysql服务，删了安装目录下的date文件夹重新用<code>mysqld --initialize</code>初始化，重新配置my.ini文件都没用。</strong><br><strong>之后用<code>mysqld --console</code>查了错误信息发现了端口被占用了：</strong></p><blockquote><p><strong>[ERROR] Can’t start server: Bind on TCP/IP port: Address already in use</strong><br><strong>[ERROR] Do you already have another mysqld server running on port: 3306 ?</strong></p></blockquote><p><strong>因为我这边的命令行无法识别<code>netstat -nltp|grep mysql</code>，到后面才用<code>netstat -aon|findstr 3306</code>查到了占用3306端口的进程，记住了进程后面的PID号，用<code>taskkil /f /pid 对应的PID号</code>把进程给杀了才解决问题</strong></p><h3 id="无法登陆"><a href="#无法登陆" class="headerlink" title="无法登陆"></a>无法登陆</h3><p><strong>耗了一些时间后，我用<code>net start mysql</code>开启了数据库后，用<code>mysql -uroot -密码</code>尝试登陆，结果又报了一个这样的错误</strong></p><blockquote><p><strong>mysql: [ERROR] mysql: unknown option ‘-R’.</strong></p></blockquote><p><strong>于是用<code>mysql -uroot -p</code>后再输入密码,才知道原先输入密码前也要加个p，也就是<code>mysql -uroot -p密码</code>。</strong><br><strong>但是接下来又报了一个错误</strong></p><blockquote><p><strong>mysql: [Warning] Using a password on the command line interface can be insecure.</strong><br><strong>ERROR 1045 (28000): Access denied for user ‘root‘@’localhost’ (using password: YES)</strong></p></blockquote><p><strong>查了一下发现是密码错误，因为我输入的是安装时的密码，但是初始化的时候密码重置了，所以密码错了，所以我又绕了一次弯路，把date删了重新初始化了一遍，把初始化输出的临时密码记了下来</strong></p><blockquote><p><strong>[Note] A temporary password is generated for root@localhost: TKk51x#bOi0S</strong><br><strong>之后就可以成功登陆了</strong></p></blockquote><h3 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h3><p><strong>登陆后没办法使用其他语句，说是必须修改一下密码，而且自动生成的密码太难记了，我想改回自己的密码，但是在网上查了很多指令都用不成功，错误提示的ALTER USER语句也不知道怎么用，所以又上网馊了一下，还看了一下官方文档，总结就是看不懂【</strong><br><strong>查到最后终于发现了一个可以用的语句</strong></p><blockquote><p><code>alter user &#39;root&#39;@&#39;localhost&#39; identified by &#39;password&#39;;</code></p></blockquote><p><strong>这下问题终于解决了，可以开始进一步学习了。</strong></p><div class="note info"><p><strong>虽然遇到了很多问题，但是也知道了很多MySQL和命令行的语句，有些没派上用场就是了，至少折腾了一夜一些有用的语句都变熟悉了。</strong></p></div><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Sep 15 2019 23:34:41 GMT+0800 (GMT+08:00) --&gt;&lt;div class=&quot;note warning&quot;&gt;&lt;p&gt;&lt;strong&gt;经过一晚上的折腾，我终于登陆进数据库了！！这期间遇到了不少问题，虽然网上有很
      
    
    </summary>
    
    
      <category term="数据库" scheme="http://arukione.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MySQL" scheme="http://arukione.com/tags/MySQL/"/>
    
      <category term="windows命令" scheme="http://arukione.com/tags/windows%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>我的学习旅程</title>
    <link href="http://arukione.com/2019/04/04/%E6%88%91%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%97%85%E7%A8%8B/"/>
    <id>http://arukione.com/2019/04/04/我的学习旅程/</id>
    <published>2019-04-03T16:00:00.000Z</published>
    <updated>2019-09-15T06:36:09.663Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 15 2019 23:34:41 GMT+0800 (GMT+08:00) --><div align="center"><h2>2018年</h2><br><strong>加强自己对计算机的认识，更深层地去理解计算机的工作原理</strong><br><strong>从C语言开始认识程序</strong><br><strong>接下来是自己买了服务器搭建梯子，第一次接触脚本</strong><br><strong>慢慢的听到了许多自己没接触过的东西，例如github、node.js、还有前端啊，但是自己都不知道是什么东西</strong><br><strong>自己买了前端的书学习，知道了如何构建网站</strong><br><strong>参与了wiki的建设，发现了更多自己不知道的知识</strong><br><strong>和vultr的客服交流，开启了服务器25号端口</strong><br><strong>学习java，认识到了面向对象</strong><br><br><h2>2019年</h2><br><strong>访问了HackOne网站，开始对网络安全产生兴趣</strong><br><strong>接触linux系统</strong><br><strong>学习了github，明白了github的作用和使用方法</strong><br><strong>接触python，发现python的优点</strong><br><strong>购买了域名，尝试搭建博客</strong><br><strong>初次使用git和githubDesktop，并搭建了自己的博客</strong><br><strong>用githubDesktop给博客做备份</strong><br><strong>学习linux系统和python、java，开始接触数据库</strong><br><strong>学习数据库和python</strong><br><strong>使用python写一个爬虫，借了数据库的书进行进一步学习和练习</strong><br><strong>学习AI，入门机器学习</strong><br><strong>第一次写了一个可以识别数字的神经网络</strong><br><strong>学习python数据结构</strong><br><strong>接触网络和使用刷入固件的路由器</strong><br><h3>七月</h3><br><strong>暑假开始使用ubuntu系统</strong><br><strong>进一步学习机器学习算法，入门TensorFlow深度学习框架</strong><br><strong>学习卷积神经网络结构(CNN)</strong><br><strong>学习对抗神经网络（DCGAN）</strong><br><strong>使用tesra平台，尝试在系统用GPU训练网络，结果安装驱动的时候把ubuntu系统搞坏了（呜呜呜）</strong><br><strong>开始使用debian系统</strong><br></div><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Sep 15 2019 23:34:41 GMT+0800 (GMT+08:00) --&gt;&lt;div align=&quot;center&quot;&gt;&lt;h2&gt;2018年&lt;/h2&gt;&lt;br&gt;&lt;strong&gt;加强自己对计算机的认识，更深层地去理解计算机的工作原理&lt;/
      
    
    </summary>
    
    
      <category term="学习旅程" scheme="http://arukione.com/categories/%E5%AD%A6%E4%B9%A0%E6%97%85%E7%A8%8B/"/>
    
    
      <category term="编程学习" scheme="http://arukione.com/tags/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>机器学习资源分享</title>
    <link href="http://arukione.com/2019/04/04/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90%E5%88%86%E4%BA%AB/"/>
    <id>http://arukione.com/2019/04/04/机器学习资源分享/</id>
    <published>2019-04-03T16:00:00.000Z</published>
    <updated>2019-09-15T15:40:40.417Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 15 2019 23:42:01 GMT+0800 (GMT+08:00) --><div align="center"><br><strong>我只想说虽然很有兴趣，但是学习深度学习太难了！！！</strong><br><strong>所以在这里和大家分享点学习资源，希望能给学习机器学习、深度学习的小伙伴帮助。</strong><br><br><strong>B站机器学习视频：</strong><br><strong>上交ACM机器学习：<a href="https://www.bilibili.com/video/av58580135" target="_blank" rel="noopener">https://www.bilibili.com/video/av58580135</a></strong><br><strong>吴恩达（Ng）机器学习：<a href="https://www.bilibili.com/video/av9912938" target="_blank" rel="noopener">https://www.bilibili.com/video/av9912938</a></strong><br><strong>斯坦福 CS224n 自然语言处理：<a href="https://www.bilibili.com/video/av46216519" target="_blank" rel="noopener">https://www.bilibili.com/video/av46216519</a></strong><br><br><br><strong>ApacheCN学习组织：<a href="https://github.com/apachecn/AiLearning" target="_blank" rel="noopener">https://github.com/apachecn/AiLearning</a></strong><br><strong>斯坦福 CS224n 自然语言处理中文笔记：<a href="https://github.com/apachecn/stanford-cs224n-notes-zh" target="_blank" rel="noopener">https://github.com/apachecn/stanford-cs224n-notes-zh</a></strong><br><br><strong>知乎卷积神经网络讲解：<a href="https://zhuanlan.zhihu.com/c_141391545" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/c_141391545</a></strong><br><br><strong>神经网络&amp;CNN论文（需要翻墙）：<a href="http://cs231n.github.io/" target="_blank" rel="noopener">http://cs231n.github.io/</a></strong><br>我把论文下载为压缩包，给国内的小伙伴们下载学习：<a href="./repositories/maching\ learning/maching\ learning.7z">maching learning.7z</a><br><br><strong>一个有点好玩、能帮助理解的数学可视化视频：</strong><br><strong>深度学习（Deep Learning）：<a href="https://space.bilibili.com/88461692/channel/detail?cid=26587" target="_blank" rel="noopener">https://space.bilibili.com/88461692/channel/detail?cid=26587</a></strong><br><strong>微积分：<a href="https://space.bilibili.com/88461692/channel/detail?cid=13407" target="_blank" rel="noopener">https://space.bilibili.com/88461692/channel/detail?cid=13407</a></strong><br><strong>在B站的全部视频：<a href="https://space.bilibili.com/88461692?spm_id_from=333.788.b_765f7570696e666f.1" target="_blank" rel="noopener">https://space.bilibili.com/88461692?spm_id_from=333.788.b_765f7570696e666f.1</a></strong><br></div><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Sep 15 2019 23:42:01 GMT+0800 (GMT+08:00) --&gt;&lt;div align=&quot;center&quot;&gt;&lt;br&gt;&lt;strong&gt;我只想说虽然很有兴趣，但是学习深度学习太难了！！！&lt;/strong&gt;&lt;br&gt;&lt;stro
      
    
    </summary>
    
    
      <category term="学习旅程" scheme="http://arukione.com/categories/%E5%AD%A6%E4%B9%A0%E6%97%85%E7%A8%8B/"/>
    
    
      <category term="-编程学习 -神经网络 -机器学习" scheme="http://arukione.com/tags/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>使用Hexo-NexT时遇到的问题</title>
    <link href="http://arukione.com/2019/03/29/%E4%BD%BF%E7%94%A8Hexo-NexT%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://arukione.com/2019/03/29/使用Hexo-NexT时遇到的问题/</id>
    <published>2019-03-28T16:00:00.000Z</published>
    <updated>2019-09-15T06:36:09.652Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 15 2019 23:34:41 GMT+0800 (GMT+08:00) --><h1 id="部署到github显示的网页和本地测试的网页不一样"><a href="#部署到github显示的网页和本地测试的网页不一样" class="headerlink" title="部署到github显示的网页和本地测试的网页不一样"></a>部署到github显示的网页和本地测试的网页不一样</h1><p><font size="4"><br>之前设置了网页的背景图片还有側框的边角，同时添加了右上角的github跳转图标和阅读全文的设置。<br>但是在在本地测试完，部署到github时，发现只有github图标和阅读全文的设置生效了，背景图片和边角设置没有体现出来。<br>这是因为github部署的时候缓存加载比较慢，有时候要过一段时间才会显示出你想要的效果，用<code>hexo clean</code>清除一下public文件夹,再重新部署用<code>hexo g -d</code>部署一下，多刷新几次就行了。<br></font><br></p><h1 id="生成了空白的html文件"><a href="#生成了空白的html文件" class="headerlink" title="生成了空白的html文件"></a>生成了空白的html文件</h1><p><font size="4"><br>第一次遇到这个问题的时候，我是直接重新搭建了这个博客的，毕竟一直不知道怎么解决，明明上一步操作还是没问题的，下一步页面突然就崩溃了。<br>后来这个博客又遇到了一次，好在我找到了解决方法：<br>如果找不到index.html文件（在生成的public文件夹里面）的话，要先用<code>npm ls --depth 0</code>检查一下插件情况,如果插件缺失了deploy和generator这两个插件的话就要用<code>npm install</code>重新安装插件。<br><div class="note warning"><p><strong>如果是有html文件，但文件是空白的。那么你就要检查你刚刚修改的配置了，如果你修改一个文件里某一个配置下的某一项，但那一个配置忘记打开的话就会导致这样的情况。</strong></p></div></font></p><p>例如我在主题配置文件里的友情链接links下增加了网易云音乐这一个选项，但是links前面原先有一个#号，我没有删除打开的话，生成的index.html文件就是空白的。<br>而我就是遇到了这种情况，当时不知道是修改了哪一个配置，忘记把#号删了，结果就没有成功生成页面，发现了之后把#号删了就恢复正常了。<br><br></p><h1 id="hexo语句发生错误-Template-render-error-unknown-path"><a href="#hexo语句发生错误-Template-render-error-unknown-path" class="headerlink" title="hexo语句发生错误 Template render error: (unknown path)"></a>hexo语句发生错误 Template render error: (unknown path)</h1><p><font size="4"><br>在我写完另外一篇文章后，打算测试一下，发现无论是hexo g还是hexo s都会报错，于是移除了那篇文章，重新尝试了一下发现可以了。<br>在网上看到似乎不能用}}这样的符号，我回去看那篇文章时发现我有一个}误删了，这才的导致解析不通过。<br>结合之前生成空白html的经历，我发现只要文件里面有一点语法错误都会出现很大问题，如果某次操作突然出错了，记得去检查你最近的修改和文章有没有语法错误。<br></font><br></p><h1 id="左下角多了一个undefined"><a href="#左下角多了一个undefined" class="headerlink" title="左下角多了一个undefined"></a>左下角多了一个undefined</h1><p><font size="4"><br>最新版本的看板娘，在layout/_layout.swig的<code>&lt;/body&gt;</code>前加上{ { live2d() } }，会产生一个默认的看板娘。<br>如果在_config.yml文件中只设置一个，这就会产生冲突，导致有一个无法定义，所以会在页面多出一个undefined语句。<br>在最新版本要把<code>&lt;/body&gt;</code>前的{ { live2d() } }删除，这样才不会出错。<br></font><br></p><h1 id="文件过大push不了"><a href="#文件过大push不了" class="headerlink" title="文件过大push不了"></a>文件过大push不了</h1><p><font size="4"><br>更新404页面的时候，我这404里面插入了一个视频，然后在上传的时候发现github不支持超过100M的文件，所以我把视频删了，重新部署一遍博客。<br>但每次部署都会继续上传我删掉的那个视频，为什么呢？<br>我已经把404文件夹里面的视频删了，也把public文件夹里面的视频删了，我还检查了一遍.deploy_git下面的文件夹，都没发现那个视频了。<br>上网重新查了一下hexo的部署方式才知道，执行hexo d，就会把这个public文件夹的东西完完整整拷贝到.deploy_git文件夹里。<br>想起了之前部署失败，应该是.deploy_git文件夹里面还保留了之前没push的信息，才会导致现在也部署不了。<br>解决方法就是执行<code>hexo cl</code>清除一下缓存，或者直接把.deploy_git文件夹删了，<br>这样重新部署就没问题了。<br>顺便一提，其实那个视频我还是插进去了，只不过用了另外一种方法…<br></font><br></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Sep 15 2019 23:34:41 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;部署到github显示的网页和本地测试的网页不一样&quot;&gt;&lt;a href=&quot;#部署到github显示的网页和本地测试的网页不一样&quot; cla
      
    
    </summary>
    
    
      <category term="前端建设" scheme="http://arukione.com/categories/%E5%89%8D%E7%AB%AF%E5%BB%BA%E8%AE%BE/"/>
    
    
      <category term="博客建设" scheme="http://arukione.com/tags/%E5%8D%9A%E5%AE%A2%E5%BB%BA%E8%AE%BE/"/>
    
      <category term="Hexo-NexT" scheme="http://arukione.com/tags/Hexo-NexT/"/>
    
  </entry>
  
</feed>
