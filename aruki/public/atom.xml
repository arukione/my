<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ARUKI&#39;S BLOG</title>
  
  <subtitle>有机少年</subtitle>
  <link href="/arukione.github.io/atom.xml" rel="self"/>
  
  <link href="http://arukione.com/"/>
  <updated>2019-11-09T21:45:02.779Z</updated>
  <id>http://arukione.com/</id>
  
  <author>
    <name>aruki</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>用树结构获取字符排列组合</title>
    <link href="http://arukione.com/2019/11/10/%E7%94%A8%E6%A0%91%E7%BB%93%E6%9E%84%E8%8E%B7%E5%8F%96%E5%AD%97%E7%AC%A6%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/"/>
    <id>http://arukione.com/2019/11/10/用树结构获取字符排列组合/</id>
    <published>2019-11-09T16:00:00.000Z</published>
    <updated>2019-11-09T21:45:02.779Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Nov 13 2019 21:27:00 GMT+0800 (GMT+08:00) --><p><strong>假如有一串字符串，要对字符串里所有字符进行排列，列出所有排列组合的可能</strong><br>对于这种获取所有可能性的问题我第一想到的就是用树结构来实现，显然这个问题不能用二叉树，那我们就不用二叉树了，反正也没要求一定要用(hhhhh)</p><p>对于这种问题，我们知道遍历到最后的树叶就是其中的一种结果，所以我们定义一个全局列表来储存全部树叶的结果。<br>对于这个问题，并没有所谓的树根，树的开头就是所有可能的第一个字符。<br>所以我们定义一个树的类来对第一次传入节点进行操作；<br>定义一个节点类来作为树节点，并直接把向下添加的节点写在构造函数里面，只要符合要求就一直向下传入节点，直到全部字符都遍历完，到达树叶的时候将该结果存储起来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 存储树叶结果</span></span><br><span class="line">result = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 树结构</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tree</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,strings)</span>:</span></span><br><span class="line">        <span class="comment"># 树根节点</span></span><br><span class="line">        self.nodes = []</span><br><span class="line">        <span class="keyword">if</span> strings != []:</span><br><span class="line">            <span class="keyword">for</span> index <span class="keyword">in</span> range(<span class="number">0</span>,len(strings)):</span><br><span class="line">                <span class="comment"># 把字符传入节点</span></span><br><span class="line">                node = Node(index,strings[index],strings)</span><br><span class="line">                <span class="comment"># 添加子节点到树根</span></span><br><span class="line">                self.nodes.append(node)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 节点结构</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,index,string,strings)</span>:</span></span><br><span class="line">        <span class="comment"># 树节点的值</span></span><br><span class="line">        self.value = string</span><br><span class="line">        <span class="comment"># 树节点的子节点</span></span><br><span class="line">        self.nodes = []</span><br><span class="line">        <span class="comment"># 复制新的字符列表</span></span><br><span class="line">        self.strings = strings[:]</span><br><span class="line">        <span class="comment"># 将已拼接入节点值的字符从字符列表里删除</span></span><br><span class="line">        self.strings.pop(index)</span><br><span class="line">        <span class="comment"># 如果字符列表为空，则结束添加节点，将当前树叶节点保存的值存进result</span></span><br><span class="line">        <span class="keyword">if</span> len(self.strings) == <span class="number">0</span>:</span><br><span class="line">            result.append(self.value)</span><br><span class="line">        <span class="comment"># 不为空，继续将字符存入新节点添加到当前节点的子节点中</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(self.strings)):</span><br><span class="line">                node = Node(i,self.value+self.strings[i],self.strings)</span><br><span class="line">                self.nodes.append(node)</span><br></pre></td></tr></table></figure><p>以下是执行的主方法<br>先从键盘获取字符串，再将字符串转成列表以便进行遍历，然后将字符列表传入树进行操作<br>最后按照不同字符开头分段打印出结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    string = str(input())</span><br><span class="line"></span><br><span class="line">    strings = list(string)</span><br><span class="line">    tree = Tree(strings)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(strings)):</span><br><span class="line">        length = int(len(result)/len(strings))</span><br><span class="line">        print(result[i*length:i*length+length])</span><br></pre></td></tr></table></figure><p>对于遍历所有可能的问题，树结构往往会是我第一考虑的解决方法，因为这种结构基本可以将需要的可能都列出来，即使会有累赘的元素，但是所有可能往往都可以很好的列出来，实现起来也很方便。<br>有问题反馈请在评论区留言。<br>GitHub源代码链接：<a href="https://github.com/arukione/python_learning" target="_blank" rel="noopener">https://github.com/arukione/python_learning</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Nov 13 2019 21:27:00 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;&lt;strong&gt;假如有一串字符串，要对字符串里所有字符进行排列，列出所有排列组合的可能&lt;/strong&gt;&lt;br&gt;对于这种获取所有可能性的问题我第
      
    
    </summary>
    
    
      <category term="Python" scheme="http://arukione.com/categories/Python/"/>
    
    
      <category term="-编程学习 -数据结构 -Python" scheme="http://arukione.com/tags/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-Python/"/>
    
  </entry>
  
  <entry>
    <title>强类型与动态类型的Python</title>
    <link href="http://arukione.com/2019/11/10/%E5%BC%BA%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B%E7%9A%84/"/>
    <id>http://arukione.com/2019/11/10/强类型与动态类型的/</id>
    <published>2019-11-09T16:00:00.000Z</published>
    <updated>2019-11-10T06:17:11.469Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Nov 13 2019 21:27:00 GMT+0800 (GMT+08:00) --><p><strong>很多人都会说到Python是一门强类型、动态类型的语言，为什么这么说呢？</strong></p><p>我们先来看一下什么是强类型的语言<br><strong>百度答案：强类型指的是程序中表达的任何对象所从属的类型都必须能在编译时刻确定。</strong><br>什么意思呢？<br>就是说，在编译的时候，变量的类型就可以被编译器确定，并且运行时该变量不经过强制转换将类型无法发生改变。<br>例如我在Python里面定义了两个不同类型的变量，然后对这两个变量进行以下操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="string">"b"</span></span><br><span class="line">a + b</span><br></pre></td></tr></table></figure><p>就会报如下的类型错误(TypeError)</p><p><img src="/images/Python特性/TypeError1.png" alt="TypeError"></p><p>因为a和b是两个不同类型的变量，在不可以进行赋值操作，但是在C语言里面是可以的，因为会进行隐式转换，而在Python里面不会进行类型隐式转换。<br>对于Python来说，变量不通过int()或str()等方法进行转换的话，那么该变量的类型将无法发生改变<br><strong>根据百度提供的信息可以了解到：强类型是针对类型检查的严格程度而言的，它指任何变量在使用的时候必须要指定这个变量的类型，而且在程序的运行过程中这个变量只能存储这个类型的数据。</strong></p><p>但是我们在用Python的时候就会知道，我们是可以给变量赋其它类型的值的，例如我们可以这样写</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line">a = <span class="literal">False</span></span><br><span class="line">b = <span class="string">"b"</span></span><br><span class="line">a = b</span><br></pre></td></tr></table></figure><p>这不是和强类型的定义发生冲突了吗？<br>其实这涉及到我们要讲的另外一个问题，<strong>动态类型</strong>。</p><p>为什么说Python是动态类型呢？</p><p>因为Python的变量并不是指定了类型的，Python的变量在进行赋值的时候，是指向了对象的地址，在进行重新赋值的时候，Python变量并不关心值的类型，因为它只是改变了地址的指向。这种赋值方式报错导致的类型错误，都是在运行的时候才会发生，包括上面举的例子的。</p><p><strong>在编译的时候不对变量类型进行识别，在运行的时候可以改变其结构的语言，我们称为动态语言。</strong></p><p>因为Python的这个特性，所以可以抛开强类型语言对于赋值时类型的要求，但是在运行时会对变量指向地址的值的类型进行判别。<br>这就是Python既是动态类型语言，也是强类型语言的原因。</p><p>对于Python这种动态指向，在编写程序的时候，给我们带来了很多方便，但是稍不注意，也会让程序发生一些难以察觉的错误。<br>例如我们对列表操作的时候</p><p><img src="/images/Python特性/dynamic1.png" alt="dynamic"></p><p>当Python将一个列表赋给变量a，此时a并不等于[1,2,3]，而是指向了这个列表的地址。<br>将a的值赋给b的时候，相当于将b的指向修改成a的指向，也就是b也是指向这个列表的地址。当你对b进行操作的时候，就是在对这个地址的值进行操作，所以a的值也会发生改变，当程序在递归或者用树遍历的时候，如果这样进行列表的赋值，将会导致重大的错误。<br>为了避免这种情况，Python也提供了一些方法给我们进行赋值使用，当我们希望将a和b不是指向同一个列表，但两个列表的值又要一样的时候，我们可以用list的copy()方法来对列表进行复制。这种情况下我们是复制出了一个新的列表赋给了b，所以对b操作的时候不会改变a的值。<br>另外一种方法就是直接对整个列表进行截取：<br>当我们使用a[x:y]时，可以截取到a中下标x到下标y的片段；<br>当x或y的参数放空时，表示从头开始截取或者截取到尾；<br>例：a[:y]就是截取下标0~y的片段，a[x:]就是从x开始截取到列表结束；<br>而a[:]就是从头截取到最后一个元素，也就是整个列表都截取下来。</p><p><img src="/images/Python特性/dynamic2.png" alt="dynamic"></p><p>或者是对多维列表的子列表进行修改</p><p><img src="/images/Python特性/dynamic3.png" alt="dynamic"></p><p><strong>但是这两个方法对于多维列表操作单个元素来说，都不起作用！</strong></p><p><img src="/images/Python特性/dynamic4.png" alt="dynamic"></p><p><strong>原因是：列表里面保存的元素，也是地址的指向！</strong><br>当对多维列表的下一级列表进行操作的时候，是让该下标指向了另一个列表的地址，但是对该子列表的元素进行修改时，是修改子列表的元素的指向。</p><p>附上图可能会更容易理解一点：<br><img src="/images/Python特性/introduce.png" alt="dynamic"></p><p>例如：<br>我将a复制给了b，虽然生成的是新列表，但是列表里面元素指向的地址是相同的，当我修改b[0]的时候，相当于是把b[0]指向了其它列表，此时a并不会收到影响。<br>但是如果我修改的是b[1][1],此时我修改的是b[1]指向的列表下标为1的元素，但是a[1]和b[1]指向的是同一列表，相当于也是在修改a[1]的元素。</p><p>这种情况下，也有应对的方法，我用的是for循环来进行重复制</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = [[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]]</span><br><span class="line">b = []</span><br><span class="line"><span class="keyword">for</span> data <span class="keyword">in</span> a:</span><br><span class="line">    b.append(data.copy())</span><br></pre></td></tr></table></figure><p>但是这种办法对于对于n维列表，需要内嵌的for循环为n-1个，如果是维度高的列表，就不是很切实际了。<br>如果大佬们有更好的方法，还请在评论区留言^_^</p><p>掘金地址：<a href="https://juejin.im/post/5dc7a58b51882521f62cc3c2" target="_blank" rel="noopener">https://juejin.im/post/5dc7a58b51882521f62cc3c2</a><br>知乎地址：<a href="https://zhuanlan.zhihu.com/p/91117079" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/91117079</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Nov 13 2019 21:27:00 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;&lt;strong&gt;很多人都会说到Python是一门强类型、动态类型的语言，为什么这么说呢？&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;我们先来看一下什么是强类
      
    
    </summary>
    
    
      <category term="Python" scheme="http://arukione.com/categories/Python/"/>
    
    
      <category term="-编程学习 -Python" scheme="http://arukione.com/tags/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0-Python/"/>
    
  </entry>
  
  <entry>
    <title>用树结构获取自然数拆分结果</title>
    <link href="http://arukione.com/2019/11/10/%E7%94%A8%E6%A0%91%E7%BB%93%E6%9E%84%E8%8E%B7%E5%8F%96%E8%87%AA%E7%84%B6%E6%95%B0%E6%8B%86%E5%88%86%E7%BB%93%E6%9E%9C/"/>
    <id>http://arukione.com/2019/11/10/用树结构获取自然数拆分结果/</id>
    <published>2019-11-09T16:00:00.000Z</published>
    <updated>2019-11-09T21:41:10.616Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Nov 13 2019 21:27:00 GMT+0800 (GMT+08:00) --><p><strong>任何一个大于1的自然数n，都可以拆分成若干个小于n的自然数相加，现在输入一个数n，列出该数的所有拆分可能</strong><br>像这种获取所有可能性的问题，我第一想到的当然是树啦！<br>好吧，这次其实我第一次想到的不是树，而是for循环，其实就是被那么规律的排列给误导了….<br>但是最后还是靠树来实现了</p><p>不过这一次的问题没定义Tree类了，直接定义了Node类传入列表进行计算存储。<br>其实这个问题就是从1到n-1开始遍历，将遍历到的数存到列表里面，每次存完1个数将列表传入下一个节点，再从1开始存，直到列表的和等于n的值，把这个列表进行排序然后存入全局列表result里面，最后再打印出来。</p><p>以下是实现代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 储存结果</span></span><br><span class="line">result = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义全局变量n</span></span><br><span class="line">n=<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,num_list)</span>:</span></span><br><span class="line">        <span class="comment"># 计算列表里值的和</span></span><br><span class="line">        list_sum = sum(num_list)</span><br><span class="line">        <span class="comment"># 遍历1到当前可储存的最大值</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n-list_sum+<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 复制已存储自然数的列表</span></span><br><span class="line">            new_num_list = num_list[:]</span><br><span class="line">            <span class="comment"># 将可存储的值添加进列表</span></span><br><span class="line">            new_num_list.append(i)</span><br><span class="line">            <span class="comment"># 如果添加新值后列表里全部元素的和等于n，则该节点为尾节点</span></span><br><span class="line">            <span class="keyword">if</span> list_sum+i == n:</span><br><span class="line">                <span class="comment"># 判断存的自然数是否全都小于n</span></span><br><span class="line">                <span class="keyword">if</span> len(new_num_list)!=<span class="number">1</span>:</span><br><span class="line">                    <span class="comment"># 对存储的自然数进行排序</span></span><br><span class="line">                    new_num_list.sort()</span><br><span class="line">                    <span class="comment"># 判断该结果是否已存在</span></span><br><span class="line">                    <span class="keyword">if</span> new_num_list <span class="keyword">not</span> <span class="keyword">in</span> result:</span><br><span class="line">                        result.append(new_num_list)</span><br><span class="line">            <span class="comment"># 如果不是尾节点，继续添加节点</span></span><br><span class="line">            <span class="keyword">if</span> list_sum+i &lt; n:</span><br><span class="line">                Node(new_num_list)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    print(<span class="string">"Enter a number greater than two"</span>)</span><br><span class="line">    <span class="comment"># 设置n的值</span></span><br><span class="line">    n = int(input())</span><br><span class="line">    <span class="comment"># 开始拆分</span></span><br><span class="line">    num_list = []</span><br><span class="line">    Node(num_list)</span><br><span class="line">    <span class="comment"># 展示结果</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> result:</span><br><span class="line">        print(i)</span><br></pre></td></tr></table></figure><p>其实无论是拆分还是组合，只要是求全部可能性的问题，用树结构都可以很好的解决，如果有其它问题请在评论区留言。<br>附上GitHub代码链接：<a href="https://github.com/arukione/python_learning" target="_blank" rel="noopener">https://github.com/arukione/python_learning</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Nov 13 2019 21:27:00 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;&lt;strong&gt;任何一个大于1的自然数n，都可以拆分成若干个小于n的自然数相加，现在输入一个数n，列出该数的所有拆分可能&lt;/strong&gt;&lt;br
      
    
    </summary>
    
    
      <category term="Python" scheme="http://arukione.com/categories/Python/"/>
    
    
      <category term="-编程学习 -数据结构 -Python" scheme="http://arukione.com/tags/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-Python/"/>
    
  </entry>
  
  <entry>
    <title>Welcome</title>
    <link href="http://arukione.com/2019/09/15/Welcome/"/>
    <id>http://arukione.com/2019/09/15/Welcome/</id>
    <published>2019-09-15T06:36:09.644Z</published>
    <updated>2019-09-15T09:19:16.765Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Nov 13 2019 21:27:00 GMT+0800 (GMT+08:00) --><p><strong>欢迎来到ARUKI’ BLOG,你可以在这里寻找对您有帮助的文章。</strong><br><strong>目前博客仍在建设中，如果对本博客有任何意见，欢迎联系我并提出您的问题！！</strong></p><p><strong>Welcome to my blog! You can find articles that useful for you.</strong><br><strong>At present, the blog is still under construction, if you have any comments on this blog, please contact me and raise your questions!!</strong></p><p><strong>ようこそ　ARUKI’ BLOG、ここで君の役に立つ文章を探すことができます。</strong><br><strong>现在、ブログ建设中ですが、もしこのブログに何か意见があれば、私を连络して问题を提出してくだいさい! !</strong></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Nov 13 2019 21:27:00 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;&lt;strong&gt;欢迎来到ARUKI’ BLOG,你可以在这里寻找对您有帮助的文章。&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;目前博客仍在建设中，
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>数据结构基础</title>
    <link href="http://arukione.com/2019/09/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/"/>
    <id>http://arukione.com/2019/09/11/数据结构基础/</id>
    <published>2019-09-10T16:00:00.000Z</published>
    <updated>2019-11-09T20:19:12.015Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Nov 13 2019 21:27:00 GMT+0800 (GMT+08:00) --><h2 id="基本概念和术语"><a href="#基本概念和术语" class="headerlink" title="基本概念和术语"></a>基本概念和术语</h2><p><strong>数据(Data)：</strong>客观事物的符号表示，是所有能输入到计算机中并被计算机程序处理的符号的总称</p><p><strong>数据元素(Data Element)：</strong>数据的基本单位，在计算机中通常作为一个整体进行考虑和处理</p><p><strong>数据项(Data Item)：</strong>组成数据元素的、有独立含义的、不可分割的最小单位</p><p><strong>数据对象(Data Object)：</strong>是性质相同的数据元素的集合，是数据的一个子集</p><div class="note info"><p>数据是什么？如何理解数据对象？什么是性质相同的数据元素的集合？<br>数据对象相当于数据的一部分内容，而这部分内容里面的元素都有相同的特点，举个例子：</p><p>数据 一个班级里面的学生<br>数据对象 一个班里学生的信息表<br>数据元素 学生信息表的每一条数据都是数据元素<br>数据项 学生信息表里面的每一项信息</p><p>这里面，学生的信息表是学生的一个部分内容，学生可以包含很多内容，除了信息表，还有成绩单，身份内容，这些都算是学生这个数据的一部分，也就是数据的子集，即数据对象。而学生信息表里面会含有很多个信息项，例如姓名学号、专业、性别等等，这些信息项就是数据项，有着独立的含义。信息表里面的每一个学生的数据，都算是一个数据元素，这些学生的数据构和数据项构造成了信息表，所以数据对象是数据元素的集合。</p></div><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p><strong>数据结构(Data Stucture)：是相互之间存在一种或多种特定关系的数据元素的集合。</strong><br>数据结构其实就是带有“结构”的数据元素的集合。不过说是数据元素的集合，我们平时的理解更多的是倾向于结构，学得主要也是结构，但这个名词本身指的还是集合！<br>数据结构包括逻辑结构和储存结构两个层次。</p><h4 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h4><p><strong>逻辑结构是对于数据来讲的，从逻辑关系上描述数据，和数据的储存无关，独立于计算机。</strong><br><strong>数据的逻辑结构分为：线性结构和非线性结构。</strong></p><p>四类基本逻辑结构：</p><p><strong>集合结构：</strong>数据元素除了属于同一集合外，没有其他关系<br><strong>线性结构：</strong>数据元素之间存在一对一的关系<br><strong>树结构：</strong>数据元素之间存在一对多的关系<br><strong>图结构或网状结构：</strong>数据元素之间存在多对多的关系</p><p>下面图示，会更容易理解</p><p><img src="/images/数据的逻辑结构.png" alt="数据的逻辑结构层次图"></p><h4 id="储存结构"><a href="#储存结构" class="headerlink" title="储存结构"></a>储存结构</h4><p><strong>储存结构也称为物理结构，指的是数据对象在计算机中的存储方式。</strong><br>通常要求数据对象在存入计算机时既要存储数据元素的数据，也要存储数据元素之间的逻辑关系，数据元素在计算机内用一个结点来表示。</p><p>数据元素在计算机中的两种基本储存结构：</p><p><strong>顺序存储结构：</strong>借助元素在存储器中的相对位置来表示数据元素之间的逻辑关系，要求所有的元素依次存放在一片连续的存储空间中</p><p><strong>链式存储结构：</strong>无需占用一整块存储空间，为了表示结点之间的关系，给每个结点附加指针字段，用于存放后继元素的存储地址。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">课外补充：</span><br><span class="line">逻辑结构与数据元素本身的形式、内容、相对位置、个数无关。</span><br><span class="line">一些表面上很不相同的数据可以有相同的逻辑结构</span><br><span class="line">通常要求同一逻辑结构中的所有数据元素具有相同的特性，这意味着不仅数据元素所包含的数据项的个数要相同，而且对应数据项的类型要一致</span><br></pre></td></tr></table></figure><h2 id="算法和算法分析"><a href="#算法和算法分析" class="headerlink" title="算法和算法分析"></a>算法和算法分析</h2><p><strong>算法：</strong>是为了解决某类问题而规定的一个有限长的操作序列<br>一个算法必须满足的五个重要特征：<strong>有穷性、确定性、可行性、输入、输出</strong>。</p><p>一个算法的优劣评价的方面：<strong>正确性、可读性、健壮性、高效性</strong>。<br>高效性包括时间和空间两个方面：<br>时间高效是指算法设计合理，执行效率高，可以用<strong>时间复杂度</strong>来度量<br>空间高效是指算法占用存储容量合理，可以用<strong>空间复杂度</strong>来度量<br><strong>时间复杂度和空间复杂度是衡量算法的两个主要指标。</strong></p><p>衡量算法效率的方法主要有两种：事后统计法和事前分析估算法。<br>通常采用事前分析估算法，通过计算算法的渐进复杂度来衡量算法的效率。</p><h3 id="渐进时间复杂度"><a href="#渐进时间复杂度" class="headerlink" title="渐进时间复杂度"></a>渐进时间复杂度</h3><p><strong>一般情况下对于算法中基本语句的执行的是问题规模n的某个函数f(n)，我们用”O”来表示数量级，算法的时间量度记作</strong><br><strong>T(n) = O(f(n))</strong><br><strong>它表示随问题规模n的增大，算法执行时间的增长率和 f(n) 的增长率相同，称做算法的渐渐时间复杂度，简称时间复杂度(Time Complexity).</strong></p><p><strong>问题规模：</strong>问题规模是算法求解问题输入量的多少，是问题大小的本质表示，一般用整数n表示<br><strong>语句频度：</strong>一条语句的重复执行次数</p><p>「 以下代码来自书中 」</p><p><strong>一个算法的执行时间大致上等于所有语句执行时间的总和，而语句的执行时间则为该条语句的财富执行次数和执行一次所需时间的乘积。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">两个n阶矩阵的乘积算法</span><br><span class="line">设每条语句执行一次所需时间均为单位时间，n为执行规模</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n; i++)                                                     <span class="comment">//频度为 n+1</span></span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">1</span>; j&lt;=n; j++)&#123;                                                <span class="comment">//频度为 n*(n+1)</span></span><br><span class="line">        c[i][j] = <span class="number">0</span>;                                                    <span class="comment">//频度为 n^2</span></span><br><span class="line">        <span class="keyword">for</span>(k=<span class="number">1</span>; k&lt;=n; k++)                                             <span class="comment">//频度为 n^2 * (n+1)</span></span><br><span class="line">        c[i][j] = c[i][j] + a[i][k] * b[k][j];                          <span class="comment">//频度为 n^3</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">该算法中所有语句频度的和 f(n) = <span class="number">2</span>n^<span class="number">3</span> + <span class="number">3</span>n^<span class="number">2</span> + <span class="number">2</span>n + <span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>为了客观反映一个算法的执行时间，可以通过算法中“基本语句”(重复执行次数和算法的执行时间成正比的语句，它对算法运行时间的贡献最大) 执行次数来度量算法的工作量。</strong><br><strong>通常，算法的执行时间随问题规模增长而增长，因此对算法的评价只需考虑其随问题规模增长的趋势。</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">上面那个例子,当执行规模n趋向无穷大时</span><br><span class="line">f(n) / n^3  的极限等于2</span><br><span class="line">也就是当n充分大时，f(n) 和 n^3 的比是一个不等于0的常数</span><br><span class="line">即 f(n) 和 n^3 同阶(数量级Order of Magnitude相同)</span><br><span class="line">时间复杂度T(n) = O(f(n)) = O(n^3)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">关于常量阶</span><br><span class="line">当语句频度为1时，算法执行时间是一个与问题规模n无关的常数，即T(n) = O(1)，称为常量阶。</span><br><span class="line">只要算法执行时间不随问题规模n增长而增长，算法中语句的频度就是某个常数，无论这个常数多大，算法的时间复杂度都是O(1)。</span><br><span class="line">例如：for(i=0;i&lt;10000;i++)&#123;x++;s=0;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">关于线性阶</span><br><span class="line">循环体内两条基本语句的频度均为 f(n)=n，算法的时间复杂度为 T(n) = O(n)，称为线性阶。</span><br><span class="line">当算法的基本语句频度最大为 n^2 时，T(n) = O(n^2)， 则为平方阶；</span><br><span class="line">同样，当频度最大为 n^3 时，则为立方阶。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">对数阶示例</span><br><span class="line"></span><br><span class="line">i = 1;</span><br><span class="line">while (i &lt;= n)</span><br><span class="line">    i = i*3;</span><br><span class="line"></span><br><span class="line">设循环体里面的基本语句的频度为 f(n)</span><br><span class="line">也就是执行了 f(n) 次 i*3</span><br><span class="line">所以执行完 i的值为 3^f(n)</span><br><span class="line">由于 i&lt;=n，所以 3^f(n) &lt;= n</span><br><span class="line">可得到 f(n) &lt;= log_3 n</span><br><span class="line">所以这个程序的时间复杂度为f(log3 n)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">最好、最坏、平均时间复杂度</span><br><span class="line">对于某些问题，算法的基本语句的频度不仅仅和问题的规模有关，还依赖于其他因素，例如：未知的输入值、随机的初始化等等。</span><br><span class="line">这些问题的算法，在计算时间复杂度的时候需要考虑各种情况。</span><br><span class="line">称算法在最好情况下的时间复杂度为最好时间复杂度；最坏情况下算法的时间复杂度为最坏时间复杂度，分别指的是算法计算量可能达到的最小值和最大值。</span><br><span class="line">算法的平均时间复杂度是指算法在所有情况下，按照输入实例以等概率出现时，算法计算量的加权平均值。</span><br><span class="line">一般来说，人们更关心的是平均情况下和最坏情况下的时间复杂度，但是算法的平均时间复杂度难以确定。</span><br></pre></td></tr></table></figure><h3 id="渐进空间复杂度"><a href="#渐进空间复杂度" class="headerlink" title="渐进空间复杂度"></a>渐进空间复杂度</h3><p><strong>和时间复杂度类似，渐进空间复杂度(Space Complexity)作为算法所需存储空间的量度，它也是问题规模n的函数，记作S(n) = O(f(n))</strong><br>在分析时，输入数据所占的具体存储量取决于问题，和算法无关，所以秩序分析该算法在实现是所需要的辅助空间就行了。<br>若算法实现时所需的辅助存储空间相对于输入数据量而言是个常数，与问题本身无关，则称这个算法为原地工作，辅助空间为O(1)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n/<span class="number">2</span>;i++)&#123;</span><br><span class="line">    t = a[i];</span><br><span class="line">    a[i] = a[n-i<span class="number">-1</span>];</span><br><span class="line">    a[n-i<span class="number">-1</span>] = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">由于算法只需借助一个变量t，与问题规模n的大小无关，所以其空间复杂度为O(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    b[i] = a[n-i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n/<span class="number">2</span>;i++)</span><br><span class="line">    a[i] = b[i];</span><br><span class="line"></span><br><span class="line">算法需要借助一个大小为n的辅助数组b，所以其空间复杂度为O(n)</span><br></pre></td></tr></table></figure><blockquote><p>参考：人民邮电出版社《数据结构 C语言版|第二版》严蔚敏</p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Nov 13 2019 21:27:00 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;基本概念和术语&quot;&gt;&lt;a href=&quot;#基本概念和术语&quot; class=&quot;headerlink&quot; title=&quot;基本概念和术语&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
    
      <category term="学习旅程" scheme="http://arukione.com/categories/%E5%AD%A6%E4%B9%A0%E6%97%85%E7%A8%8B/"/>
    
    
      <category term="-编程学习 -数据结构" scheme="http://arukione.com/tags/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Python程序打包成exe可执行文件</title>
    <link href="http://arukione.com/2019/06/02/python%E7%A8%8B%E5%BA%8F%E6%89%93%E5%8C%85%E6%88%90exe%E6%96%87%E4%BB%B6/"/>
    <id>http://arukione.com/2019/06/02/python程序打包成exe文件/</id>
    <published>2019-06-01T16:00:00.000Z</published>
    <updated>2019-10-19T19:24:52.759Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Nov 13 2019 21:27:00 GMT+0800 (GMT+08:00) --><h3 id="本教程是使用Pyinstaller来将Python程序打包成exe可执行文件"><a href="#本教程是使用Pyinstaller来将Python程序打包成exe可执行文件" class="headerlink" title="本教程是使用Pyinstaller来将Python程序打包成exe可执行文件"></a>本教程是使用Pyinstaller来将Python程序打包成exe可执行文件</h3><h3 id="实现步骤："><a href="#实现步骤：" class="headerlink" title="实现步骤："></a><strong>实现步骤：</strong></h3><p><strong>首先要安装Pyinstaller包，在命令行窗口使用pip指令就可以完成：</strong><br><code>pip install pyinstaller</code><br><strong>安装成功后就可以进行打包了</strong><br><strong>首先在命令行进入要打包的python程序的目录下面</strong><br><strong>接着使用</strong> <code>pyinstaller file.py</code> <strong>就可以打包了(file.py是指你要打包的python文件)</strong><br><strong>这个指令也可以附带其他属性：</strong><br></p><div class="note info"><p><strong>-F 表示生成单个可执行文件</strong></p><p><strong>-D 创建一个目录，包含exe文件和依赖很多文件（默认选项）</strong></p><p><strong>-w 表示去掉控制台窗口，这样执行exe文件的时候不会出现窗口，但会在后台运行，用命令行还是可以看见执行情况的</strong></p><p><strong>-c 使用控制台，无界面(默认)；</strong></p><p><strong>-p 表示你自己自定义需要加载的类路径</strong></p><p><strong>-i 表示可执行文件的图标。</strong></p></div><br><strong>例如我要生成一个带图标的exe文件，没有其他依赖文件的，那么就是使用指令：</strong><br><code>pyinstaller -F -i image.ico file.py</code> <strong>（image.ico表示图标的路径，file.py表示要打包的python文件）</strong><br><strong>打包后会生成dict文件夹和buid文件夹还有一个.spec文件，其中dict就是放置我们要的exe文件的文件夹，其他两个是生成exe文件的过程中的中间产物，可以删掉。</strong><br><strong>pyinstaller打包的时候会自动把其他依赖的包和其他python文件引入，所以不用担心调用的问题。</strong><br><strong>但是其他要使用到的文件并不会被添加进去，例如要使用的图片或者文档，所以要自己把文件添加到打包完的exe文件的目录下面相应的路径，否则会出现闪退或者文件执行失败。</strong><br><strong>另外就是，如果py文件的编码是utf8，但是文件里面又有中文的话，那么使用windows的命令行打包会出现编码错误。</strong><br><strong>解决的方法就是先使用chcp指令进入其他编码的命令行</strong><br><div class="note info"><p><strong>以下是几种常用的编码:</strong><br><strong>GBK(一般情况下为默认编码) 936</strong><br><strong>美国英语 437</strong><br><strong>utf-8 65001</strong></p></div><br><strong>在这里我们要使用utf-8的编码，所以使用命令:</strong><br><code>chcp 65001</code><br><strong>设置编码后再进行打包就不会出现编码错误的情况了</strong><p></p><p><strong>最后就是，第一次打包出来的程序经常会出现各种问题，建议在命令行执行exe文件，这样可以看到报错的内容，以便结合情况解决问题。</strong></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Nov 13 2019 21:27:00 GMT+0800 (GMT+08:00) --&gt;&lt;h3 id=&quot;本教程是使用Pyinstaller来将Python程序打包成exe可执行文件&quot;&gt;&lt;a href=&quot;#本教程是使用Pyinstaller
      
    
    </summary>
    
    
      <category term="Python" scheme="http://arukione.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://arukione.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>天翼校园网验证码识别</title>
    <link href="http://arukione.com/2019/05/25/%E5%A4%A9%E7%BF%BC%E6%A0%A1%E5%9B%AD%E7%BD%91%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB/"/>
    <id>http://arukione.com/2019/05/25/天翼校园网验证码识别/</id>
    <published>2019-05-24T16:00:00.000Z</published>
    <updated>2019-11-09T18:17:12.819Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Nov 13 2019 21:27:00 GMT+0800 (GMT+08:00) --><p><strong>本菜鸡能力有限，本文章主要目的是为了完成自动登录校园网，不是为了教学……</strong><br><strong>依靠之前学的一个神经网络，尝试写一个识别天翼验证码的代码</strong><br>其实是为了破解那个不得不吐槽的校园网，不得不捣鼓的东西……</p><p><strong>如果不懂爬虫，神经网络的构造，梯度下降算法和反向传播算法，请先找资料学习相关知识，网上有很多讲解的文章，B站也有很多视频</strong></p><p><strong>首先训练神经网络需要一点训练数据，而且，写的那个神经网络也不是靠深度学习框架的，所以识别的时候是采取分别识别验证码里面的4个数字的方式。</strong><br><strong>幸好，天翼的验证码里的数字，非常简单，没有那些奇奇怪怪的加工，每个数字都是一样的，所以训练数据也不用那么多。</strong><br><strong>写一个爬虫抓取一下验证码图片，然后把图片分割一下，就可以得到训练数据了。</strong><br><strong>因为验证码里面的数字都长得一样，这里我每个数字就只用了10张图片来训练</strong><br><img src="\images\天翼验证码训练集图片.png" alt="训练数据数字0~9"></p><p><strong>接下来是训练神经网络</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">neuralNetwork</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 初始化神经网络</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 定义输入层节点数量</span></span><br><span class="line">        self.inputnodes = <span class="number">13</span> * <span class="number">9</span></span><br><span class="line">        <span class="comment"># 定义隐藏层节点数量</span></span><br><span class="line">        self.hiddennodes = <span class="number">300</span></span><br><span class="line">        <span class="comment"># 定义输出层节点数量</span></span><br><span class="line">        self.outnodes = <span class="number">10</span></span><br><span class="line">        <span class="comment"># 随机初始化权重</span></span><br><span class="line">        self.input_hidden_weight = random.normal(<span class="number">0.0</span>, pow(self.hiddennodes, <span class="number">-0.5</span>), (self.hiddennodes, self.inputnodes))</span><br><span class="line">        self.hidden_out_weight = random.normal(<span class="number">0.0</span>, pow(self.outnodes, <span class="number">-0.5</span>), (self.outnodes, self.hiddennodes))</span><br><span class="line">        <span class="comment"># 设置学习率</span></span><br><span class="line">        self.learning_rate = <span class="number">0.1</span></span><br><span class="line">        <span class="comment"># 定义激活函数</span></span><br><span class="line">        self.activation_function = <span class="keyword">lambda</span> x: expit(x)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">train</span><span class="params">(self, inputs, targets)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :param inputs: 输入的图片数组</span></span><br><span class="line"><span class="string">        :param targets: 预测得到的结果</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 转化输入的数据</span></span><br><span class="line">        inputs = nparray(inputs, ndmin=<span class="number">2</span>).T</span><br><span class="line">        <span class="comment"># 转化预测的数据</span></span><br><span class="line">        targets = nparray(targets, ndmin=<span class="number">2</span>).T</span><br><span class="line">        <span class="comment"># 神经网络的识别结果</span></span><br><span class="line">        hidden_inputs = dot(self.input_hidden_weight, inputs)</span><br><span class="line">        hidden_outputs = self.activation_function(hidden_inputs)</span><br><span class="line">        out_inputs = dot(self.hidden_out_weight, hidden_outputs)</span><br><span class="line">        final_outputs = self.activation_function(out_inputs)</span><br><span class="line">        <span class="comment"># 分配输出层、隐藏层的各节的损失值</span></span><br><span class="line">        out_error = targets - final_outputs</span><br><span class="line">        hidden_error = dot(self.hidden_out_weight.T, out_error)</span><br><span class="line">        <span class="comment"># 更新权重</span></span><br><span class="line">        self.hidden_out_weight += self.learning_rate * dot((out_error * final_outputs * (<span class="number">1.0</span> - final_outputs)),</span><br><span class="line">                                                           hidden_outputs.T)</span><br><span class="line">        self.input_hidden_weight += self.learning_rate * dot((hidden_error * hidden_outputs * (<span class="number">1.0</span> - hidden_outputs)),</span><br><span class="line">                                                             inputs.T)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">query</span><span class="params">(self, inputs)</span>:</span></span><br><span class="line">        inputs = nparray(inputs, ndmin=<span class="number">2</span>).T</span><br><span class="line">        hidden_inputs = dot(self.input_hidden_weight, inputs)</span><br><span class="line">        hidden_outputs = self.activation_function(hidden_inputs)</span><br><span class="line">        out_inputs = dot(self.hidden_out_weight, hidden_outputs)</span><br><span class="line">        final_outputs = self.activation_function(out_inputs)</span><br><span class="line">        max = argmax(final_outputs)</span><br><span class="line">        <span class="keyword">return</span> max</span><br></pre></td></tr></table></figure><p><strong>用这个类代表神经网络，激活函数是使用sigmoid函数,这个函数在python里面已经内置在scipy库里面了，直接调用scipy.special的expit()函数就可以了</strong><br><strong>query函数是神经网络识别图片函数，train函数是训练神经网络的函数，训练时用的算法是梯度下降和反向传播。</strong><br><strong>把分割的数字图片转化为numpy数据传入train方法就可以对神经网络进行训练。</strong><br><strong>权重更新方式使用梯度下降算法来获取更优的权重</strong><br><strong>以下是图片的转化函数</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_data</span><span class="params">(image, select)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    转化图片数据</span></span><br><span class="line"><span class="string">    :param image: 图片</span></span><br><span class="line"><span class="string">    :param select: 0代表输入整张验证码，返回4个数字的3维numpy数组    1代表输入一个数字，返回一个2维的numpy数组</span></span><br><span class="line"><span class="string">    :return: data or imdata</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> select == <span class="number">0</span>:</span><br><span class="line">        <span class="comment"># 分割图片</span></span><br><span class="line">        numdata = []</span><br><span class="line">        number = image.crop((<span class="number">7</span>, <span class="number">3</span>, <span class="number">55</span>, <span class="number">16</span>)).convert(<span class="string">'L'</span>)</span><br><span class="line">        num1 = number.crop((<span class="number">0</span>, <span class="number">0</span>, <span class="number">9</span>, <span class="number">13</span>))</span><br><span class="line">        num2 = number.crop((<span class="number">13</span>, <span class="number">0</span>, <span class="number">22</span>, <span class="number">13</span>))</span><br><span class="line">        num3 = number.crop((<span class="number">26</span>, <span class="number">0</span>, <span class="number">35</span>, <span class="number">13</span>))</span><br><span class="line">        num4 = number.crop((<span class="number">39</span>, <span class="number">0</span>, <span class="number">48</span>, <span class="number">13</span>))</span><br><span class="line">        numlist = [num1, num2, num3, num4]</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> numlist:</span><br><span class="line">            two = num.convert(<span class="string">'1'</span>)</span><br><span class="line">            array = nparray(two)</span><br><span class="line">            list = array.tolist()</span><br><span class="line">            data = []</span><br><span class="line">            <span class="keyword">for</span> l <span class="keyword">in</span> list:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> l:</span><br><span class="line">                    data.append(i)</span><br><span class="line">            numdata.append(data)</span><br><span class="line">        data = nparray(numdata) * <span class="number">0.89</span> + <span class="number">0.1</span></span><br><span class="line">        <span class="keyword">return</span> data</span><br><span class="line">    <span class="keyword">if</span> select == <span class="number">1</span>:</span><br><span class="line">        two = image.convert(<span class="string">'1'</span>)</span><br><span class="line">        array = nparray(two)</span><br><span class="line">        list = array.tolist()</span><br><span class="line">        data = []</span><br><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> list:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> l:</span><br><span class="line">                data.append(i)</span><br><span class="line">        imdata = nparray(data) * <span class="number">0.89</span> + <span class="number">0.1</span></span><br><span class="line">        <span class="keyword">return</span> imdata</span><br></pre></td></tr></table></figure><p><strong>以下是我用到的训练函数</strong><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">def network_train(network):</span><br><span class="line">    for ii in range(0, 11):</span><br><span class="line">        for i in range(0, 10):</span><br><span class="line">            image = Image.open(&quot;number/&quot; + str(i) + &quot;/&quot; + str(ii) + &quot;.jpg&quot;)</span><br><span class="line">            inputs = get_data(image, 1)</span><br><span class="line">            targes = zeros(10) + 0.1</span><br><span class="line">            targes[i] = 0.99</span><br><span class="line">            network.train(inputs, targes)</span><br><span class="line">    try:</span><br><span class="line">        os.remove(&apos;input_hidden_weight.txt&apos;)</span><br><span class="line">        os.remove(&apos;hidden_out_weight.txt&apos;)</span><br><span class="line">        print(&apos;重置权重文件&apos;)</span><br><span class="line">    except:</span><br><span class="line">        print(&apos;创建权重文件&apos;)</span><br><span class="line">    savetxt(&quot;input_hidden_weight.txt&quot;, network.input_hidden_weight)</span><br><span class="line">    savetxt(&quot;hidden_out_weight.txt&quot;, network.hidden_out_weight)</span><br></pre></td></tr></table></figure><p></p><p><strong>因为这个验证码很简单，所以我没打算分测试数据，把全部图片训练完，这个神经网络就可以调用query方法来识别验证码了。</strong><br><strong>为了不用每次识别验证码都训练一次，我在把训练出来的模型的权重保存在文件里面，以便以后直接拿文件里面的模型来用。</strong></p><p><strong>代码文件、训练数据、模型权重文件，我都放在github里面</strong></p><p>github代码链接：<br><a href="https://github.com/arukione/verification-code/tree/master/%E5%A4%A9%E7%BF%BC%E6%A0%A1%E5%9B%AD%E7%BD%91%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB" target="_blank" rel="noopener">https://github.com/arukione/verification-code/tree/master/%E5%A4%A9%E7%BF%BC%E6%A0%A1%E5%9B%AD%E7%BD%91%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Nov 13 2019 21:27:00 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;&lt;strong&gt;本菜鸡能力有限，本文章主要目的是为了完成自动登录校园网，不是为了教学……&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;依靠之前学的一
      
    
    </summary>
    
    
      <category term="AI" scheme="http://arukione.com/categories/AI/"/>
    
    
      <category term="Python" scheme="http://arukione.com/tags/Python/"/>
    
      <category term="神经网络" scheme="http://arukione.com/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>MySQL安装到登陆的问题</title>
    <link href="http://arukione.com/2019/04/08/MySQL%E5%AE%89%E8%A3%85%E5%88%B0%E7%99%BB%E9%99%86%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://arukione.com/2019/04/08/MySQL安装到登陆的问题/</id>
    <published>2019-04-07T16:00:00.000Z</published>
    <updated>2019-09-15T06:36:09.640Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Nov 13 2019 21:27:00 GMT+0800 (GMT+08:00) --><div class="note warning"><p><strong>经过一晚上的折腾，我终于登陆进数据库了！！这期间遇到了不少问题，虽然网上有很多解决方案，但要找到适用的真的不容易，每个问题都花了很长时间去尝试那些指令，绕了很多弯路才解决。</strong></p></div><h3 id="端口冲突"><a href="#端口冲突" class="headerlink" title="端口冲突"></a>端口冲突</h3><p><strong>安装完遇到的第一个问题就是，没办法打开mysql服务，删了安装目录下的date文件夹重新用<code>mysqld --initialize</code>初始化，重新配置my.ini文件都没用。</strong><br><strong>之后用<code>mysqld --console</code>查了错误信息发现了端口被占用了：</strong></p><blockquote><p><strong>[ERROR] Can’t start server: Bind on TCP/IP port: Address already in use</strong><br><strong>[ERROR] Do you already have another mysqld server running on port: 3306 ?</strong></p></blockquote><p><strong>因为我这边的命令行无法识别<code>netstat -nltp|grep mysql</code>，到后面才用<code>netstat -aon|findstr 3306</code>查到了占用3306端口的进程，记住了进程后面的PID号，用<code>taskkil /f /pid 对应的PID号</code>把进程给杀了才解决问题</strong></p><h3 id="无法登陆"><a href="#无法登陆" class="headerlink" title="无法登陆"></a>无法登陆</h3><p><strong>耗了一些时间后，我用<code>net start mysql</code>开启了数据库后，用<code>mysql -uroot -密码</code>尝试登陆，结果又报了一个这样的错误</strong></p><blockquote><p><strong>mysql: [ERROR] mysql: unknown option ‘-R’.</strong></p></blockquote><p><strong>于是用<code>mysql -uroot -p</code>后再输入密码,才知道原先输入密码前也要加个p，也就是<code>mysql -uroot -p密码</code>。</strong><br><strong>但是接下来又报了一个错误</strong></p><blockquote><p><strong>mysql: [Warning] Using a password on the command line interface can be insecure.</strong><br><strong>ERROR 1045 (28000): Access denied for user ‘root‘@’localhost’ (using password: YES)</strong></p></blockquote><p><strong>查了一下发现是密码错误，因为我输入的是安装时的密码，但是初始化的时候密码重置了，所以密码错了，所以我又绕了一次弯路，把date删了重新初始化了一遍，把初始化输出的临时密码记了下来</strong></p><blockquote><p><strong>[Note] A temporary password is generated for root@localhost: TKk51x#bOi0S</strong><br><strong>之后就可以成功登陆了</strong></p></blockquote><h3 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h3><p><strong>登陆后没办法使用其他语句，说是必须修改一下密码，而且自动生成的密码太难记了，我想改回自己的密码，但是在网上查了很多指令都用不成功，错误提示的ALTER USER语句也不知道怎么用，所以又上网馊了一下，还看了一下官方文档，总结就是看不懂【</strong><br><strong>查到最后终于发现了一个可以用的语句</strong></p><blockquote><p><code>alter user &#39;root&#39;@&#39;localhost&#39; identified by &#39;password&#39;;</code></p></blockquote><p><strong>这下问题终于解决了，可以开始进一步学习了。</strong></p><div class="note info"><p><strong>虽然遇到了很多问题，但是也知道了很多MySQL和命令行的语句，有些没派上用场就是了，至少折腾了一夜一些有用的语句都变熟悉了。</strong></p></div><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Nov 13 2019 21:27:00 GMT+0800 (GMT+08:00) --&gt;&lt;div class=&quot;note warning&quot;&gt;&lt;p&gt;&lt;strong&gt;经过一晚上的折腾，我终于登陆进数据库了！！这期间遇到了不少问题，虽然网上有很
      
    
    </summary>
    
    
      <category term="数据库" scheme="http://arukione.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MySQL" scheme="http://arukione.com/tags/MySQL/"/>
    
      <category term="windows命令" scheme="http://arukione.com/tags/windows%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>我的学习旅程</title>
    <link href="http://arukione.com/2019/04/04/%E6%88%91%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%97%85%E7%A8%8B/"/>
    <id>http://arukione.com/2019/04/04/我的学习旅程/</id>
    <published>2019-04-03T16:00:00.000Z</published>
    <updated>2019-11-09T18:37:52.351Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Nov 13 2019 21:27:00 GMT+0800 (GMT+08:00) --><div align="center"><h2>2018年</h2><br><strong>加强自己对计算机的认识，更深层地去理解计算机的工作原理</strong><br><strong>从C语言开始认识程序</strong><br><strong>接下来是自己买了服务器搭建梯子，第一次接触脚本</strong><br><strong>慢慢的听到了许多自己没接触过的东西，例如github、node.js、还有前端啊，但是自己都不知道是什么东西</strong><br><strong>自己买了前端的书学习，知道了如何构建网站</strong><br><strong>参与了wiki的建设，发现了更多自己不知道的知识</strong><br><strong>和vultr的客服交流，开启了服务器25号端口</strong><br><strong>学习java，认识到了面向对象</strong><br><br><h2>2019年</h2><br><strong>访问了HackOne网站，开始对网络安全产生兴趣</strong><br><strong>接触linux系统</strong><br><strong>学习了github，明白了github的作用和使用方法</strong><br><strong>接触python，发现python的优点</strong><br><strong>购买了域名，尝试搭建博客</strong><br><strong>初次使用git和githubDesktop，并搭建了自己的博客</strong><br><strong>用githubDesktop给博客做备份</strong><br><strong>学习linux系统和python、java，开始接触数据库</strong><br><strong>学习数据库和python</strong><br><strong>使用python写一个爬虫，借了数据库的书进行进一步学习和练习</strong><br><strong>学习AI，入门机器学习</strong><br><strong>第一次写了一个可以识别数字的神经网络</strong><br><strong>学习python数据结构</strong><br><strong>接触网络和使用刷入固件的路由器</strong><br><h3>七月</h3><br><strong>暑假开始使用ubuntu系统</strong><br><strong>进一步学习机器学习算法，入门TensorFlow深度学习框架</strong><br><strong>学习卷积神经网络结构(CNN)</strong><br><strong>学习对抗神经网络（DCGAN）</strong><br><strong>使用tesra平台，尝试在系统用GPU训练网络，结果安装驱动的时候把ubuntu系统搞坏了（呜呜呜）</strong><br><strong>开始使用debian系统</strong><br><h3>十月</h3><br><strong>接触Python的web框架Django和Flask</strong><br><strong>进行部门微信小程序开发</strong><br></div><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Nov 13 2019 21:27:00 GMT+0800 (GMT+08:00) --&gt;&lt;div align=&quot;center&quot;&gt;&lt;h2&gt;2018年&lt;/h2&gt;&lt;br&gt;&lt;strong&gt;加强自己对计算机的认识，更深层地去理解计算机的工作原理&lt;/
      
    
    </summary>
    
    
      <category term="学习旅程" scheme="http://arukione.com/categories/%E5%AD%A6%E4%B9%A0%E6%97%85%E7%A8%8B/"/>
    
    
      <category term="编程学习" scheme="http://arukione.com/tags/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>机器学习资源分享</title>
    <link href="http://arukione.com/2019/04/04/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90%E5%88%86%E4%BA%AB/"/>
    <id>http://arukione.com/2019/04/04/机器学习资源分享/</id>
    <published>2019-04-03T16:00:00.000Z</published>
    <updated>2019-09-15T15:40:40.417Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Nov 13 2019 21:27:00 GMT+0800 (GMT+08:00) --><div align="center"><br><strong>我只想说虽然很有兴趣，但是学习深度学习太难了！！！</strong><br><strong>所以在这里和大家分享点学习资源，希望能给学习机器学习、深度学习的小伙伴帮助。</strong><br><br><strong>B站机器学习视频：</strong><br><strong>上交ACM机器学习：<a href="https://www.bilibili.com/video/av58580135" target="_blank" rel="noopener">https://www.bilibili.com/video/av58580135</a></strong><br><strong>吴恩达（Ng）机器学习：<a href="https://www.bilibili.com/video/av9912938" target="_blank" rel="noopener">https://www.bilibili.com/video/av9912938</a></strong><br><strong>斯坦福 CS224n 自然语言处理：<a href="https://www.bilibili.com/video/av46216519" target="_blank" rel="noopener">https://www.bilibili.com/video/av46216519</a></strong><br><br><br><strong>ApacheCN学习组织：<a href="https://github.com/apachecn/AiLearning" target="_blank" rel="noopener">https://github.com/apachecn/AiLearning</a></strong><br><strong>斯坦福 CS224n 自然语言处理中文笔记：<a href="https://github.com/apachecn/stanford-cs224n-notes-zh" target="_blank" rel="noopener">https://github.com/apachecn/stanford-cs224n-notes-zh</a></strong><br><br><strong>知乎卷积神经网络讲解：<a href="https://zhuanlan.zhihu.com/c_141391545" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/c_141391545</a></strong><br><br><strong>神经网络&amp;CNN论文（需要翻墙）：<a href="http://cs231n.github.io/" target="_blank" rel="noopener">http://cs231n.github.io/</a></strong><br>我把论文下载为压缩包，给国内的小伙伴们下载学习：<a href="./repositories/maching\ learning/maching\ learning.7z">maching learning.7z</a><br><br><strong>一个有点好玩、能帮助理解的数学可视化视频：</strong><br><strong>深度学习（Deep Learning）：<a href="https://space.bilibili.com/88461692/channel/detail?cid=26587" target="_blank" rel="noopener">https://space.bilibili.com/88461692/channel/detail?cid=26587</a></strong><br><strong>微积分：<a href="https://space.bilibili.com/88461692/channel/detail?cid=13407" target="_blank" rel="noopener">https://space.bilibili.com/88461692/channel/detail?cid=13407</a></strong><br><strong>在B站的全部视频：<a href="https://space.bilibili.com/88461692?spm_id_from=333.788.b_765f7570696e666f.1" target="_blank" rel="noopener">https://space.bilibili.com/88461692?spm_id_from=333.788.b_765f7570696e666f.1</a></strong><br></div><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Nov 13 2019 21:27:00 GMT+0800 (GMT+08:00) --&gt;&lt;div align=&quot;center&quot;&gt;&lt;br&gt;&lt;strong&gt;我只想说虽然很有兴趣，但是学习深度学习太难了！！！&lt;/strong&gt;&lt;br&gt;&lt;stro
      
    
    </summary>
    
    
      <category term="学习旅程" scheme="http://arukione.com/categories/%E5%AD%A6%E4%B9%A0%E6%97%85%E7%A8%8B/"/>
    
    
      <category term="-编程学习 -神经网络 -机器学习" scheme="http://arukione.com/tags/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>使用Hexo-NexT时遇到的问题</title>
    <link href="http://arukione.com/2019/03/29/%E4%BD%BF%E7%94%A8Hexo-NexT%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://arukione.com/2019/03/29/使用Hexo-NexT时遇到的问题/</id>
    <published>2019-03-28T16:00:00.000Z</published>
    <updated>2019-09-15T06:36:09.652Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Nov 13 2019 21:27:00 GMT+0800 (GMT+08:00) --><h1 id="部署到github显示的网页和本地测试的网页不一样"><a href="#部署到github显示的网页和本地测试的网页不一样" class="headerlink" title="部署到github显示的网页和本地测试的网页不一样"></a>部署到github显示的网页和本地测试的网页不一样</h1><p><font size="4"><br>之前设置了网页的背景图片还有側框的边角，同时添加了右上角的github跳转图标和阅读全文的设置。<br>但是在在本地测试完，部署到github时，发现只有github图标和阅读全文的设置生效了，背景图片和边角设置没有体现出来。<br>这是因为github部署的时候缓存加载比较慢，有时候要过一段时间才会显示出你想要的效果，用<code>hexo clean</code>清除一下public文件夹,再重新部署用<code>hexo g -d</code>部署一下，多刷新几次就行了。<br></font><br></p><h1 id="生成了空白的html文件"><a href="#生成了空白的html文件" class="headerlink" title="生成了空白的html文件"></a>生成了空白的html文件</h1><p><font size="4"><br>第一次遇到这个问题的时候，我是直接重新搭建了这个博客的，毕竟一直不知道怎么解决，明明上一步操作还是没问题的，下一步页面突然就崩溃了。<br>后来这个博客又遇到了一次，好在我找到了解决方法：<br>如果找不到index.html文件（在生成的public文件夹里面）的话，要先用<code>npm ls --depth 0</code>检查一下插件情况,如果插件缺失了deploy和generator这两个插件的话就要用<code>npm install</code>重新安装插件。<br><div class="note warning"><p><strong>如果是有html文件，但文件是空白的。那么你就要检查你刚刚修改的配置了，如果你修改一个文件里某一个配置下的某一项，但那一个配置忘记打开的话就会导致这样的情况。</strong></p></div></font></p><p>例如我在主题配置文件里的友情链接links下增加了网易云音乐这一个选项，但是links前面原先有一个#号，我没有删除打开的话，生成的index.html文件就是空白的。<br>而我就是遇到了这种情况，当时不知道是修改了哪一个配置，忘记把#号删了，结果就没有成功生成页面，发现了之后把#号删了就恢复正常了。<br><br></p><h1 id="hexo语句发生错误-Template-render-error-unknown-path"><a href="#hexo语句发生错误-Template-render-error-unknown-path" class="headerlink" title="hexo语句发生错误 Template render error: (unknown path)"></a>hexo语句发生错误 Template render error: (unknown path)</h1><p><font size="4"><br>在我写完另外一篇文章后，打算测试一下，发现无论是hexo g还是hexo s都会报错，于是移除了那篇文章，重新尝试了一下发现可以了。<br>在网上看到似乎不能用}}这样的符号，我回去看那篇文章时发现我有一个}误删了，这才的导致解析不通过。<br>结合之前生成空白html的经历，我发现只要文件里面有一点语法错误都会出现很大问题，如果某次操作突然出错了，记得去检查你最近的修改和文章有没有语法错误。<br></font><br></p><h1 id="左下角多了一个undefined"><a href="#左下角多了一个undefined" class="headerlink" title="左下角多了一个undefined"></a>左下角多了一个undefined</h1><p><font size="4"><br>最新版本的看板娘，在layout/_layout.swig的<code>&lt;/body&gt;</code>前加上{ { live2d() } }，会产生一个默认的看板娘。<br>如果在_config.yml文件中只设置一个，这就会产生冲突，导致有一个无法定义，所以会在页面多出一个undefined语句。<br>在最新版本要把<code>&lt;/body&gt;</code>前的{ { live2d() } }删除，这样才不会出错。<br></font><br></p><h1 id="文件过大push不了"><a href="#文件过大push不了" class="headerlink" title="文件过大push不了"></a>文件过大push不了</h1><p><font size="4"><br>更新404页面的时候，我这404里面插入了一个视频，然后在上传的时候发现github不支持超过100M的文件，所以我把视频删了，重新部署一遍博客。<br>但每次部署都会继续上传我删掉的那个视频，为什么呢？<br>我已经把404文件夹里面的视频删了，也把public文件夹里面的视频删了，我还检查了一遍.deploy_git下面的文件夹，都没发现那个视频了。<br>上网重新查了一下hexo的部署方式才知道，执行hexo d，就会把这个public文件夹的东西完完整整拷贝到.deploy_git文件夹里。<br>想起了之前部署失败，应该是.deploy_git文件夹里面还保留了之前没push的信息，才会导致现在也部署不了。<br>解决方法就是执行<code>hexo cl</code>清除一下缓存，或者直接把.deploy_git文件夹删了，<br>这样重新部署就没问题了。<br>顺便一提，其实那个视频我还是插进去了，只不过用了另外一种方法…<br></font><br></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Nov 13 2019 21:27:00 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;部署到github显示的网页和本地测试的网页不一样&quot;&gt;&lt;a href=&quot;#部署到github显示的网页和本地测试的网页不一样&quot; cla
      
    
    </summary>
    
    
      <category term="前端建设" scheme="http://arukione.com/categories/%E5%89%8D%E7%AB%AF%E5%BB%BA%E8%AE%BE/"/>
    
    
      <category term="博客建设" scheme="http://arukione.com/tags/%E5%8D%9A%E5%AE%A2%E5%BB%BA%E8%AE%BE/"/>
    
      <category term="Hexo-NexT" scheme="http://arukione.com/tags/Hexo-NexT/"/>
    
  </entry>
  
</feed>
