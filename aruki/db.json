{"meta":{"version":1,"warehouse":"3.0.1"},"models":{"Asset":[{"_id":"themes/3-hexo/source/css/custom.css","path":"css/custom.css","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/gitalk.css","path":"css/gitalk.css","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/mobile.styl","path":"css/mobile.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/img/avatar.jpg","path":"img/avatar.jpg","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/img/brown-papersq.png","path":"img/brown-papersq.png","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/img/school-book.png","path":"img/school-book.png","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/js/iconfont.js","path":"js/iconfont.js","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/js/jquery.autocomplete.min.js","path":"js/jquery.autocomplete.min.js","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/js/jquery.pjax.js","path":"js/jquery.pjax.js","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/js/script.js","path":"js/script.js","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/js/search.js","path":"js/search.js","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/img/alipay.jpg","path":"img/alipay.jpg","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/img/article-list-background.jpg","path":"img/article-list-background.jpg","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/img/weixin.jpg","path":"img/weixin.jpg","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/icomoon.ttf","path":"css/fonts/icomoon.ttf","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/icomoon.svg","path":"css/fonts/icomoon.svg","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/icomoon.eot","path":"css/fonts/icomoon.eot","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/icomoon.woff","path":"css/fonts/icomoon.woff","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/iconfont.woff","path":"css/fonts/iconfont.woff","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/selection.json","path":"css/fonts/selection.json","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/atom-dark.styl","path":"css/hl_theme/atom-dark.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/atom-light.styl","path":"css/hl_theme/atom-light.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/brown-paper.styl","path":"css/hl_theme/brown-paper.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/darcula.styl","path":"css/hl_theme/darcula.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/github-gist.styl","path":"css/hl_theme/github-gist.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/github.styl","path":"css/hl_theme/github.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/gruvbox-dark.styl","path":"css/hl_theme/gruvbox-dark.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/gruvbox-light.styl","path":"css/hl_theme/gruvbox-light.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/kimbie-dark.styl","path":"css/hl_theme/kimbie-dark.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/kimbie-light.styl","path":"css/hl_theme/kimbie-light.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/railscasts.styl","path":"css/hl_theme/railscasts.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/rainbow.styl","path":"css/hl_theme/rainbow.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/school-book.styl","path":"css/hl_theme/school-book.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/sublime.styl","path":"css/hl_theme/sublime.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/sunburst.styl","path":"css/hl_theme/sunburst.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/iconfont.eot","path":"css/fonts/iconfont.eot","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/zenbum.styl","path":"css/hl_theme/zenbum.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/img/article.jpg","path":"img/article.jpg","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/iconfont.ttf","path":"css/fonts/iconfont.ttf","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/iconfont.svg","path":"css/fonts/iconfont.svg","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/js/gitment.js","path":"js/gitment.js","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/js/gitalk.js","path":"js/gitalk.js","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/img/preview.jpg","path":"img/preview.jpg","modified":0,"renderable":1},{"_id":"source/images/数据逻辑结构层次图.jpg","path":"images/数据逻辑结构层次图.jpg","modified":0,"renderable":0},{"_id":"source/images/Python特性/TypeError1.png","path":"images/Python特性/TypeError1.png","modified":0,"renderable":0},{"_id":"source/images/Python特性/dynamic1.png","path":"images/Python特性/dynamic1.png","modified":0,"renderable":0},{"_id":"source/images/Python特性/dynamic3.png","path":"images/Python特性/dynamic3.png","modified":0,"renderable":0},{"_id":"source/images/Python特性/dynamic2.png","path":"images/Python特性/dynamic2.png","modified":0,"renderable":0},{"_id":"source/images/Python特性/dynamic4.png","path":"images/Python特性/dynamic4.png","modified":0,"renderable":0},{"_id":"source/images/Python特性/introduce.png","path":"images/Python特性/introduce.png","modified":0,"renderable":0},{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0}],"Cache":[{"_id":"themes/3-hexo/.gitignore","hash":"560a43fddfe4559ed1a17e7362874454519f189b","modified":1578923033837},{"_id":"themes/3-hexo/.DS_Store","hash":"0770f9d42bfdd8d420de48fed463015e001cf579","modified":1578923033834},{"_id":"themes/3-hexo/_config.yml","hash":"b86edd75b8445b1df5bd6498ba6d4fc07a3f7a58","modified":1579795811147},{"_id":"themes/3-hexo/README.md","hash":"754d6f873d73f4a7faf5530fa4062e9a696a8fd4","modified":1578923033839},{"_id":"source/_posts/使用Hexo-NexT时遇到的问题.md","hash":"19e2b074e5c4567fa3c52a3ea689b421ca46b837","modified":1579763843963},{"_id":"source/_posts/MySQL安装到登陆的问题.md","hash":"569c80d844c36531538149cb16fe30a83d1b2117","modified":1579763824587},{"_id":"source/_posts/python程序打包成exe文件.md","hash":"d91b405fabaf8f088f295fbeef3c6c7c4a21e7e7","modified":1579935051838},{"_id":"source/_posts/强类型与动态类型的Python.md","hash":"cd6fa848c4ef4dfe226ade084a984fbaef7b34bd","modified":1579763860097},{"_id":"source/_posts/机器学习资源分享.md","hash":"3c81f63e7ada793a710b3b3ae1359a8e63a79a89","modified":1579763911281},{"_id":"source/about/index.md","hash":"4fdee25d44ce0850a504a59e5274641e357e72ec","modified":1579801582240},{"_id":"source/tags/index.md","hash":"9b2a982e4c99510b905657e3f265b1ed31c9fd83","modified":1579763726790},{"_id":"source/_posts/数据结构基础.md","hash":"991663fdb63784dad0c5a3362b83d41372e4cb16","modified":1579800619638},{"_id":"themes/3-hexo/layout/index.ejs","hash":"99aecf628b29c3345ddf819fe3d26e88788600ea","modified":1578923033915},{"_id":"themes/3-hexo/layout/post.ejs","hash":"aeda285031ba8d4e94225e82b364bcf5f79fce1d","modified":1578923033921},{"_id":"source/_posts/用树结构获取字符排列组合.md","hash":"e9e852a4cf0527e620b176604777e6a9b73484a7","modified":1579763921637},{"_id":"themes/3-hexo/source/.DS_Store","hash":"fdcc907c46e093a14b153c5dc8c038461997ed3c","modified":1578923033930},{"_id":"themes/3-hexo/layout/indexs.md","hash":"20d1e1b0ba23a418d47a0ae3ca7f7c8c99bec509","modified":1579838702156},{"_id":"source/_posts/用树结构获取自然数拆分结果.md","hash":"a4054cc958fcda47af41ccf9f8b3f5acd6ce3338","modified":1579766198924},{"_id":"themes/3-hexo/source/css/custom.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1579768370912},{"_id":"themes/3-hexo/layout/_partial/article.ejs","hash":"0ccec30a2a6799451afe9a213fa5310d1ad06c0d","modified":1578923033850},{"_id":"themes/3-hexo/layout/_partial/article_copyright.ejs","hash":"e46b7a68a5cd417330cca6fb5a5e65855fbed77b","modified":1578923033853},{"_id":"themes/3-hexo/layout/_partial/comment.ejs","hash":"d18f94e04ef0cf7abb432a8e707ccb3abc7fe435","modified":1578923033857},{"_id":"themes/3-hexo/layout/_partial/copyright.ejs","hash":"faffe25aec33936fa2ec9d8f0e34e16ef3d90c25","modified":1578923033875},{"_id":"themes/3-hexo/layout/_partial/dashang.ejs","hash":"c41a62155c416ca7d4bd90a7e2cd0ec06f174ab6","modified":1578923033878},{"_id":"themes/3-hexo/layout/_partial/footer.ejs","hash":"b8444ec0ce36ffc2e06510502c9eec2840954616","modified":1578923033883},{"_id":"themes/3-hexo/layout/_partial/friends.ejs","hash":"558a3d4bad578819fb07729fe1b50d9b81da8b93","modified":1578923033889},{"_id":"themes/3-hexo/layout/_partial/full-toc.ejs","hash":"38285b8d5272a14bfa4769163c8d569abff4c95f","modified":1578923033892},{"_id":"themes/3-hexo/layout/_partial/mathjax.ejs","hash":"e2be0e37f3d48e63e65a47d819bfb800b9aa3784","modified":1578923033898},{"_id":"themes/3-hexo/layout/_partial/header.ejs","hash":"915d5f10dd8f3dcd19cb75010e23689e8f385caf","modified":1578923033894},{"_id":"themes/3-hexo/layout/_partial/meta.ejs","hash":"ef387e80043b62e1925a068267f2377cac64adc7","modified":1578923033900},{"_id":"themes/3-hexo/layout/_partial/nav-left.ejs","hash":"c14bc1393f779dff7854089621804dceea236d82","modified":1578923033903},{"_id":"themes/3-hexo/layout/_partial/nav-right.ejs","hash":"98326675546fc6828a45e8b95250899b4ee2d821","modified":1578923033906},{"_id":"themes/3-hexo/layout/_partial/tag.ejs","hash":"d4b69b53e15abe71d2abeaff8eefa7695c12f0f6","modified":1578923033910},{"_id":"themes/3-hexo/layout/_partial/toc-ref.ejs","hash":"33f7a4bfca1bb9835ec8f0d1e73188d1f56cc8b9","modified":1578923033912},{"_id":"themes/3-hexo/source/css/gitalk.css","hash":"3dc58e9a3fd63a3144d5fe850eb55e3dc885c9fb","modified":1578923034009},{"_id":"themes/3-hexo/source/css/mobile.styl","hash":"93e144139d4b5224409ed5154f2dcf7ac56678ad","modified":1579786753377},{"_id":"themes/3-hexo/source/css/style.styl","hash":"4e02689474ac6e39ea404be5a46b96c63923652a","modified":1579786767197},{"_id":"themes/3-hexo/source/img/avatar.jpg","hash":"d8dba617be564e3a7035fcb5c820475a71387d60","modified":1579759161446},{"_id":"themes/3-hexo/source/img/brown-papersq.png","hash":"3a1332ede3a75a3d24f60b6ed69035b72da5e182","modified":1578923034091},{"_id":"themes/3-hexo/source/img/school-book.png","hash":"711ec983c874e093bb89eb77afcbdf6741fa61ee","modified":1578923034095},{"_id":"themes/3-hexo/source/js/iconfont.js","hash":"3a0869ca1b09af07d82987e343a3bc4cb9558ecb","modified":1578923034134},{"_id":"themes/3-hexo/source/js/jquery.autocomplete.min.js","hash":"2462169ad7f4a8ae9f9f4063995cbe7fed45cd77","modified":1578923034138},{"_id":"themes/3-hexo/source/js/jquery.pjax.js","hash":"8c2a4f10a4da3d9615a3a81542494c6d21479b3d","modified":1578923034142},{"_id":"themes/3-hexo/source/js/script.js","hash":"14772b08b9c3d5c99a4b54748be9666deaae2778","modified":1578923034147},{"_id":"themes/3-hexo/source/js/search.js","hash":"788c610149a5f9361295f9f0207c8523f37ddb8b","modified":1578923034152},{"_id":"themes/3-hexo/source/img/alipay.jpg","hash":"e70a57b660caa38f36f30794e8d657a218841fd5","modified":1579759706462},{"_id":"themes/3-hexo/source/img/article-list-background.jpg","hash":"b579af6819ee49d524b074167201adef09575629","modified":1579792141978},{"_id":"themes/3-hexo/source/img/weixin.jpg","hash":"f536bdbf78f988e57562f715c0a5b96b6cde4bba","modified":1579759766148},{"_id":"themes/3-hexo/layout/_partial/comments/disqus.ejs","hash":"32ce7b48d366b9c888ff2ceb911a3cd82f864537","modified":1578923033865},{"_id":"themes/3-hexo/layout/_partial/comments/click2show.ejs","hash":"05b09c45b379ffeb4f48c1604044d88829f90799","modified":1578923033862},{"_id":"themes/3-hexo/layout/_partial/comments/gentie.ejs","hash":"908d9046502612d24780ca354bd9392a009b4d7b","modified":1578923033868},{"_id":"themes/3-hexo/layout/_partial/comments/gitalk.ejs","hash":"01567e010cf4f2dd141fe2019490d3f0d5aa2529","modified":1578923033870},{"_id":"themes/3-hexo/layout/_partial/comments/gitment.ejs","hash":"eaf2b6f297282606b630ad55fb9e38af7e2829dc","modified":1578923033873},{"_id":"themes/3-hexo/source/css/_partial/autocomplete.styl","hash":"1ffe51e3b77afefcd94d386a718506d5b055ad94","modified":1578923033935},{"_id":"themes/3-hexo/source/css/_partial/dashang.styl","hash":"f0eac1dc1f5dbed1769d032bb5fd5f002faaee26","modified":1578923033941},{"_id":"themes/3-hexo/source/css/_partial/comment.styl","hash":"fe00fb1269b4fe1f3d5ab917891926222ce47275","modified":1578923033938},{"_id":"themes/3-hexo/source/css/_partial/fade.styl","hash":"02c7510a26f306e240f23ddbf772a69be2c890dd","modified":1578923033944},{"_id":"themes/3-hexo/source/css/_partial/font.styl","hash":"d14328a267248fa8bc5f877f32eb5baafb1eaaea","modified":1579781522396},{"_id":"themes/3-hexo/source/css/_partial/full-toc.styl","hash":"4102753dad0cc1ee9ed673f7253ba097a960c3b7","modified":1578923033950},{"_id":"themes/3-hexo/source/css/_partial/nav-left.styl","hash":"a794a326b042b9bd2ba6262b63c92b4ca50aabc3","modified":1579784743935},{"_id":"themes/3-hexo/source/css/_partial/nav-right.styl","hash":"70c3878051a180f0e5dd9494df2607f5804b2131","modified":1579843944783},{"_id":"themes/3-hexo/source/css/_partial/nprogress.styl","hash":"2620a02169a6aeb75137fd368eac2c36423d8498","modified":1578923033963},{"_id":"themes/3-hexo/source/css/_partial/num-load.styl","hash":"f7ef35459ece22e1da950b86126be1c2bfe97fcf","modified":1578923033966},{"_id":"themes/3-hexo/source/css/_partial/post.styl","hash":"aadefbbf20c3a02796bdec8b86e532f065158df9","modified":1579792999091},{"_id":"themes/3-hexo/source/css/fonts/icomoon.ttf","hash":"eb976d8b8559fcddfc2658a03a4350cb566fc06b","modified":1578923033981},{"_id":"themes/3-hexo/source/css/fonts/icomoon.svg","hash":"b5e7562c8494b0ddb3a70ecc5545ef7340d8e971","modified":1578923033978},{"_id":"themes/3-hexo/source/css/fonts/icomoon.eot","hash":"b6195bedc1cb2f9cfcb26cc27021f2e94be2ab0a","modified":1578923033974},{"_id":"themes/3-hexo/source/css/fonts/icomoon.woff","hash":"3985d29416bb9b19f50a2f20f2bbbce47f10af8d","modified":1578923033984},{"_id":"themes/3-hexo/source/css/fonts/iconfont.woff","hash":"f8ed131ccf13f4bdd3ec11fc3e997339dd7b66ba","modified":1578923034002},{"_id":"themes/3-hexo/source/css/fonts/selection.json","hash":"b6456a4eabcffd95e822d1d7adce96da524d481a","modified":1578923034006},{"_id":"themes/3-hexo/source/css/hl_theme/atom-dark.styl","hash":"f3eb4e5feda9cbd6242ccf44ca064e2979b5d719","modified":1578923034014},{"_id":"themes/3-hexo/source/css/hl_theme/atom-light.styl","hash":"69d184a682bcaeba2b180b437dc4431bc3be38aa","modified":1578923034018},{"_id":"themes/3-hexo/source/css/hl_theme/brown-paper.styl","hash":"03af387edcc1cf8c18d12e9c440fd51b6cf425b6","modified":1578923034021},{"_id":"themes/3-hexo/source/css/hl_theme/darcula.styl","hash":"2bfc14f27ccca108b4b3755782de8366e8bd001e","modified":1578923034024},{"_id":"themes/3-hexo/source/css/hl_theme/github-gist.styl","hash":"5e05b19832c1099bd9d284bc3ed00dc8a3d7ee23","modified":1578923034029},{"_id":"themes/3-hexo/source/css/hl_theme/github.styl","hash":"53276ff1f224f691dfe811e82c0af7f4476abf5d","modified":1578923034032},{"_id":"themes/3-hexo/source/css/hl_theme/gruvbox-dark.styl","hash":"315ad610d303caba9eac80a7d51002193a15478a","modified":1578923034036},{"_id":"themes/3-hexo/source/css/hl_theme/gruvbox-light.styl","hash":"1bece084b1dbbbd4af064f05feffd8c332b96a48","modified":1578923034038},{"_id":"themes/3-hexo/source/css/hl_theme/kimbie-dark.styl","hash":"e9c190f9ffc37a13cac430512e4e0c760205be4a","modified":1578923034041},{"_id":"themes/3-hexo/source/css/hl_theme/kimbie-light.styl","hash":"0c3ccd0d64e7504c7061d246dc32737f502f64e4","modified":1578923034045},{"_id":"themes/3-hexo/source/css/hl_theme/railscasts.styl","hash":"a6e8cfd2202afd7893f5268f3437421e35066e7b","modified":1578923034047},{"_id":"themes/3-hexo/source/css/hl_theme/rainbow.styl","hash":"e5c37646a9d9c1094f9aab7a7c65a4b242e8db00","modified":1578923034052},{"_id":"themes/3-hexo/source/css/hl_theme/school-book.styl","hash":"51659351b391a2be5c68728bb51b7ad467c5e0db","modified":1578923034055},{"_id":"themes/3-hexo/source/css/hl_theme/sublime.styl","hash":"501d75ef0f4385bea24d9b9b4cc434ba68d4be27","modified":1578923034058},{"_id":"themes/3-hexo/source/css/hl_theme/sunburst.styl","hash":"2aa9817e68fb2ed216781ea04b733039ebe18214","modified":1578923034062},{"_id":"themes/3-hexo/source/css/fonts/iconfont.eot","hash":"3dfe8e557d9dfaf39bca088a02b76deb82dbaa3d","modified":1578923033987},{"_id":"themes/3-hexo/source/css/hl_theme/zenbum.styl","hash":"92941a6ae73b74f44ad7c559c5548c44073c644a","modified":1578923034065},{"_id":"themes/3-hexo/source/images/Python特性/TypeError1.png","hash":"3bee26a28c50c682d37353c54c744db7400cd199","modified":1579763415371},{"_id":"themes/3-hexo/source/images/Python特性/dynamic1.png","hash":"7cfda8f81fdb8694d258c841fe8686bfe38962b7","modified":1579763431604},{"_id":"themes/3-hexo/source/images/Python特性/dynamic2.png","hash":"cae1d97b658295f80fc8db83559ec3e187e82ccc","modified":1579763439186},{"_id":"themes/3-hexo/source/images/Python特性/dynamic3.png","hash":"e857dffd839825e4c728826c2b5e4fc9e31e67bc","modified":1579763444001},{"_id":"themes/3-hexo/source/images/Python特性/dynamic4.png","hash":"a05bce4e0d48e3a0cabc8002f2312df0510af1b7","modified":1579763452161},{"_id":"themes/3-hexo/source/images/Python特性/introduce.png","hash":"dca90e3f78c4c98397a89d5794bbcd1ce88fac53","modified":1579763459122},{"_id":"themes/3-hexo/source/img/article.jpg","hash":"1a3451c8af089b00deda14e1e83d719d29b119da","modified":1579792623958},{"_id":"themes/3-hexo/source/css/fonts/iconfont.ttf","hash":"aa087561480fb9c2cfd541e33d1e99d5ac1a56bb","modified":1578923033999},{"_id":"themes/3-hexo/source/css/fonts/iconfont.svg","hash":"7e54ae44c02faa319c4fe128e1e6bda38eae5c9d","modified":1578923033991},{"_id":"themes/3-hexo/source/js/gitment.js","hash":"67984b83cd46ff4300d4fd959bf6c17dd66b4136","modified":1578923034131},{"_id":"themes/3-hexo/source/js/gitalk.js","hash":"536f28c4354a13582af826d9d9b2cb27cec07dc6","modified":1578923034120},{"_id":"themes/3-hexo/source/img/preview.jpg","hash":"506dcade3f6153eb2c350a67c615d84c710c8ac6","modified":1579791586441},{"_id":"public/about/index.html","hash":"aa5cd0d88f94313b5f6b874b05bbaae841aa44c6","modified":1579944870132},{"_id":"public/tags/index.html","hash":"9485ea2cb8d17a87cfd581648b7246521b9bfd70","modified":1579944870132},{"_id":"public/2019/11/10/强类型与动态类型的Python/index.html","hash":"138ee04ed6d5466eb41b2ac927a2ad488836df93","modified":1579944870132},{"_id":"public/2019/11/10/用树结构获取自然数拆分结果/index.html","hash":"a412c98665672ac014ad87086bd16bbed862e1a8","modified":1579944870132},{"_id":"public/2019/11/10/用树结构获取字符排列组合/index.html","hash":"842e4b188cd4f7a0be93f3f3315ec36c69b34e76","modified":1579944870132},{"_id":"public/2019/09/11/数据结构基础/index.html","hash":"1610c85c5438beddb2fb0a53b7009cbcfe578b4b","modified":1579944870132},{"_id":"public/2019/06/02/python程序打包成exe文件/index.html","hash":"9a9eb81083a800c94523d96c222ee03ada507fdb","modified":1579944870132},{"_id":"public/2019/04/08/MySQL安装到登陆的问题/index.html","hash":"e22c565b61c5605e971efd90a4ad1e0cd34e98c9","modified":1579944870132},{"_id":"public/2019/04/04/机器学习资源分享/index.html","hash":"c05ca44aa71951753fe3dea0f28f083174a998d7","modified":1579944870132},{"_id":"public/2019/03/29/使用Hexo-NexT时遇到的问题/index.html","hash":"38cf8514b88d0649947941d8f704f506dfda7329","modified":1579944870132},{"_id":"public/archives/index.html","hash":"ea600f63f56fa0c3b7e51fcecfce463ed313853a","modified":1579944870132},{"_id":"public/archives/2019/index.html","hash":"ea600f63f56fa0c3b7e51fcecfce463ed313853a","modified":1579944870132},{"_id":"public/archives/2019/03/index.html","hash":"ea600f63f56fa0c3b7e51fcecfce463ed313853a","modified":1579944870132},{"_id":"public/archives/2019/04/index.html","hash":"ea600f63f56fa0c3b7e51fcecfce463ed313853a","modified":1579944870132},{"_id":"public/archives/2019/06/index.html","hash":"ea600f63f56fa0c3b7e51fcecfce463ed313853a","modified":1579944870132},{"_id":"public/archives/2019/09/index.html","hash":"ea600f63f56fa0c3b7e51fcecfce463ed313853a","modified":1579944870132},{"_id":"public/archives/2019/11/index.html","hash":"ea600f63f56fa0c3b7e51fcecfce463ed313853a","modified":1579944870132},{"_id":"public/categories/开发记录/index.html","hash":"ea600f63f56fa0c3b7e51fcecfce463ed313853a","modified":1579944870132},{"_id":"public/categories/学习笔记/index.html","hash":"ea600f63f56fa0c3b7e51fcecfce463ed313853a","modified":1579944870132},{"_id":"public/categories/技术文章/index.html","hash":"ea600f63f56fa0c3b7e51fcecfce463ed313853a","modified":1579944870132},{"_id":"public/tags/Python/index.html","hash":"ea600f63f56fa0c3b7e51fcecfce463ed313853a","modified":1579944870132},{"_id":"public/tags/博客/index.html","hash":"ea600f63f56fa0c3b7e51fcecfce463ed313853a","modified":1579944870132},{"_id":"public/tags/深度学习-神经网络/index.html","hash":"ea600f63f56fa0c3b7e51fcecfce463ed313853a","modified":1579944870132},{"_id":"public/tags/MySQL/index.html","hash":"ea600f63f56fa0c3b7e51fcecfce463ed313853a","modified":1579944870132},{"_id":"public/index.html","hash":"ea600f63f56fa0c3b7e51fcecfce463ed313853a","modified":1579944870132},{"_id":"public/img/brown-papersq.png","hash":"3a1332ede3a75a3d24f60b6ed69035b72da5e182","modified":1579793044642},{"_id":"public/img/school-book.png","hash":"711ec983c874e093bb89eb77afcbdf6741fa61ee","modified":1579793044642},{"_id":"public/css/fonts/icomoon.ttf","hash":"eb976d8b8559fcddfc2658a03a4350cb566fc06b","modified":1579793044642},{"_id":"public/css/fonts/icomoon.svg","hash":"b5e7562c8494b0ddb3a70ecc5545ef7340d8e971","modified":1579793044642},{"_id":"public/css/fonts/icomoon.eot","hash":"b6195bedc1cb2f9cfcb26cc27021f2e94be2ab0a","modified":1579793044642},{"_id":"public/css/fonts/icomoon.woff","hash":"3985d29416bb9b19f50a2f20f2bbbce47f10af8d","modified":1579793044642},{"_id":"public/css/fonts/iconfont.woff","hash":"f8ed131ccf13f4bdd3ec11fc3e997339dd7b66ba","modified":1579793044642},{"_id":"public/css/fonts/iconfont.eot","hash":"3dfe8e557d9dfaf39bca088a02b76deb82dbaa3d","modified":1579793044642},{"_id":"public/images/Python特性/dynamic1.png","hash":"7cfda8f81fdb8694d258c841fe8686bfe38962b7","modified":1579793044642},{"_id":"public/images/Python特性/TypeError1.png","hash":"3bee26a28c50c682d37353c54c744db7400cd199","modified":1579793044642},{"_id":"public/images/Python特性/dynamic2.png","hash":"cae1d97b658295f80fc8db83559ec3e187e82ccc","modified":1579793044642},{"_id":"public/images/Python特性/dynamic3.png","hash":"e857dffd839825e4c728826c2b5e4fc9e31e67bc","modified":1579793044642},{"_id":"public/images/Python特性/dynamic4.png","hash":"a05bce4e0d48e3a0cabc8002f2312df0510af1b7","modified":1579793044642},{"_id":"public/images/Python特性/introduce.png","hash":"dca90e3f78c4c98397a89d5794bbcd1ce88fac53","modified":1579793044642},{"_id":"public/css/fonts/iconfont.ttf","hash":"aa087561480fb9c2cfd541e33d1e99d5ac1a56bb","modified":1579793044642},{"_id":"public/css/fonts/iconfont.svg","hash":"7e54ae44c02faa319c4fe128e1e6bda38eae5c9d","modified":1579793044642},{"_id":"public/img/article-list-background.jpg","hash":"b579af6819ee49d524b074167201adef09575629","modified":1579793044642},{"_id":"public/img/alipay.jpg","hash":"e70a57b660caa38f36f30794e8d657a218841fd5","modified":1579793044642},{"_id":"public/img/weixin.jpg","hash":"f536bdbf78f988e57562f715c0a5b96b6cde4bba","modified":1579793044642},{"_id":"public/css/custom.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1579793044642},{"_id":"public/css/mobile.css","hash":"90a2542d535276b09730a7f56b2fc5789515e4ff","modified":1579793044642},{"_id":"public/js/search.js","hash":"c80c9a231ee040c7adc07a477793873fb85ce8bc","modified":1579793044642},{"_id":"public/js/jquery.autocomplete.min.js","hash":"7b8ac4d06c9e763963832529f44a56ad42a81e5f","modified":1579793044642},{"_id":"public/css/hl_theme/atom-dark.css","hash":"88d11052a24e8100af6248eb4dbe1ce7b0e96408","modified":1579793044642},{"_id":"public/css/hl_theme/atom-light.css","hash":"a3c8f3ee9a655594eff7ac545cb2e6914c1abcc2","modified":1579793044642},{"_id":"public/css/hl_theme/brown-paper.css","hash":"500c8e750373f6656ff49a7857c871ceedcf8777","modified":1579793044642},{"_id":"public/css/hl_theme/darcula.css","hash":"4341074bae4bc9f0b86e32b623e27babc0159b6e","modified":1579793044642},{"_id":"public/css/hl_theme/github.css","hash":"e05a0806a508a26b9f3f3794b6b588ec6504ad3f","modified":1579793044642},{"_id":"public/css/hl_theme/github-gist.css","hash":"7a41c1c479d09df875f99f1f6d94aac42e9e2ad0","modified":1579793044642},{"_id":"public/css/hl_theme/gruvbox-dark.css","hash":"8c440d9b4ee19ac03eaee3c6af78ba52e5ba5535","modified":1579793044642},{"_id":"public/css/hl_theme/kimbie-dark.css","hash":"728527fcc308da454722c119b89e6da3025bd1e3","modified":1579793044642},{"_id":"public/css/hl_theme/railscasts.css","hash":"511f2fd2a84d426e5da5cb17880cc08f73beb002","modified":1579793044642},{"_id":"public/css/hl_theme/kimbie-light.css","hash":"0c61926c989163faefb031d27bce3e287d6e10f2","modified":1579793044642},{"_id":"public/css/hl_theme/rainbow.css","hash":"7ff4251938076ddb7e4e49413db82653e5b61321","modified":1579793044642},{"_id":"public/css/hl_theme/gruvbox-light.css","hash":"30514aaa242a34647aa666cfca4fc74c595ea8f2","modified":1579793044642},{"_id":"public/css/hl_theme/school-book.css","hash":"ffbbcd13a74ac2404262c50b7a43053dfd0096ff","modified":1579793044642},{"_id":"public/css/hl_theme/sublime.css","hash":"f65c5b116d9213afb9c324384a2f3bc86cb71121","modified":1579793044642},{"_id":"public/css/hl_theme/sunburst.css","hash":"8a135abac1512cf430d1d1ad2304b79afa1a4d6e","modified":1579793044642},{"_id":"public/css/hl_theme/zenbum.css","hash":"0a78f74a93568e20b32ca7427c719e9bae9a0b55","modified":1579793044642},{"_id":"public/css/gitalk.css","hash":"58177ce227c50ee359fbf99a4fdd26058887afc5","modified":1579793044642},{"_id":"public/css/style.css","hash":"4bfea03326e51a2f866458961bf10f6a5551c467","modified":1579793044642},{"_id":"public/js/iconfont.js","hash":"3a0869ca1b09af07d82987e343a3bc4cb9558ecb","modified":1579793044642},{"_id":"public/js/script.js","hash":"7502191e29366a11323dc72ae365b1aed254e6f2","modified":1579793044642},{"_id":"public/js/jquery.pjax.js","hash":"191c49fdb40dff115a49cfd2b30dffb888d86550","modified":1579793044642},{"_id":"public/css/fonts/selection.json","hash":"047b615ea32dc48dae5b964061427d41feaaafdf","modified":1579793044642},{"_id":"public/js/gitment.js","hash":"59a1e03f2b0ce61dd9bd405d3c52d3e07cc10dec","modified":1579793044642},{"_id":"public/js/gitalk.js","hash":"d1eb82a3280981bd652d9a8e323060e4311c547b","modified":1579793044642},{"_id":"public/img/avatar.jpg","hash":"d8dba617be564e3a7035fcb5c820475a71387d60","modified":1579793044642},{"_id":"public/img/article.jpg","hash":"1a3451c8af089b00deda14e1e83d719d29b119da","modified":1579793044642},{"_id":"public/img/preview.jpg","hash":"506dcade3f6153eb2c350a67c615d84c710c8ac6","modified":1579793044642},{"_id":"source/_posts/Flask请求钩子.md","hash":"0fce7884ac75257333d4511d3f3015a51ab6dcbe","modified":1579800746692},{"_id":"public/2020/01/24/Flask请求钩子/index.html","hash":"1801d6ac7cc0ace49dbba1c871eae0b24202b0a5","modified":1579803570106},{"_id":"public/archives/2020/index.html","hash":"ea600f63f56fa0c3b7e51fcecfce463ed313853a","modified":1579944870132},{"_id":"public/archives/2020/01/index.html","hash":"ea600f63f56fa0c3b7e51fcecfce463ed313853a","modified":1579944870132},{"_id":"source/images/数据逻辑结构层次图.jpg","hash":"12d91d50cfa6c3f47248332e16094adc5165e7c4","modified":1579800039620},{"_id":"source/images/Python特性/TypeError1.png","hash":"3bee26a28c50c682d37353c54c744db7400cd199","modified":1579763415371},{"_id":"source/images/Python特性/dynamic1.png","hash":"7cfda8f81fdb8694d258c841fe8686bfe38962b7","modified":1579763431604},{"_id":"source/images/Python特性/dynamic3.png","hash":"e857dffd839825e4c728826c2b5e4fc9e31e67bc","modified":1579763444001},{"_id":"source/images/Python特性/dynamic2.png","hash":"cae1d97b658295f80fc8db83559ec3e187e82ccc","modified":1579763439186},{"_id":"source/images/Python特性/dynamic4.png","hash":"a05bce4e0d48e3a0cabc8002f2312df0510af1b7","modified":1579763452161},{"_id":"source/images/Python特性/introduce.png","hash":"dca90e3f78c4c98397a89d5794bbcd1ce88fac53","modified":1579763459122},{"_id":"public/images/数据逻辑结构层次图.jpg","hash":"12d91d50cfa6c3f47248332e16094adc5165e7c4","modified":1579800208862},{"_id":"public/tags/Flask/index.html","hash":"4ec65c30f27fad3256ecbecf7f3219c8fc9b0bd2","modified":1579803570106},{"_id":"source/CNAME","hash":"440ddcd92585f97aa09ec6414ee6c46599ff9ea3","modified":1568529324463},{"_id":"source/_posts/关于沉迷于东方Project这件事.md","hash":"f6db5b875a484bf7a25a3f692211e66204f69340","modified":1579838110806},{"_id":"public/2020/01/24/关于沉迷于东方Project这件事/index.html","hash":"a9c793125aaed9a4ea443461b378b0e33693f774","modified":1579944870132},{"_id":"public/categories/生活日常/index.html","hash":"ea600f63f56fa0c3b7e51fcecfce463ed313853a","modified":1579944870132},{"_id":"public/CNAME","hash":"440ddcd92585f97aa09ec6414ee6c46599ff9ea3","modified":1579838139638},{"_id":"source/_posts/使用twine把项目打成pip包.md","hash":"77ca8ac0283b3a6af8d7d7a0ab13a179b34abfef","modified":1579940534137},{"_id":"public/2020/01/25/使用twine把项目打成pip包/index.html","hash":"e7b8a4ffa1b7b9865b923d3eae0ae5e8b5218abd","modified":1579944870132},{"_id":"source/_posts/算法导论python快速排序代码理解.md","hash":"443b6ca669a93187c7111f37e8e7e9c2f6ed8e96","modified":1579944838137},{"_id":"public/2020/01/25/算法导论python快速排序代码理解/index.html","hash":"740162a2902a3c929d169138d83456395d4755b1","modified":1579944870132},{"_id":"public/page/2/index.html","hash":"ea600f63f56fa0c3b7e51fcecfce463ed313853a","modified":1579944870132},{"_id":"public/archives/page/2/index.html","hash":"ea600f63f56fa0c3b7e51fcecfce463ed313853a","modified":1579944870132}],"Category":[{"name":"开发记录","_id":"ck5qvznmu0004gcv54ryvhy4u"},{"name":"学习笔记","_id":"ck5qvznnp000fgcv5620l0wus"},{"name":"技术文章","_id":"ck5qvzno0000mgcv5adtcefzz"},{"name":"开发","_id":"ck5r0iwnd00033cv592o40888"},{"name":"开发日记","_id":"ck5r0ixlu00053cv5drhi7f0c"},{"name":"生活日常","_id":"ck5rmu7us00015cv5e52abcxy"}],"Data":[],"Page":[{"title":"关于我自己","date":"2020-01-23T06:51:57.000Z","_content":"\n\n**关于我自己的兴趣爱好**\n---\n\n**从小到大喜欢玩游戏，现在玩的主要是王者和东京七姐妹，可以说我大部分类型的游戏都玩**\n**以前喜欢打篮球，现在到球场只能感叹“年轻真好”**\n**喜欢听歌，喜欢唱歌，喜欢看动漫，也喜欢游戏同人作品**\n**现在对计算机方面的技术非常痴迷，一个是兴趣点刚好在这，一个是自身学习能力和执着于探究的性格，也有一些童年的原因**\n**可以说是一个二次猿+程序猿，嗯，同时也是一个直男吧...**\n\n**一点点信息**\n---\n\n**现实日常不太擅长说话，倒是挺喜欢边观察边思考别人说话和做事**\n**博客从大一的时候就搭建了，当时没什么东西可以写的，倒是这段时间不嫌费劲不怕浪费时间挺执着于给博客弄漂亮一点，换了几个主题**\n**目前主要使用的编程语言是Python，当然Java也会，就是比较喜欢Python而已**\n\n**自己给自己的几句话**\n---\n\n**1、不怕自己犯错误，不怕别人的批评，该被批评就接，犯了错误就改**\n**2、正しさなんてもの、人のモノサシによって変わる(所谓的正义因不同人的标准而不同)**\n**3、不给他人决定道路，不让自己走歪路**\n\n**实际项目**\n---\n\n|**所属**|**项目名称**|**开始时间**|**开发周期**|\n|:---|:---:|:---:|:---:|\n|**东莞理工学院城市学院校易班学生工作站**|**城院易班微信小程序**|**2019-11**|**2个星期**|\n|**东莞理工学院城市学院校易班学生工作站**|**2020新年祝福专栏网站**|**2020-1**|**18天**|\n","source":"about/index.md","raw":"---\ntitle: 关于我自己\ndate: 2020-01-23 14:51:57\n---\n\n\n**关于我自己的兴趣爱好**\n---\n\n**从小到大喜欢玩游戏，现在玩的主要是王者和东京七姐妹，可以说我大部分类型的游戏都玩**\n**以前喜欢打篮球，现在到球场只能感叹“年轻真好”**\n**喜欢听歌，喜欢唱歌，喜欢看动漫，也喜欢游戏同人作品**\n**现在对计算机方面的技术非常痴迷，一个是兴趣点刚好在这，一个是自身学习能力和执着于探究的性格，也有一些童年的原因**\n**可以说是一个二次猿+程序猿，嗯，同时也是一个直男吧...**\n\n**一点点信息**\n---\n\n**现实日常不太擅长说话，倒是挺喜欢边观察边思考别人说话和做事**\n**博客从大一的时候就搭建了，当时没什么东西可以写的，倒是这段时间不嫌费劲不怕浪费时间挺执着于给博客弄漂亮一点，换了几个主题**\n**目前主要使用的编程语言是Python，当然Java也会，就是比较喜欢Python而已**\n\n**自己给自己的几句话**\n---\n\n**1、不怕自己犯错误，不怕别人的批评，该被批评就接，犯了错误就改**\n**2、正しさなんてもの、人のモノサシによって変わる(所谓的正义因不同人的标准而不同)**\n**3、不给他人决定道路，不让自己走歪路**\n\n**实际项目**\n---\n\n|**所属**|**项目名称**|**开始时间**|**开发周期**|\n|:---|:---:|:---:|:---:|\n|**东莞理工学院城市学院校易班学生工作站**|**城院易班微信小程序**|**2019-11**|**2个星期**|\n|**东莞理工学院城市学院校易班学生工作站**|**2020新年祝福专栏网站**|**2020-1**|**18天**|\n","updated":"2020-01-23T17:46:22.240Z","path":"about/index.html","_id":"ck5qvznml0001gcv50n370aq6","comments":1,"layout":"page","content":"<h2 id=\"关于我自己的兴趣爱好\"><a href=\"#关于我自己的兴趣爱好\" class=\"headerlink\" title=\"关于我自己的兴趣爱好\"></a><strong>关于我自己的兴趣爱好</strong></h2><p><strong>从小到大喜欢玩游戏，现在玩的主要是王者和东京七姐妹，可以说我大部分类型的游戏都玩</strong><br><strong>以前喜欢打篮球，现在到球场只能感叹“年轻真好”</strong><br><strong>喜欢听歌，喜欢唱歌，喜欢看动漫，也喜欢游戏同人作品</strong><br><strong>现在对计算机方面的技术非常痴迷，一个是兴趣点刚好在这，一个是自身学习能力和执着于探究的性格，也有一些童年的原因</strong><br><strong>可以说是一个二次猿+程序猿，嗯，同时也是一个直男吧…</strong></p>\n<h2 id=\"一点点信息\"><a href=\"#一点点信息\" class=\"headerlink\" title=\"一点点信息\"></a><strong>一点点信息</strong></h2><p><strong>现实日常不太擅长说话，倒是挺喜欢边观察边思考别人说话和做事</strong><br><strong>博客从大一的时候就搭建了，当时没什么东西可以写的，倒是这段时间不嫌费劲不怕浪费时间挺执着于给博客弄漂亮一点，换了几个主题</strong><br><strong>目前主要使用的编程语言是Python，当然Java也会，就是比较喜欢Python而已</strong></p>\n<h2 id=\"自己给自己的几句话\"><a href=\"#自己给自己的几句话\" class=\"headerlink\" title=\"自己给自己的几句话\"></a><strong>自己给自己的几句话</strong></h2><p><strong>1、不怕自己犯错误，不怕别人的批评，该被批评就接，犯了错误就改</strong><br><strong>2、正しさなんてもの、人のモノサシによって変わる(所谓的正义因不同人的标准而不同)</strong><br><strong>3、不给他人决定道路，不让自己走歪路</strong></p>\n<h2 id=\"实际项目\"><a href=\"#实际项目\" class=\"headerlink\" title=\"实际项目\"></a><strong>实际项目</strong></h2><table>\n<thead>\n<tr>\n<th align=\"left\"><strong>所属</strong></th>\n<th align=\"center\"><strong>项目名称</strong></th>\n<th align=\"center\"><strong>开始时间</strong></th>\n<th align=\"center\"><strong>开发周期</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>东莞理工学院城市学院校易班学生工作站</strong></td>\n<td align=\"center\"><strong>城院易班微信小程序</strong></td>\n<td align=\"center\"><strong>2019-11</strong></td>\n<td align=\"center\"><strong>2个星期</strong></td>\n</tr>\n<tr>\n<td align=\"left\"><strong>东莞理工学院城市学院校易班学生工作站</strong></td>\n<td align=\"center\"><strong>2020新年祝福专栏网站</strong></td>\n<td align=\"center\"><strong>2020-1</strong></td>\n<td align=\"center\"><strong>18天</strong></td>\n</tr>\n</tbody></table>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"关于我自己的兴趣爱好\"><a href=\"#关于我自己的兴趣爱好\" class=\"headerlink\" title=\"关于我自己的兴趣爱好\"></a><strong>关于我自己的兴趣爱好</strong></h2><p><strong>从小到大喜欢玩游戏，现在玩的主要是王者和东京七姐妹，可以说我大部分类型的游戏都玩</strong><br><strong>以前喜欢打篮球，现在到球场只能感叹“年轻真好”</strong><br><strong>喜欢听歌，喜欢唱歌，喜欢看动漫，也喜欢游戏同人作品</strong><br><strong>现在对计算机方面的技术非常痴迷，一个是兴趣点刚好在这，一个是自身学习能力和执着于探究的性格，也有一些童年的原因</strong><br><strong>可以说是一个二次猿+程序猿，嗯，同时也是一个直男吧…</strong></p>\n<h2 id=\"一点点信息\"><a href=\"#一点点信息\" class=\"headerlink\" title=\"一点点信息\"></a><strong>一点点信息</strong></h2><p><strong>现实日常不太擅长说话，倒是挺喜欢边观察边思考别人说话和做事</strong><br><strong>博客从大一的时候就搭建了，当时没什么东西可以写的，倒是这段时间不嫌费劲不怕浪费时间挺执着于给博客弄漂亮一点，换了几个主题</strong><br><strong>目前主要使用的编程语言是Python，当然Java也会，就是比较喜欢Python而已</strong></p>\n<h2 id=\"自己给自己的几句话\"><a href=\"#自己给自己的几句话\" class=\"headerlink\" title=\"自己给自己的几句话\"></a><strong>自己给自己的几句话</strong></h2><p><strong>1、不怕自己犯错误，不怕别人的批评，该被批评就接，犯了错误就改</strong><br><strong>2、正しさなんてもの、人のモノサシによって変わる(所谓的正义因不同人的标准而不同)</strong><br><strong>3、不给他人决定道路，不让自己走歪路</strong></p>\n<h2 id=\"实际项目\"><a href=\"#实际项目\" class=\"headerlink\" title=\"实际项目\"></a><strong>实际项目</strong></h2><table>\n<thead>\n<tr>\n<th align=\"left\"><strong>所属</strong></th>\n<th align=\"center\"><strong>项目名称</strong></th>\n<th align=\"center\"><strong>开始时间</strong></th>\n<th align=\"center\"><strong>开发周期</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>东莞理工学院城市学院校易班学生工作站</strong></td>\n<td align=\"center\"><strong>城院易班微信小程序</strong></td>\n<td align=\"center\"><strong>2019-11</strong></td>\n<td align=\"center\"><strong>2个星期</strong></td>\n</tr>\n<tr>\n<td align=\"left\"><strong>东莞理工学院城市学院校易班学生工作站</strong></td>\n<td align=\"center\"><strong>2020新年祝福专栏网站</strong></td>\n<td align=\"center\"><strong>2020-1</strong></td>\n<td align=\"center\"><strong>18天</strong></td>\n</tr>\n</tbody></table>\n"},{"title":"tags","date":"2020-01-23T07:15:26.000Z","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2020-01-23 15:15:26\n---\n","updated":"2020-01-23T07:15:26.790Z","path":"tags/index.html","comments":1,"layout":"page","_id":"ck5qvznmq0003gcv52usahd7c","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Python程序打包成exe可执行文件","date":"2019-06-01T16:00:00.000Z","_content":"\n### 本教程是使用Pyinstaller来将Python程序打包成exe可执行文件\n\n### **实现步骤：**\n\n**首先要安装Pyinstaller包，在命令行窗口使用pip指令就可以完成：**\n`pip install pyinstaller`\n**安装成功后就可以进行打包了**\n**首先在命令行进入要打包的python程序的目录下面**\n**接着使用**   `pyinstaller file.py`   **就可以打包了(file.py是指你要打包的python文件)**\n**这个指令也可以附带其他属性：**\n\n```text\n-F  表示生成单个可执行文件\n-D  创建一个目录，包含exe文件和依赖很多文件（默认选项）\n-w  表示去掉控制台窗口，这样执行exe文件的时候不会出现窗口，但会在后台运行，用命令行还是可以看见执行情况的\n-c  使用控制台，无界面(默认)；\n-p  表示你自己自定义需要加载的类路径\n-i  表示可执行文件的图标。\n```\n\n**例如我要生成一个带图标的exe文件，没有其他依赖文件的，那么就是使用指令：**\n`pyinstaller -F -i image.ico file.py`   **（image.ico表示图标的路径，file.py表示要打包的python文件）**\n**打包后会生成dict文件夹和buid文件夹还有一个.spec文件，其中dict就是放置我们要的exe文件的文件夹，其他两个是生成exe文件的过程中的中间产物，可以删掉。**\n**pyinstaller打包的时候会自动把其他依赖的包和其他python文件引入，所以不用担心调用的问题。**\n**但是其他要使用到的文件并不会被添加进去，例如要使用的图片或者文档，所以要自己把文件添加到打包完的exe文件的目录下面相应的路径，否则会出现闪退或者文件执行失败。**\n**另外就是，如果py文件的编码是utf8，但是文件里面又有中文的话，那么使用windows的命令行打包会出现编码错误。**\n**解决的方法就是先使用chcp指令进入其他编码的命令行**\n\n**以下是几种常用的编码:**\n```text\nGBK(一般情况下为默认编码) 936\n美国英语 437\nutf-8 65001\n```\n\n**在这里我们要使用utf-8的编码，所以使用命令:**\n`chcp 65001`\n**设置编码后再进行打包就不会出现编码错误的情况了**\n\n**最后就是，第一次打包出来的程序经常会出现各种问题，建议在命令行执行exe文件，这样可以看到报错的内容，以便结合情况解决问题。**","source":"_posts/python程序打包成exe文件.md","raw":"---\ntitle: Python程序打包成exe可执行文件\ndate: 2019-6-2\ncategories: 技术文章\ntags:\n    -Python\n---\n\n### 本教程是使用Pyinstaller来将Python程序打包成exe可执行文件\n\n### **实现步骤：**\n\n**首先要安装Pyinstaller包，在命令行窗口使用pip指令就可以完成：**\n`pip install pyinstaller`\n**安装成功后就可以进行打包了**\n**首先在命令行进入要打包的python程序的目录下面**\n**接着使用**   `pyinstaller file.py`   **就可以打包了(file.py是指你要打包的python文件)**\n**这个指令也可以附带其他属性：**\n\n```text\n-F  表示生成单个可执行文件\n-D  创建一个目录，包含exe文件和依赖很多文件（默认选项）\n-w  表示去掉控制台窗口，这样执行exe文件的时候不会出现窗口，但会在后台运行，用命令行还是可以看见执行情况的\n-c  使用控制台，无界面(默认)；\n-p  表示你自己自定义需要加载的类路径\n-i  表示可执行文件的图标。\n```\n\n**例如我要生成一个带图标的exe文件，没有其他依赖文件的，那么就是使用指令：**\n`pyinstaller -F -i image.ico file.py`   **（image.ico表示图标的路径，file.py表示要打包的python文件）**\n**打包后会生成dict文件夹和buid文件夹还有一个.spec文件，其中dict就是放置我们要的exe文件的文件夹，其他两个是生成exe文件的过程中的中间产物，可以删掉。**\n**pyinstaller打包的时候会自动把其他依赖的包和其他python文件引入，所以不用担心调用的问题。**\n**但是其他要使用到的文件并不会被添加进去，例如要使用的图片或者文档，所以要自己把文件添加到打包完的exe文件的目录下面相应的路径，否则会出现闪退或者文件执行失败。**\n**另外就是，如果py文件的编码是utf8，但是文件里面又有中文的话，那么使用windows的命令行打包会出现编码错误。**\n**解决的方法就是先使用chcp指令进入其他编码的命令行**\n\n**以下是几种常用的编码:**\n```text\nGBK(一般情况下为默认编码) 936\n美国英语 437\nutf-8 65001\n```\n\n**在这里我们要使用utf-8的编码，所以使用命令:**\n`chcp 65001`\n**设置编码后再进行打包就不会出现编码错误的情况了**\n\n**最后就是，第一次打包出来的程序经常会出现各种问题，建议在命令行执行exe文件，这样可以看到报错的内容，以便结合情况解决问题。**","slug":"python程序打包成exe文件","published":1,"updated":"2020-01-25T06:50:51.838Z","_id":"ck5qvznm60000gcv55by36f6n","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"本教程是使用Pyinstaller来将Python程序打包成exe可执行文件\"><a href=\"#本教程是使用Pyinstaller来将Python程序打包成exe可执行文件\" class=\"headerlink\" title=\"本教程是使用Pyinstaller来将Python程序打包成exe可执行文件\"></a>本教程是使用Pyinstaller来将Python程序打包成exe可执行文件</h3><h3 id=\"实现步骤：\"><a href=\"#实现步骤：\" class=\"headerlink\" title=\"实现步骤：\"></a><strong>实现步骤：</strong></h3><p><strong>首先要安装Pyinstaller包，在命令行窗口使用pip指令就可以完成：</strong><br><code>pip install pyinstaller</code><br><strong>安装成功后就可以进行打包了</strong><br><strong>首先在命令行进入要打包的python程序的目录下面</strong><br><strong>接着使用</strong>   <code>pyinstaller file.py</code>   <strong>就可以打包了(file.py是指你要打包的python文件)</strong><br><strong>这个指令也可以附带其他属性：</strong></p>\n<pre><code class=\"text\">-F  表示生成单个可执行文件\n-D  创建一个目录，包含exe文件和依赖很多文件（默认选项）\n-w  表示去掉控制台窗口，这样执行exe文件的时候不会出现窗口，但会在后台运行，用命令行还是可以看见执行情况的\n-c  使用控制台，无界面(默认)；\n-p  表示你自己自定义需要加载的类路径\n-i  表示可执行文件的图标。</code></pre>\n<p><strong>例如我要生成一个带图标的exe文件，没有其他依赖文件的，那么就是使用指令：</strong><br><code>pyinstaller -F -i image.ico file.py</code>   <strong>（image.ico表示图标的路径，file.py表示要打包的python文件）</strong><br><strong>打包后会生成dict文件夹和buid文件夹还有一个.spec文件，其中dict就是放置我们要的exe文件的文件夹，其他两个是生成exe文件的过程中的中间产物，可以删掉。</strong><br><strong>pyinstaller打包的时候会自动把其他依赖的包和其他python文件引入，所以不用担心调用的问题。</strong><br><strong>但是其他要使用到的文件并不会被添加进去，例如要使用的图片或者文档，所以要自己把文件添加到打包完的exe文件的目录下面相应的路径，否则会出现闪退或者文件执行失败。</strong><br><strong>另外就是，如果py文件的编码是utf8，但是文件里面又有中文的话，那么使用windows的命令行打包会出现编码错误。</strong><br><strong>解决的方法就是先使用chcp指令进入其他编码的命令行</strong></p>\n<p><strong>以下是几种常用的编码:</strong></p>\n<pre><code class=\"text\">GBK(一般情况下为默认编码) 936\n美国英语 437\nutf-8 65001</code></pre>\n<p><strong>在这里我们要使用utf-8的编码，所以使用命令:</strong><br><code>chcp 65001</code><br><strong>设置编码后再进行打包就不会出现编码错误的情况了</strong></p>\n<p><strong>最后就是，第一次打包出来的程序经常会出现各种问题，建议在命令行执行exe文件，这样可以看到报错的内容，以便结合情况解决问题。</strong></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"本教程是使用Pyinstaller来将Python程序打包成exe可执行文件\"><a href=\"#本教程是使用Pyinstaller来将Python程序打包成exe可执行文件\" class=\"headerlink\" title=\"本教程是使用Pyinstaller来将Python程序打包成exe可执行文件\"></a>本教程是使用Pyinstaller来将Python程序打包成exe可执行文件</h3><h3 id=\"实现步骤：\"><a href=\"#实现步骤：\" class=\"headerlink\" title=\"实现步骤：\"></a><strong>实现步骤：</strong></h3><p><strong>首先要安装Pyinstaller包，在命令行窗口使用pip指令就可以完成：</strong><br><code>pip install pyinstaller</code><br><strong>安装成功后就可以进行打包了</strong><br><strong>首先在命令行进入要打包的python程序的目录下面</strong><br><strong>接着使用</strong>   <code>pyinstaller file.py</code>   <strong>就可以打包了(file.py是指你要打包的python文件)</strong><br><strong>这个指令也可以附带其他属性：</strong></p>\n<pre><code class=\"text\">-F  表示生成单个可执行文件\n-D  创建一个目录，包含exe文件和依赖很多文件（默认选项）\n-w  表示去掉控制台窗口，这样执行exe文件的时候不会出现窗口，但会在后台运行，用命令行还是可以看见执行情况的\n-c  使用控制台，无界面(默认)；\n-p  表示你自己自定义需要加载的类路径\n-i  表示可执行文件的图标。</code></pre>\n<p><strong>例如我要生成一个带图标的exe文件，没有其他依赖文件的，那么就是使用指令：</strong><br><code>pyinstaller -F -i image.ico file.py</code>   <strong>（image.ico表示图标的路径，file.py表示要打包的python文件）</strong><br><strong>打包后会生成dict文件夹和buid文件夹还有一个.spec文件，其中dict就是放置我们要的exe文件的文件夹，其他两个是生成exe文件的过程中的中间产物，可以删掉。</strong><br><strong>pyinstaller打包的时候会自动把其他依赖的包和其他python文件引入，所以不用担心调用的问题。</strong><br><strong>但是其他要使用到的文件并不会被添加进去，例如要使用的图片或者文档，所以要自己把文件添加到打包完的exe文件的目录下面相应的路径，否则会出现闪退或者文件执行失败。</strong><br><strong>另外就是，如果py文件的编码是utf8，但是文件里面又有中文的话，那么使用windows的命令行打包会出现编码错误。</strong><br><strong>解决的方法就是先使用chcp指令进入其他编码的命令行</strong></p>\n<p><strong>以下是几种常用的编码:</strong></p>\n<pre><code class=\"text\">GBK(一般情况下为默认编码) 936\n美国英语 437\nutf-8 65001</code></pre>\n<p><strong>在这里我们要使用utf-8的编码，所以使用命令:</strong><br><code>chcp 65001</code><br><strong>设置编码后再进行打包就不会出现编码错误的情况了</strong></p>\n<p><strong>最后就是，第一次打包出来的程序经常会出现各种问题，建议在命令行执行exe文件，这样可以看到报错的内容，以便结合情况解决问题。</strong></p>\n"},{"title":"使用Hexo-NexT时遇到的问题","date":"2019-03-28T16:00:00.000Z","_content":"# 部署到github显示的网页和本地测试的网页不一样\n\n<font size=\"4\">\n之前设置了网页的背景图片还有側框的边角，同时添加了右上角的github跳转图标和阅读全文的设置。\n\n但是在在本地测试完，部署到github时，发现只有github图标和阅读全文的设置生效了，背景图片和边角设置没有体现出来。\n\n这是因为github部署的时候缓存加载比较慢，有时候要过一段时间才会显示出你想要的效果，用`hexo clean`清除一下public文件夹,再重新部署用`hexo g -d`部署一下，多刷新几次就行了。\n</font><br /> \n\n# 生成了空白的html文件\n\n\n第一次遇到这个问题的时候，我是直接重新搭建了这个博客的，毕竟一直不知道怎么解决，明明上一步操作还是没问题的，下一步页面突然就崩溃了。\n\n后来这个博客又遇到了一次，好在我找到了解决方法：\n\n如果找不到index.html文件（在生成的public文件夹里面）的话，要先用`npm ls --depth 0`检查一下插件情况,如果插件缺失了deploy和generator这两个插件的话就要用`npm install`重新安装插件。\n\n**如果是有html文件，但文件是空白的。那么你就要检查你刚刚修改的配置了，如果你修改一个文件里某一个配置下的某一项，但那一个配置忘记打开的话就会导致这样的情况。** \n\n例如我在主题配置文件里的友情链接links下增加了网易云音乐这一个选项，但是links前面原先有一个#号，我没有删除打开的话，生成的index.html文件就是空白的。\n\n而我就是遇到了这种情况，当时不知道是修改了哪一个配置，忘记把#号删了，结果就没有成功生成页面，发现了之后把#号删了就恢复正常了。\n\n\n# hexo语句发生错误 Template render error: (unknown path)\n\n\n在我写完另外一篇文章后，打算测试一下，发现无论是hexo g还是hexo s都会报错，于是移除了那篇文章，重新尝试了一下发现可以了。\n在网上看到似乎不能用}}这样的符号，我回去看那篇文章时发现我有一个}误删了，这才的导致解析不通过。\n结合之前生成空白html的经历，我发现只要文件里面有一点语法错误都会出现很大问题，如果某次操作突然出错了，记得去检查你最近的修改和文章有没有语法错误。\n\n\n# 左下角多了一个undefined\n\n\n最新版本的看板娘，在layout/_layout.swig的`</body>`前加上{ { live2d() } }，会产生一个默认的看板娘。\n如果在_config.yml文件中只设置一个，这就会产生冲突，导致有一个无法定义，所以会在页面多出一个undefined语句。\n在最新版本要把`</body>`前的{ { live2d() } }删除，这样才不会出错。\n\n\n# 文件过大push不了\n\n更新404页面的时候，我这404里面插入了一个视频，然后在上传的时候发现github不支持超过100M的文件，所以我把视频删了，重新部署一遍博客。\n但每次部署都会继续上传我删掉的那个视频，为什么呢？\n我已经把404文件夹里面的视频删了，也把public文件夹里面的视频删了，我还检查了一遍.deploy_git下面的文件夹，都没发现那个视频了。\n上网重新查了一下hexo的部署方式才知道，执行hexo d，就会把这个public文件夹的东西完完整整拷贝到.deploy_git文件夹里。\n想起了之前部署失败，应该是.deploy_git文件夹里面还保留了之前没push的信息，才会导致现在也部署不了。\n解决方法就是执行`hexo cl`清除一下缓存，或者直接把.deploy_git文件夹删了，\n这样重新部署就没问题了。\n顺便一提，其实那个视频我还是插进去了，只不过用了另外一种方法...\n","source":"_posts/使用Hexo-NexT时遇到的问题.md","raw":"---\ntitle: 使用Hexo-NexT时遇到的问题\ndate: 2019-3-29\ncategories: 开发记录\ntags:\n    -博客\n---\n# 部署到github显示的网页和本地测试的网页不一样\n\n<font size=\"4\">\n之前设置了网页的背景图片还有側框的边角，同时添加了右上角的github跳转图标和阅读全文的设置。\n\n但是在在本地测试完，部署到github时，发现只有github图标和阅读全文的设置生效了，背景图片和边角设置没有体现出来。\n\n这是因为github部署的时候缓存加载比较慢，有时候要过一段时间才会显示出你想要的效果，用`hexo clean`清除一下public文件夹,再重新部署用`hexo g -d`部署一下，多刷新几次就行了。\n</font><br /> \n\n# 生成了空白的html文件\n\n\n第一次遇到这个问题的时候，我是直接重新搭建了这个博客的，毕竟一直不知道怎么解决，明明上一步操作还是没问题的，下一步页面突然就崩溃了。\n\n后来这个博客又遇到了一次，好在我找到了解决方法：\n\n如果找不到index.html文件（在生成的public文件夹里面）的话，要先用`npm ls --depth 0`检查一下插件情况,如果插件缺失了deploy和generator这两个插件的话就要用`npm install`重新安装插件。\n\n**如果是有html文件，但文件是空白的。那么你就要检查你刚刚修改的配置了，如果你修改一个文件里某一个配置下的某一项，但那一个配置忘记打开的话就会导致这样的情况。** \n\n例如我在主题配置文件里的友情链接links下增加了网易云音乐这一个选项，但是links前面原先有一个#号，我没有删除打开的话，生成的index.html文件就是空白的。\n\n而我就是遇到了这种情况，当时不知道是修改了哪一个配置，忘记把#号删了，结果就没有成功生成页面，发现了之后把#号删了就恢复正常了。\n\n\n# hexo语句发生错误 Template render error: (unknown path)\n\n\n在我写完另外一篇文章后，打算测试一下，发现无论是hexo g还是hexo s都会报错，于是移除了那篇文章，重新尝试了一下发现可以了。\n在网上看到似乎不能用}}这样的符号，我回去看那篇文章时发现我有一个}误删了，这才的导致解析不通过。\n结合之前生成空白html的经历，我发现只要文件里面有一点语法错误都会出现很大问题，如果某次操作突然出错了，记得去检查你最近的修改和文章有没有语法错误。\n\n\n# 左下角多了一个undefined\n\n\n最新版本的看板娘，在layout/_layout.swig的`</body>`前加上{ { live2d() } }，会产生一个默认的看板娘。\n如果在_config.yml文件中只设置一个，这就会产生冲突，导致有一个无法定义，所以会在页面多出一个undefined语句。\n在最新版本要把`</body>`前的{ { live2d() } }删除，这样才不会出错。\n\n\n# 文件过大push不了\n\n更新404页面的时候，我这404里面插入了一个视频，然后在上传的时候发现github不支持超过100M的文件，所以我把视频删了，重新部署一遍博客。\n但每次部署都会继续上传我删掉的那个视频，为什么呢？\n我已经把404文件夹里面的视频删了，也把public文件夹里面的视频删了，我还检查了一遍.deploy_git下面的文件夹，都没发现那个视频了。\n上网重新查了一下hexo的部署方式才知道，执行hexo d，就会把这个public文件夹的东西完完整整拷贝到.deploy_git文件夹里。\n想起了之前部署失败，应该是.deploy_git文件夹里面还保留了之前没push的信息，才会导致现在也部署不了。\n解决方法就是执行`hexo cl`清除一下缓存，或者直接把.deploy_git文件夹删了，\n这样重新部署就没问题了。\n顺便一提，其实那个视频我还是插进去了，只不过用了另外一种方法...\n","slug":"使用Hexo-NexT时遇到的问题","published":1,"updated":"2020-01-23T07:17:23.963Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5qvznmn0002gcv59ha799s1","content":"<h1 id=\"部署到github显示的网页和本地测试的网页不一样\"><a href=\"#部署到github显示的网页和本地测试的网页不一样\" class=\"headerlink\" title=\"部署到github显示的网页和本地测试的网页不一样\"></a>部署到github显示的网页和本地测试的网页不一样</h1><font size=\"4\">\n之前设置了网页的背景图片还有側框的边角，同时添加了右上角的github跳转图标和阅读全文的设置。\n\n<p>但是在在本地测试完，部署到github时，发现只有github图标和阅读全文的设置生效了，背景图片和边角设置没有体现出来。</p>\n<p>这是因为github部署的时候缓存加载比较慢，有时候要过一段时间才会显示出你想要的效果，用<code>hexo clean</code>清除一下public文件夹,再重新部署用<code>hexo g -d</code>部署一下，多刷新几次就行了。<br></font><br /> </p>\n<h1 id=\"生成了空白的html文件\"><a href=\"#生成了空白的html文件\" class=\"headerlink\" title=\"生成了空白的html文件\"></a>生成了空白的html文件</h1><p>第一次遇到这个问题的时候，我是直接重新搭建了这个博客的，毕竟一直不知道怎么解决，明明上一步操作还是没问题的，下一步页面突然就崩溃了。</p>\n<p>后来这个博客又遇到了一次，好在我找到了解决方法：</p>\n<p>如果找不到index.html文件（在生成的public文件夹里面）的话，要先用<code>npm ls --depth 0</code>检查一下插件情况,如果插件缺失了deploy和generator这两个插件的话就要用<code>npm install</code>重新安装插件。</p>\n<p><strong>如果是有html文件，但文件是空白的。那么你就要检查你刚刚修改的配置了，如果你修改一个文件里某一个配置下的某一项，但那一个配置忘记打开的话就会导致这样的情况。</strong> </p>\n<p>例如我在主题配置文件里的友情链接links下增加了网易云音乐这一个选项，但是links前面原先有一个#号，我没有删除打开的话，生成的index.html文件就是空白的。</p>\n<p>而我就是遇到了这种情况，当时不知道是修改了哪一个配置，忘记把#号删了，结果就没有成功生成页面，发现了之后把#号删了就恢复正常了。</p>\n<h1 id=\"hexo语句发生错误-Template-render-error-unknown-path\"><a href=\"#hexo语句发生错误-Template-render-error-unknown-path\" class=\"headerlink\" title=\"hexo语句发生错误 Template render error: (unknown path)\"></a>hexo语句发生错误 Template render error: (unknown path)</h1><p>在我写完另外一篇文章后，打算测试一下，发现无论是hexo g还是hexo s都会报错，于是移除了那篇文章，重新尝试了一下发现可以了。<br>在网上看到似乎不能用}}这样的符号，我回去看那篇文章时发现我有一个}误删了，这才的导致解析不通过。<br>结合之前生成空白html的经历，我发现只要文件里面有一点语法错误都会出现很大问题，如果某次操作突然出错了，记得去检查你最近的修改和文章有没有语法错误。</p>\n<h1 id=\"左下角多了一个undefined\"><a href=\"#左下角多了一个undefined\" class=\"headerlink\" title=\"左下角多了一个undefined\"></a>左下角多了一个undefined</h1><p>最新版本的看板娘，在layout/_layout.swig的<code>&lt;/body&gt;</code>前加上{ { live2d() } }，会产生一个默认的看板娘。<br>如果在_config.yml文件中只设置一个，这就会产生冲突，导致有一个无法定义，所以会在页面多出一个undefined语句。<br>在最新版本要把<code>&lt;/body&gt;</code>前的{ { live2d() } }删除，这样才不会出错。</p>\n<h1 id=\"文件过大push不了\"><a href=\"#文件过大push不了\" class=\"headerlink\" title=\"文件过大push不了\"></a>文件过大push不了</h1><p>更新404页面的时候，我这404里面插入了一个视频，然后在上传的时候发现github不支持超过100M的文件，所以我把视频删了，重新部署一遍博客。<br>但每次部署都会继续上传我删掉的那个视频，为什么呢？<br>我已经把404文件夹里面的视频删了，也把public文件夹里面的视频删了，我还检查了一遍.deploy_git下面的文件夹，都没发现那个视频了。<br>上网重新查了一下hexo的部署方式才知道，执行hexo d，就会把这个public文件夹的东西完完整整拷贝到.deploy_git文件夹里。<br>想起了之前部署失败，应该是.deploy_git文件夹里面还保留了之前没push的信息，才会导致现在也部署不了。<br>解决方法就是执行<code>hexo cl</code>清除一下缓存，或者直接把.deploy_git文件夹删了，<br>这样重新部署就没问题了。<br>顺便一提，其实那个视频我还是插进去了，只不过用了另外一种方法…</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"部署到github显示的网页和本地测试的网页不一样\"><a href=\"#部署到github显示的网页和本地测试的网页不一样\" class=\"headerlink\" title=\"部署到github显示的网页和本地测试的网页不一样\"></a>部署到github显示的网页和本地测试的网页不一样</h1><font size=\"4\">\n之前设置了网页的背景图片还有側框的边角，同时添加了右上角的github跳转图标和阅读全文的设置。\n\n<p>但是在在本地测试完，部署到github时，发现只有github图标和阅读全文的设置生效了，背景图片和边角设置没有体现出来。</p>\n<p>这是因为github部署的时候缓存加载比较慢，有时候要过一段时间才会显示出你想要的效果，用<code>hexo clean</code>清除一下public文件夹,再重新部署用<code>hexo g -d</code>部署一下，多刷新几次就行了。<br></font><br /> </p>\n<h1 id=\"生成了空白的html文件\"><a href=\"#生成了空白的html文件\" class=\"headerlink\" title=\"生成了空白的html文件\"></a>生成了空白的html文件</h1><p>第一次遇到这个问题的时候，我是直接重新搭建了这个博客的，毕竟一直不知道怎么解决，明明上一步操作还是没问题的，下一步页面突然就崩溃了。</p>\n<p>后来这个博客又遇到了一次，好在我找到了解决方法：</p>\n<p>如果找不到index.html文件（在生成的public文件夹里面）的话，要先用<code>npm ls --depth 0</code>检查一下插件情况,如果插件缺失了deploy和generator这两个插件的话就要用<code>npm install</code>重新安装插件。</p>\n<p><strong>如果是有html文件，但文件是空白的。那么你就要检查你刚刚修改的配置了，如果你修改一个文件里某一个配置下的某一项，但那一个配置忘记打开的话就会导致这样的情况。</strong> </p>\n<p>例如我在主题配置文件里的友情链接links下增加了网易云音乐这一个选项，但是links前面原先有一个#号，我没有删除打开的话，生成的index.html文件就是空白的。</p>\n<p>而我就是遇到了这种情况，当时不知道是修改了哪一个配置，忘记把#号删了，结果就没有成功生成页面，发现了之后把#号删了就恢复正常了。</p>\n<h1 id=\"hexo语句发生错误-Template-render-error-unknown-path\"><a href=\"#hexo语句发生错误-Template-render-error-unknown-path\" class=\"headerlink\" title=\"hexo语句发生错误 Template render error: (unknown path)\"></a>hexo语句发生错误 Template render error: (unknown path)</h1><p>在我写完另外一篇文章后，打算测试一下，发现无论是hexo g还是hexo s都会报错，于是移除了那篇文章，重新尝试了一下发现可以了。<br>在网上看到似乎不能用}}这样的符号，我回去看那篇文章时发现我有一个}误删了，这才的导致解析不通过。<br>结合之前生成空白html的经历，我发现只要文件里面有一点语法错误都会出现很大问题，如果某次操作突然出错了，记得去检查你最近的修改和文章有没有语法错误。</p>\n<h1 id=\"左下角多了一个undefined\"><a href=\"#左下角多了一个undefined\" class=\"headerlink\" title=\"左下角多了一个undefined\"></a>左下角多了一个undefined</h1><p>最新版本的看板娘，在layout/_layout.swig的<code>&lt;/body&gt;</code>前加上{ { live2d() } }，会产生一个默认的看板娘。<br>如果在_config.yml文件中只设置一个，这就会产生冲突，导致有一个无法定义，所以会在页面多出一个undefined语句。<br>在最新版本要把<code>&lt;/body&gt;</code>前的{ { live2d() } }删除，这样才不会出错。</p>\n<h1 id=\"文件过大push不了\"><a href=\"#文件过大push不了\" class=\"headerlink\" title=\"文件过大push不了\"></a>文件过大push不了</h1><p>更新404页面的时候，我这404里面插入了一个视频，然后在上传的时候发现github不支持超过100M的文件，所以我把视频删了，重新部署一遍博客。<br>但每次部署都会继续上传我删掉的那个视频，为什么呢？<br>我已经把404文件夹里面的视频删了，也把public文件夹里面的视频删了，我还检查了一遍.deploy_git下面的文件夹，都没发现那个视频了。<br>上网重新查了一下hexo的部署方式才知道，执行hexo d，就会把这个public文件夹的东西完完整整拷贝到.deploy_git文件夹里。<br>想起了之前部署失败，应该是.deploy_git文件夹里面还保留了之前没push的信息，才会导致现在也部署不了。<br>解决方法就是执行<code>hexo cl</code>清除一下缓存，或者直接把.deploy_git文件夹删了，<br>这样重新部署就没问题了。<br>顺便一提，其实那个视频我还是插进去了，只不过用了另外一种方法…</p>\n"},{"title":"机器学习资源分享","date":"2019-04-03T16:00:00.000Z","_content":"<div align=\"center\">\n\n**我只想说虽然很有兴趣，但是学习深度学习感觉有点难！！！**\n**在这里和大家分享点学习资源，希望能给学习机器学习、深度学习的小伙伴帮助。**\n\n**B站机器学习视频：**\n    **上交ACM机器学习：https://www.bilibili.com/video/av58580135**\n    **吴恩达（Ng）机器学习：https://www.bilibili.com/video/av9912938**\n    **斯坦福 CS224n 自然语言处理：https://www.bilibili.com/video/av46216519**\n\n\n**ApacheCN学习组织：https://github.com/apachecn/AiLearning**\n**斯坦福 CS224n 自然语言处理中文笔记：https://github.com/apachecn/stanford-cs224n-notes-zh**\n\n**知乎卷积神经网络讲解：https://zhuanlan.zhihu.com/c_141391545**\n\n**神经网络&CNN论文（需要翻墙）：http://cs231n.github.io/**\n**深度学习论文网站 ：https://paperswithcode.com/task/video-classification#code**\n\n**一个有点好玩、能帮助理解的数学可视化视频：**\n    **深度学习（Deep Learning）：https://space.bilibili.com/88461692/channel/detail?cid=26587**\n    **微积分：https://space.bilibili.com/88461692/channel/detail?cid=13407**\n    **在B站的全部视频：https://space.bilibili.com/88461692?spm_id_from=333.788.b_765f7570696e666f.1**\n\n</div>","source":"_posts/机器学习资源分享.md","raw":"---\ntitle: 机器学习资源分享\ndate: 2019-4-4\ncategories: 学习笔记\ntags:\n    -深度学习\n    -神经网络\n---\n<div align=\"center\">\n\n**我只想说虽然很有兴趣，但是学习深度学习感觉有点难！！！**\n**在这里和大家分享点学习资源，希望能给学习机器学习、深度学习的小伙伴帮助。**\n\n**B站机器学习视频：**\n    **上交ACM机器学习：https://www.bilibili.com/video/av58580135**\n    **吴恩达（Ng）机器学习：https://www.bilibili.com/video/av9912938**\n    **斯坦福 CS224n 自然语言处理：https://www.bilibili.com/video/av46216519**\n\n\n**ApacheCN学习组织：https://github.com/apachecn/AiLearning**\n**斯坦福 CS224n 自然语言处理中文笔记：https://github.com/apachecn/stanford-cs224n-notes-zh**\n\n**知乎卷积神经网络讲解：https://zhuanlan.zhihu.com/c_141391545**\n\n**神经网络&CNN论文（需要翻墙）：http://cs231n.github.io/**\n**深度学习论文网站 ：https://paperswithcode.com/task/video-classification#code**\n\n**一个有点好玩、能帮助理解的数学可视化视频：**\n    **深度学习（Deep Learning）：https://space.bilibili.com/88461692/channel/detail?cid=26587**\n    **微积分：https://space.bilibili.com/88461692/channel/detail?cid=13407**\n    **在B站的全部视频：https://space.bilibili.com/88461692?spm_id_from=333.788.b_765f7570696e666f.1**\n\n</div>","slug":"机器学习资源分享","published":1,"updated":"2020-01-23T07:18:31.281Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5qvznmz0006gcv55dr166zl","content":"<div align=\"center\">\n\n<p><strong>我只想说虽然很有兴趣，但是学习深度学习感觉有点难！！！</strong><br><strong>在这里和大家分享点学习资源，希望能给学习机器学习、深度学习的小伙伴帮助。</strong></p>\n<p><strong>B站机器学习视频：</strong><br>    <strong>上交ACM机器学习：<a href=\"https://www.bilibili.com/video/av58580135\" target=\"_blank\" rel=\"noopener\">https://www.bilibili.com/video/av58580135</a></strong><br>    <strong>吴恩达（Ng）机器学习：<a href=\"https://www.bilibili.com/video/av9912938\" target=\"_blank\" rel=\"noopener\">https://www.bilibili.com/video/av9912938</a></strong><br>    <strong>斯坦福 CS224n 自然语言处理：<a href=\"https://www.bilibili.com/video/av46216519\" target=\"_blank\" rel=\"noopener\">https://www.bilibili.com/video/av46216519</a></strong></p>\n<p><strong>ApacheCN学习组织：<a href=\"https://github.com/apachecn/AiLearning\" target=\"_blank\" rel=\"noopener\">https://github.com/apachecn/AiLearning</a></strong><br><strong>斯坦福 CS224n 自然语言处理中文笔记：<a href=\"https://github.com/apachecn/stanford-cs224n-notes-zh\" target=\"_blank\" rel=\"noopener\">https://github.com/apachecn/stanford-cs224n-notes-zh</a></strong></p>\n<p><strong>知乎卷积神经网络讲解：<a href=\"https://zhuanlan.zhihu.com/c_141391545\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/c_141391545</a></strong></p>\n<p><strong>神经网络&amp;CNN论文（需要翻墙）：<a href=\"http://cs231n.github.io/\" target=\"_blank\" rel=\"noopener\">http://cs231n.github.io/</a></strong><br><strong>深度学习论文网站 ：<a href=\"https://paperswithcode.com/task/video-classification#code\" target=\"_blank\" rel=\"noopener\">https://paperswithcode.com/task/video-classification#code</a></strong></p>\n<p><strong>一个有点好玩、能帮助理解的数学可视化视频：</strong><br>    <strong>深度学习（Deep Learning）：<a href=\"https://space.bilibili.com/88461692/channel/detail?cid=26587\" target=\"_blank\" rel=\"noopener\">https://space.bilibili.com/88461692/channel/detail?cid=26587</a></strong><br>    <strong>微积分：<a href=\"https://space.bilibili.com/88461692/channel/detail?cid=13407\" target=\"_blank\" rel=\"noopener\">https://space.bilibili.com/88461692/channel/detail?cid=13407</a></strong><br>    <strong>在B站的全部视频：<a href=\"https://space.bilibili.com/88461692?spm_id_from=333.788.b_765f7570696e666f.1\" target=\"_blank\" rel=\"noopener\">https://space.bilibili.com/88461692?spm_id_from=333.788.b_765f7570696e666f.1</a></strong></p>\n</div>","site":{"data":{}},"excerpt":"","more":"<div align=\"center\">\n\n<p><strong>我只想说虽然很有兴趣，但是学习深度学习感觉有点难！！！</strong><br><strong>在这里和大家分享点学习资源，希望能给学习机器学习、深度学习的小伙伴帮助。</strong></p>\n<p><strong>B站机器学习视频：</strong><br>    <strong>上交ACM机器学习：<a href=\"https://www.bilibili.com/video/av58580135\" target=\"_blank\" rel=\"noopener\">https://www.bilibili.com/video/av58580135</a></strong><br>    <strong>吴恩达（Ng）机器学习：<a href=\"https://www.bilibili.com/video/av9912938\" target=\"_blank\" rel=\"noopener\">https://www.bilibili.com/video/av9912938</a></strong><br>    <strong>斯坦福 CS224n 自然语言处理：<a href=\"https://www.bilibili.com/video/av46216519\" target=\"_blank\" rel=\"noopener\">https://www.bilibili.com/video/av46216519</a></strong></p>\n<p><strong>ApacheCN学习组织：<a href=\"https://github.com/apachecn/AiLearning\" target=\"_blank\" rel=\"noopener\">https://github.com/apachecn/AiLearning</a></strong><br><strong>斯坦福 CS224n 自然语言处理中文笔记：<a href=\"https://github.com/apachecn/stanford-cs224n-notes-zh\" target=\"_blank\" rel=\"noopener\">https://github.com/apachecn/stanford-cs224n-notes-zh</a></strong></p>\n<p><strong>知乎卷积神经网络讲解：<a href=\"https://zhuanlan.zhihu.com/c_141391545\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/c_141391545</a></strong></p>\n<p><strong>神经网络&amp;CNN论文（需要翻墙）：<a href=\"http://cs231n.github.io/\" target=\"_blank\" rel=\"noopener\">http://cs231n.github.io/</a></strong><br><strong>深度学习论文网站 ：<a href=\"https://paperswithcode.com/task/video-classification#code\" target=\"_blank\" rel=\"noopener\">https://paperswithcode.com/task/video-classification#code</a></strong></p>\n<p><strong>一个有点好玩、能帮助理解的数学可视化视频：</strong><br>    <strong>深度学习（Deep Learning）：<a href=\"https://space.bilibili.com/88461692/channel/detail?cid=26587\" target=\"_blank\" rel=\"noopener\">https://space.bilibili.com/88461692/channel/detail?cid=26587</a></strong><br>    <strong>微积分：<a href=\"https://space.bilibili.com/88461692/channel/detail?cid=13407\" target=\"_blank\" rel=\"noopener\">https://space.bilibili.com/88461692/channel/detail?cid=13407</a></strong><br>    <strong>在B站的全部视频：<a href=\"https://space.bilibili.com/88461692?spm_id_from=333.788.b_765f7570696e666f.1\" target=\"_blank\" rel=\"noopener\">https://space.bilibili.com/88461692?spm_id_from=333.788.b_765f7570696e666f.1</a></strong></p>\n</div>"},{"title":"强类型与动态类型的Python","date":"2019-11-09T16:00:00.000Z","_content":"\n**很多人都会说到Python是一门强类型、动态类型的语言，为什么这么说呢？**\n\n我们先来看一下什么是强类型的语言\n**百度答案：强类型指的是程序中表达的任何对象所从属的类型都必须能在编译时刻确定。**\n什么意思呢？\n就是说，在编译的时候，变量的类型就可以被编译器确定，并且运行时该变量不经过强制转换将类型无法发生改变。\n例如我在Python里面定义了两个不同类型的变量，然后对这两个变量进行以下操作\n\n```Python\na = 1\nb = \"b\"\na + b\n```\n\n就会报如下的类型错误(TypeError)\n\n![TypeError](/images/Python特性/TypeError1.png)\n\n因为a和b是两个不同类型的变量，在不可以进行赋值操作，但是在C语言里面是可以的，因为会进行隐式转换，而在Python里面不会进行类型隐式转换。\n对于Python来说，变量不通过int()或str()等方法进行转换的话，那么该变量的类型将无法发生改变\n**根据百度提供的信息可以了解到：强类型是针对类型检查的严格程度而言的，它指任何变量在使用的时候必须要指定这个变量的类型，而且在程序的运行过程中这个变量只能存储这个类型的数据。**\n\n但是我们在用Python的时候就会知道，我们是可以给变量赋其它类型的值的，例如我们可以这样写\n\n```Python\na = 1\na = False\nb = \"b\"\na = b\n```\n\n这不是和强类型的定义发生冲突了吗？\n其实这涉及到我们要讲的另外一个问题，**动态类型**。\n\n为什么说Python是动态类型呢？\n\n因为Python的变量并不是指定了类型的，Python的变量在进行赋值的时候，是指向了对象的地址，在进行重新赋值的时候，Python变量并不关心值的类型，因为它只是改变了地址的指向。这种赋值方式报错导致的类型错误，都是在运行的时候才会发生，包括上面举的例子的。\n\n**在编译的时候不对变量类型进行识别，在运行的时候可以改变其结构的语言，我们称为动态语言。**\n\n因为Python的这个特性，所以可以抛开强类型语言对于赋值时类型的要求，但是在运行时会对变量指向地址的值的类型进行判别。\n这就是Python既是动态类型语言，也是强类型语言的原因。\n\n对于Python这种动态指向，在编写程序的时候，给我们带来了很多方便，但是稍不注意，也会让程序发生一些难以察觉的错误。\n例如我们对列表操作的时候\n\n![dynamic](/images/Python特性/dynamic1.png)\n\n当Python将一个列表赋给变量a，此时a并不等于[1,2,3]，而是指向了这个列表的地址。\n将a的值赋给b的时候，相当于将b的指向修改成a的指向，也就是b也是指向这个列表的地址。当你对b进行操作的时候，就是在对这个地址的值进行操作，所以a的值也会发生改变，当程序在递归或者用树遍历的时候，如果这样进行列表的赋值，将会导致重大的错误。\n为了避免这种情况，Python也提供了一些方法给我们进行赋值使用，当我们希望将a和b不是指向同一个列表，但两个列表的值又要一样的时候，我们可以用list的copy()方法来对列表进行复制。这种情况下我们是复制出了一个新的列表赋给了b，所以对b操作的时候不会改变a的值。\n另外一种方法就是直接对整个列表进行截取：\n当我们使用a[x:y]时，可以截取到a中下标x到下标y的片段；\n当x或y的参数放空时，表示从头开始截取或者截取到尾；\n例：a[:y]就是截取下标0~y的片段，a[x:]就是从x开始截取到列表结束；\n而a[:]就是从头截取到最后一个元素，也就是整个列表都截取下来。\n\n![dynamic](/images/Python特性/dynamic2.png)\n\n或者是对多维列表的子列表进行修改\n\n![dynamic](/images/Python特性/dynamic3.png)\n\n**但是这两个方法对于多维列表操作单个元素来说，都不起作用！**\n\n![dynamic](/images/Python特性/dynamic4.png)\n\n**原因是：列表里面保存的元素，也是地址的指向！**\n当对多维列表的下一级列表进行操作的时候，是让该下标指向了另一个列表的地址，但是对该子列表的元素进行修改时，是修改子列表的元素的指向。\n\n附上图可能会更容易理解一点：\n![dynamic](/images/Python特性/introduce.png)\n\n例如：\n我将a复制给了b，虽然生成的是新列表，但是列表里面元素指向的地址是相同的，当我修改b[0]的时候，相当于是把b[0]指向了其它列表，此时a并不会收到影响。\n但是如果我修改的是b[1][1],此时我修改的是b[1]指向的列表下标为1的元素，但是a[1]和b[1]指向的是同一列表，相当于也是在修改a[1]的元素。\n\n这种情况下，也有应对的方法，我用的是for循环来进行重复制\n\n```Python\na = [[1,1,1],[1,1,1],[1,1,1]]\nb = []\nfor data in a:\n    b.append(data.copy())\n```\n\n但是这种办法对于对于n维列表，需要内嵌的for循环为n-1个，如果是维度高的列表，就不是很切实际了。\n如果大佬们有更好的方法，还请在评论区留言^_^\n\n掘金地址：<https://juejin.im/post/5dc7a58b51882521f62cc3c2>\n知乎地址：<https://zhuanlan.zhihu.com/p/91117079>\n","source":"_posts/强类型与动态类型的Python.md","raw":"---\ntitle: 强类型与动态类型的Python\ndate: 2019-11-10\ncategories: 技术文章\ntags:\n    -Python\n---\n\n**很多人都会说到Python是一门强类型、动态类型的语言，为什么这么说呢？**\n\n我们先来看一下什么是强类型的语言\n**百度答案：强类型指的是程序中表达的任何对象所从属的类型都必须能在编译时刻确定。**\n什么意思呢？\n就是说，在编译的时候，变量的类型就可以被编译器确定，并且运行时该变量不经过强制转换将类型无法发生改变。\n例如我在Python里面定义了两个不同类型的变量，然后对这两个变量进行以下操作\n\n```Python\na = 1\nb = \"b\"\na + b\n```\n\n就会报如下的类型错误(TypeError)\n\n![TypeError](/images/Python特性/TypeError1.png)\n\n因为a和b是两个不同类型的变量，在不可以进行赋值操作，但是在C语言里面是可以的，因为会进行隐式转换，而在Python里面不会进行类型隐式转换。\n对于Python来说，变量不通过int()或str()等方法进行转换的话，那么该变量的类型将无法发生改变\n**根据百度提供的信息可以了解到：强类型是针对类型检查的严格程度而言的，它指任何变量在使用的时候必须要指定这个变量的类型，而且在程序的运行过程中这个变量只能存储这个类型的数据。**\n\n但是我们在用Python的时候就会知道，我们是可以给变量赋其它类型的值的，例如我们可以这样写\n\n```Python\na = 1\na = False\nb = \"b\"\na = b\n```\n\n这不是和强类型的定义发生冲突了吗？\n其实这涉及到我们要讲的另外一个问题，**动态类型**。\n\n为什么说Python是动态类型呢？\n\n因为Python的变量并不是指定了类型的，Python的变量在进行赋值的时候，是指向了对象的地址，在进行重新赋值的时候，Python变量并不关心值的类型，因为它只是改变了地址的指向。这种赋值方式报错导致的类型错误，都是在运行的时候才会发生，包括上面举的例子的。\n\n**在编译的时候不对变量类型进行识别，在运行的时候可以改变其结构的语言，我们称为动态语言。**\n\n因为Python的这个特性，所以可以抛开强类型语言对于赋值时类型的要求，但是在运行时会对变量指向地址的值的类型进行判别。\n这就是Python既是动态类型语言，也是强类型语言的原因。\n\n对于Python这种动态指向，在编写程序的时候，给我们带来了很多方便，但是稍不注意，也会让程序发生一些难以察觉的错误。\n例如我们对列表操作的时候\n\n![dynamic](/images/Python特性/dynamic1.png)\n\n当Python将一个列表赋给变量a，此时a并不等于[1,2,3]，而是指向了这个列表的地址。\n将a的值赋给b的时候，相当于将b的指向修改成a的指向，也就是b也是指向这个列表的地址。当你对b进行操作的时候，就是在对这个地址的值进行操作，所以a的值也会发生改变，当程序在递归或者用树遍历的时候，如果这样进行列表的赋值，将会导致重大的错误。\n为了避免这种情况，Python也提供了一些方法给我们进行赋值使用，当我们希望将a和b不是指向同一个列表，但两个列表的值又要一样的时候，我们可以用list的copy()方法来对列表进行复制。这种情况下我们是复制出了一个新的列表赋给了b，所以对b操作的时候不会改变a的值。\n另外一种方法就是直接对整个列表进行截取：\n当我们使用a[x:y]时，可以截取到a中下标x到下标y的片段；\n当x或y的参数放空时，表示从头开始截取或者截取到尾；\n例：a[:y]就是截取下标0~y的片段，a[x:]就是从x开始截取到列表结束；\n而a[:]就是从头截取到最后一个元素，也就是整个列表都截取下来。\n\n![dynamic](/images/Python特性/dynamic2.png)\n\n或者是对多维列表的子列表进行修改\n\n![dynamic](/images/Python特性/dynamic3.png)\n\n**但是这两个方法对于多维列表操作单个元素来说，都不起作用！**\n\n![dynamic](/images/Python特性/dynamic4.png)\n\n**原因是：列表里面保存的元素，也是地址的指向！**\n当对多维列表的下一级列表进行操作的时候，是让该下标指向了另一个列表的地址，但是对该子列表的元素进行修改时，是修改子列表的元素的指向。\n\n附上图可能会更容易理解一点：\n![dynamic](/images/Python特性/introduce.png)\n\n例如：\n我将a复制给了b，虽然生成的是新列表，但是列表里面元素指向的地址是相同的，当我修改b[0]的时候，相当于是把b[0]指向了其它列表，此时a并不会收到影响。\n但是如果我修改的是b[1][1],此时我修改的是b[1]指向的列表下标为1的元素，但是a[1]和b[1]指向的是同一列表，相当于也是在修改a[1]的元素。\n\n这种情况下，也有应对的方法，我用的是for循环来进行重复制\n\n```Python\na = [[1,1,1],[1,1,1],[1,1,1]]\nb = []\nfor data in a:\n    b.append(data.copy())\n```\n\n但是这种办法对于对于n维列表，需要内嵌的for循环为n-1个，如果是维度高的列表，就不是很切实际了。\n如果大佬们有更好的方法，还请在评论区留言^_^\n\n掘金地址：<https://juejin.im/post/5dc7a58b51882521f62cc3c2>\n知乎地址：<https://zhuanlan.zhihu.com/p/91117079>\n","slug":"强类型与动态类型的Python","published":1,"updated":"2020-01-23T07:17:40.097Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5qvznn30007gcv5hlyu98u2","content":"<p><strong>很多人都会说到Python是一门强类型、动态类型的语言，为什么这么说呢？</strong></p>\n<p>我们先来看一下什么是强类型的语言<br><strong>百度答案：强类型指的是程序中表达的任何对象所从属的类型都必须能在编译时刻确定。</strong><br>什么意思呢？<br>就是说，在编译的时候，变量的类型就可以被编译器确定，并且运行时该变量不经过强制转换将类型无法发生改变。<br>例如我在Python里面定义了两个不同类型的变量，然后对这两个变量进行以下操作</p>\n<pre><code class=\"Python\">a = 1\nb = &quot;b&quot;\na + b</code></pre>\n<p>就会报如下的类型错误(TypeError)</p>\n<p><img src=\"/images/Python%E7%89%B9%E6%80%A7/TypeError1.png\" alt=\"TypeError\"></p>\n<p>因为a和b是两个不同类型的变量，在不可以进行赋值操作，但是在C语言里面是可以的，因为会进行隐式转换，而在Python里面不会进行类型隐式转换。<br>对于Python来说，变量不通过int()或str()等方法进行转换的话，那么该变量的类型将无法发生改变<br><strong>根据百度提供的信息可以了解到：强类型是针对类型检查的严格程度而言的，它指任何变量在使用的时候必须要指定这个变量的类型，而且在程序的运行过程中这个变量只能存储这个类型的数据。</strong></p>\n<p>但是我们在用Python的时候就会知道，我们是可以给变量赋其它类型的值的，例如我们可以这样写</p>\n<pre><code class=\"Python\">a = 1\na = False\nb = &quot;b&quot;\na = b</code></pre>\n<p>这不是和强类型的定义发生冲突了吗？<br>其实这涉及到我们要讲的另外一个问题，<strong>动态类型</strong>。</p>\n<p>为什么说Python是动态类型呢？</p>\n<p>因为Python的变量并不是指定了类型的，Python的变量在进行赋值的时候，是指向了对象的地址，在进行重新赋值的时候，Python变量并不关心值的类型，因为它只是改变了地址的指向。这种赋值方式报错导致的类型错误，都是在运行的时候才会发生，包括上面举的例子的。</p>\n<p><strong>在编译的时候不对变量类型进行识别，在运行的时候可以改变其结构的语言，我们称为动态语言。</strong></p>\n<p>因为Python的这个特性，所以可以抛开强类型语言对于赋值时类型的要求，但是在运行时会对变量指向地址的值的类型进行判别。<br>这就是Python既是动态类型语言，也是强类型语言的原因。</p>\n<p>对于Python这种动态指向，在编写程序的时候，给我们带来了很多方便，但是稍不注意，也会让程序发生一些难以察觉的错误。<br>例如我们对列表操作的时候</p>\n<p><img src=\"/images/Python%E7%89%B9%E6%80%A7/dynamic1.png\" alt=\"dynamic\"></p>\n<p>当Python将一个列表赋给变量a，此时a并不等于[1,2,3]，而是指向了这个列表的地址。<br>将a的值赋给b的时候，相当于将b的指向修改成a的指向，也就是b也是指向这个列表的地址。当你对b进行操作的时候，就是在对这个地址的值进行操作，所以a的值也会发生改变，当程序在递归或者用树遍历的时候，如果这样进行列表的赋值，将会导致重大的错误。<br>为了避免这种情况，Python也提供了一些方法给我们进行赋值使用，当我们希望将a和b不是指向同一个列表，但两个列表的值又要一样的时候，我们可以用list的copy()方法来对列表进行复制。这种情况下我们是复制出了一个新的列表赋给了b，所以对b操作的时候不会改变a的值。<br>另外一种方法就是直接对整个列表进行截取：<br>当我们使用a[x:y]时，可以截取到a中下标x到下标y的片段；<br>当x或y的参数放空时，表示从头开始截取或者截取到尾；<br>例：a[:y]就是截取下标0~y的片段，a[x:]就是从x开始截取到列表结束；<br>而a[:]就是从头截取到最后一个元素，也就是整个列表都截取下来。</p>\n<p><img src=\"/images/Python%E7%89%B9%E6%80%A7/dynamic2.png\" alt=\"dynamic\"></p>\n<p>或者是对多维列表的子列表进行修改</p>\n<p><img src=\"/images/Python%E7%89%B9%E6%80%A7/dynamic3.png\" alt=\"dynamic\"></p>\n<p><strong>但是这两个方法对于多维列表操作单个元素来说，都不起作用！</strong></p>\n<p><img src=\"/images/Python%E7%89%B9%E6%80%A7/dynamic4.png\" alt=\"dynamic\"></p>\n<p><strong>原因是：列表里面保存的元素，也是地址的指向！</strong><br>当对多维列表的下一级列表进行操作的时候，是让该下标指向了另一个列表的地址，但是对该子列表的元素进行修改时，是修改子列表的元素的指向。</p>\n<p>附上图可能会更容易理解一点：<br><img src=\"/images/Python%E7%89%B9%E6%80%A7/introduce.png\" alt=\"dynamic\"></p>\n<p>例如：<br>我将a复制给了b，虽然生成的是新列表，但是列表里面元素指向的地址是相同的，当我修改b[0]的时候，相当于是把b[0]指向了其它列表，此时a并不会收到影响。<br>但是如果我修改的是b[1][1],此时我修改的是b[1]指向的列表下标为1的元素，但是a[1]和b[1]指向的是同一列表，相当于也是在修改a[1]的元素。</p>\n<p>这种情况下，也有应对的方法，我用的是for循环来进行重复制</p>\n<pre><code class=\"Python\">a = [[1,1,1],[1,1,1],[1,1,1]]\nb = []\nfor data in a:\n    b.append(data.copy())</code></pre>\n<p>但是这种办法对于对于n维列表，需要内嵌的for循环为n-1个，如果是维度高的列表，就不是很切实际了。<br>如果大佬们有更好的方法，还请在评论区留言^_^</p>\n<p>掘金地址：<a href=\"https://juejin.im/post/5dc7a58b51882521f62cc3c2\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5dc7a58b51882521f62cc3c2</a><br>知乎地址：<a href=\"https://zhuanlan.zhihu.com/p/91117079\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/91117079</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>很多人都会说到Python是一门强类型、动态类型的语言，为什么这么说呢？</strong></p>\n<p>我们先来看一下什么是强类型的语言<br><strong>百度答案：强类型指的是程序中表达的任何对象所从属的类型都必须能在编译时刻确定。</strong><br>什么意思呢？<br>就是说，在编译的时候，变量的类型就可以被编译器确定，并且运行时该变量不经过强制转换将类型无法发生改变。<br>例如我在Python里面定义了两个不同类型的变量，然后对这两个变量进行以下操作</p>\n<pre><code class=\"Python\">a = 1\nb = &quot;b&quot;\na + b</code></pre>\n<p>就会报如下的类型错误(TypeError)</p>\n<p><img src=\"/images/Python%E7%89%B9%E6%80%A7/TypeError1.png\" alt=\"TypeError\"></p>\n<p>因为a和b是两个不同类型的变量，在不可以进行赋值操作，但是在C语言里面是可以的，因为会进行隐式转换，而在Python里面不会进行类型隐式转换。<br>对于Python来说，变量不通过int()或str()等方法进行转换的话，那么该变量的类型将无法发生改变<br><strong>根据百度提供的信息可以了解到：强类型是针对类型检查的严格程度而言的，它指任何变量在使用的时候必须要指定这个变量的类型，而且在程序的运行过程中这个变量只能存储这个类型的数据。</strong></p>\n<p>但是我们在用Python的时候就会知道，我们是可以给变量赋其它类型的值的，例如我们可以这样写</p>\n<pre><code class=\"Python\">a = 1\na = False\nb = &quot;b&quot;\na = b</code></pre>\n<p>这不是和强类型的定义发生冲突了吗？<br>其实这涉及到我们要讲的另外一个问题，<strong>动态类型</strong>。</p>\n<p>为什么说Python是动态类型呢？</p>\n<p>因为Python的变量并不是指定了类型的，Python的变量在进行赋值的时候，是指向了对象的地址，在进行重新赋值的时候，Python变量并不关心值的类型，因为它只是改变了地址的指向。这种赋值方式报错导致的类型错误，都是在运行的时候才会发生，包括上面举的例子的。</p>\n<p><strong>在编译的时候不对变量类型进行识别，在运行的时候可以改变其结构的语言，我们称为动态语言。</strong></p>\n<p>因为Python的这个特性，所以可以抛开强类型语言对于赋值时类型的要求，但是在运行时会对变量指向地址的值的类型进行判别。<br>这就是Python既是动态类型语言，也是强类型语言的原因。</p>\n<p>对于Python这种动态指向，在编写程序的时候，给我们带来了很多方便，但是稍不注意，也会让程序发生一些难以察觉的错误。<br>例如我们对列表操作的时候</p>\n<p><img src=\"/images/Python%E7%89%B9%E6%80%A7/dynamic1.png\" alt=\"dynamic\"></p>\n<p>当Python将一个列表赋给变量a，此时a并不等于[1,2,3]，而是指向了这个列表的地址。<br>将a的值赋给b的时候，相当于将b的指向修改成a的指向，也就是b也是指向这个列表的地址。当你对b进行操作的时候，就是在对这个地址的值进行操作，所以a的值也会发生改变，当程序在递归或者用树遍历的时候，如果这样进行列表的赋值，将会导致重大的错误。<br>为了避免这种情况，Python也提供了一些方法给我们进行赋值使用，当我们希望将a和b不是指向同一个列表，但两个列表的值又要一样的时候，我们可以用list的copy()方法来对列表进行复制。这种情况下我们是复制出了一个新的列表赋给了b，所以对b操作的时候不会改变a的值。<br>另外一种方法就是直接对整个列表进行截取：<br>当我们使用a[x:y]时，可以截取到a中下标x到下标y的片段；<br>当x或y的参数放空时，表示从头开始截取或者截取到尾；<br>例：a[:y]就是截取下标0~y的片段，a[x:]就是从x开始截取到列表结束；<br>而a[:]就是从头截取到最后一个元素，也就是整个列表都截取下来。</p>\n<p><img src=\"/images/Python%E7%89%B9%E6%80%A7/dynamic2.png\" alt=\"dynamic\"></p>\n<p>或者是对多维列表的子列表进行修改</p>\n<p><img src=\"/images/Python%E7%89%B9%E6%80%A7/dynamic3.png\" alt=\"dynamic\"></p>\n<p><strong>但是这两个方法对于多维列表操作单个元素来说，都不起作用！</strong></p>\n<p><img src=\"/images/Python%E7%89%B9%E6%80%A7/dynamic4.png\" alt=\"dynamic\"></p>\n<p><strong>原因是：列表里面保存的元素，也是地址的指向！</strong><br>当对多维列表的下一级列表进行操作的时候，是让该下标指向了另一个列表的地址，但是对该子列表的元素进行修改时，是修改子列表的元素的指向。</p>\n<p>附上图可能会更容易理解一点：<br><img src=\"/images/Python%E7%89%B9%E6%80%A7/introduce.png\" alt=\"dynamic\"></p>\n<p>例如：<br>我将a复制给了b，虽然生成的是新列表，但是列表里面元素指向的地址是相同的，当我修改b[0]的时候，相当于是把b[0]指向了其它列表，此时a并不会收到影响。<br>但是如果我修改的是b[1][1],此时我修改的是b[1]指向的列表下标为1的元素，但是a[1]和b[1]指向的是同一列表，相当于也是在修改a[1]的元素。</p>\n<p>这种情况下，也有应对的方法，我用的是for循环来进行重复制</p>\n<pre><code class=\"Python\">a = [[1,1,1],[1,1,1],[1,1,1]]\nb = []\nfor data in a:\n    b.append(data.copy())</code></pre>\n<p>但是这种办法对于对于n维列表，需要内嵌的for循环为n-1个，如果是维度高的列表，就不是很切实际了。<br>如果大佬们有更好的方法，还请在评论区留言^_^</p>\n<p>掘金地址：<a href=\"https://juejin.im/post/5dc7a58b51882521f62cc3c2\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5dc7a58b51882521f62cc3c2</a><br>知乎地址：<a href=\"https://zhuanlan.zhihu.com/p/91117079\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/91117079</a></p>\n"},{"title":"MySQL安装到登陆的问题","date":"2019-04-07T16:00:00.000Z","_content":"\n**经过一晚上的折腾，我终于登陆进数据库了！！这期间遇到了不少问题，虽然网上有很多解决方案，但要找到适用的真的不容易，每个问题都花了很长时间去尝试那些指令，绕了很多弯路才解决。**\n\n\n### 端口冲突\n**安装完遇到的第一个问题就是，没办法打开mysql服务，删了安装目录下的date文件夹重新用`mysqld --initialize`初始化，重新配置my.ini文件都没用。**\n**之后用`mysqld --console`查了错误信息发现了端口被占用了：**\n>**[ERROR] Can't start server: Bind on TCP/IP port: Address already in use**\n>**[ERROR] Do you already have another mysqld server running on port: 3306 ?**\n\n**因为我这边的命令行无法识别`netstat -nltp|grep mysql`，到后面才用`netstat  -aon|findstr 3306`查到了占用3306端口的进程，记住了进程后面的PID号，用`taskkil /f /pid 对应的PID号`把进程给杀了才解决问题**\n\n### 无法登陆\n**耗了一些时间后，我用`net start mysql`开启了数据库后，用`mysql -uroot -密码`尝试登陆，结果又报了一个这样的错误**\n>**mysql: [ERROR] mysql: unknown option '-R'.**\n\n**于是用`mysql -uroot -p`后再输入密码,才知道原先输入密码前也要加个p，也就是`mysql -uroot -p密码`。**\n**但是接下来又报了一个错误**\n>**mysql: [Warning] Using a password on the command line interface can be insecure.**\n>**ERROR 1045 (28000): Access denied for user 'root'@'localhost' (using password: YES)**\n\n**查了一下发现是密码错误，因为我输入的是安装时的密码，但是初始化的时候密码重置了，所以密码错了，所以我又绕了一次弯路，把date删了重新初始化了一遍，把初始化输出的临时密码记了下来**\n>**[Note] A temporary password is generated for root@localhost: TKk51x#bOi0S**\n**之后就可以成功登陆了**\n\n### 修改密码\n**登陆后没办法使用其他语句，说是必须修改一下密码，而且自动生成的密码太难记了，我想改回自己的密码，但是在网上查了很多指令都用不成功，错误提示的ALTER USER语句也不知道怎么用，所以又上网馊了一下，还看了一下官方文档，总结就是看不懂~~**\n**查到最后终于发现了一个可以用的语句**\n>`alter user 'root'@'localhost' identified by 'password';`\n\n**这下问题终于解决了，可以开始进一步学习了。**\n\n\n**虽然遇到了很多问题，但是也知道了很多MySQL和命令行的语句，有些没派上用场就是了，至少折腾了一夜一些有用的语句都变熟悉了。**\n","source":"_posts/MySQL安装到登陆的问题.md","raw":"---\ntitle: MySQL安装到登陆的问题\ndate: 2019-4-8\ncategories: 学习笔记\ntags:\n    -MySQL\n---\n\n**经过一晚上的折腾，我终于登陆进数据库了！！这期间遇到了不少问题，虽然网上有很多解决方案，但要找到适用的真的不容易，每个问题都花了很长时间去尝试那些指令，绕了很多弯路才解决。**\n\n\n### 端口冲突\n**安装完遇到的第一个问题就是，没办法打开mysql服务，删了安装目录下的date文件夹重新用`mysqld --initialize`初始化，重新配置my.ini文件都没用。**\n**之后用`mysqld --console`查了错误信息发现了端口被占用了：**\n>**[ERROR] Can't start server: Bind on TCP/IP port: Address already in use**\n>**[ERROR] Do you already have another mysqld server running on port: 3306 ?**\n\n**因为我这边的命令行无法识别`netstat -nltp|grep mysql`，到后面才用`netstat  -aon|findstr 3306`查到了占用3306端口的进程，记住了进程后面的PID号，用`taskkil /f /pid 对应的PID号`把进程给杀了才解决问题**\n\n### 无法登陆\n**耗了一些时间后，我用`net start mysql`开启了数据库后，用`mysql -uroot -密码`尝试登陆，结果又报了一个这样的错误**\n>**mysql: [ERROR] mysql: unknown option '-R'.**\n\n**于是用`mysql -uroot -p`后再输入密码,才知道原先输入密码前也要加个p，也就是`mysql -uroot -p密码`。**\n**但是接下来又报了一个错误**\n>**mysql: [Warning] Using a password on the command line interface can be insecure.**\n>**ERROR 1045 (28000): Access denied for user 'root'@'localhost' (using password: YES)**\n\n**查了一下发现是密码错误，因为我输入的是安装时的密码，但是初始化的时候密码重置了，所以密码错了，所以我又绕了一次弯路，把date删了重新初始化了一遍，把初始化输出的临时密码记了下来**\n>**[Note] A temporary password is generated for root@localhost: TKk51x#bOi0S**\n**之后就可以成功登陆了**\n\n### 修改密码\n**登陆后没办法使用其他语句，说是必须修改一下密码，而且自动生成的密码太难记了，我想改回自己的密码，但是在网上查了很多指令都用不成功，错误提示的ALTER USER语句也不知道怎么用，所以又上网馊了一下，还看了一下官方文档，总结就是看不懂~~**\n**查到最后终于发现了一个可以用的语句**\n>`alter user 'root'@'localhost' identified by 'password';`\n\n**这下问题终于解决了，可以开始进一步学习了。**\n\n\n**虽然遇到了很多问题，但是也知道了很多MySQL和命令行的语句，有些没派上用场就是了，至少折腾了一夜一些有用的语句都变熟悉了。**\n","slug":"MySQL安装到登陆的问题","published":1,"updated":"2020-01-23T07:17:04.587Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5qvznn70008gcv532ke5nqg","content":"<p><strong>经过一晚上的折腾，我终于登陆进数据库了！！这期间遇到了不少问题，虽然网上有很多解决方案，但要找到适用的真的不容易，每个问题都花了很长时间去尝试那些指令，绕了很多弯路才解决。</strong></p>\n<h3 id=\"端口冲突\"><a href=\"#端口冲突\" class=\"headerlink\" title=\"端口冲突\"></a>端口冲突</h3><p><strong>安装完遇到的第一个问题就是，没办法打开mysql服务，删了安装目录下的date文件夹重新用<code>mysqld --initialize</code>初始化，重新配置my.ini文件都没用。</strong><br><strong>之后用<code>mysqld --console</code>查了错误信息发现了端口被占用了：</strong></p>\n<blockquote>\n<p><strong>[ERROR] Can’t start server: Bind on TCP/IP port: Address already in use</strong><br><strong>[ERROR] Do you already have another mysqld server running on port: 3306 ?</strong></p>\n</blockquote>\n<p><strong>因为我这边的命令行无法识别<code>netstat -nltp|grep mysql</code>，到后面才用<code>netstat  -aon|findstr 3306</code>查到了占用3306端口的进程，记住了进程后面的PID号，用<code>taskkil /f /pid 对应的PID号</code>把进程给杀了才解决问题</strong></p>\n<h3 id=\"无法登陆\"><a href=\"#无法登陆\" class=\"headerlink\" title=\"无法登陆\"></a>无法登陆</h3><p><strong>耗了一些时间后，我用<code>net start mysql</code>开启了数据库后，用<code>mysql -uroot -密码</code>尝试登陆，结果又报了一个这样的错误</strong></p>\n<blockquote>\n<p><strong>mysql: [ERROR] mysql: unknown option ‘-R’.</strong></p>\n</blockquote>\n<p><strong>于是用<code>mysql -uroot -p</code>后再输入密码,才知道原先输入密码前也要加个p，也就是<code>mysql -uroot -p密码</code>。</strong><br><strong>但是接下来又报了一个错误</strong></p>\n<blockquote>\n<p><strong>mysql: [Warning] Using a password on the command line interface can be insecure.</strong><br><strong>ERROR 1045 (28000): Access denied for user ‘root’@’localhost’ (using password: YES)</strong></p>\n</blockquote>\n<p><strong>查了一下发现是密码错误，因为我输入的是安装时的密码，但是初始化的时候密码重置了，所以密码错了，所以我又绕了一次弯路，把date删了重新初始化了一遍，把初始化输出的临时密码记了下来</strong></p>\n<blockquote>\n<p><strong>[Note] A temporary password is generated for root@localhost: TKk51x#bOi0S</strong><br><strong>之后就可以成功登陆了</strong></p>\n</blockquote>\n<h3 id=\"修改密码\"><a href=\"#修改密码\" class=\"headerlink\" title=\"修改密码\"></a>修改密码</h3><p><strong>登陆后没办法使用其他语句，说是必须修改一下密码，而且自动生成的密码太难记了，我想改回自己的密码，但是在网上查了很多指令都用不成功，错误提示的ALTER USER语句也不知道怎么用，所以又上网馊了一下，还看了一下官方文档，总结就是看不懂~~</strong><br><strong>查到最后终于发现了一个可以用的语句</strong></p>\n<blockquote>\n<p><code>alter user &#39;root&#39;@&#39;localhost&#39; identified by &#39;password&#39;;</code></p>\n</blockquote>\n<p><strong>这下问题终于解决了，可以开始进一步学习了。</strong></p>\n<p><strong>虽然遇到了很多问题，但是也知道了很多MySQL和命令行的语句，有些没派上用场就是了，至少折腾了一夜一些有用的语句都变熟悉了。</strong></p>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>经过一晚上的折腾，我终于登陆进数据库了！！这期间遇到了不少问题，虽然网上有很多解决方案，但要找到适用的真的不容易，每个问题都花了很长时间去尝试那些指令，绕了很多弯路才解决。</strong></p>\n<h3 id=\"端口冲突\"><a href=\"#端口冲突\" class=\"headerlink\" title=\"端口冲突\"></a>端口冲突</h3><p><strong>安装完遇到的第一个问题就是，没办法打开mysql服务，删了安装目录下的date文件夹重新用<code>mysqld --initialize</code>初始化，重新配置my.ini文件都没用。</strong><br><strong>之后用<code>mysqld --console</code>查了错误信息发现了端口被占用了：</strong></p>\n<blockquote>\n<p><strong>[ERROR] Can’t start server: Bind on TCP/IP port: Address already in use</strong><br><strong>[ERROR] Do you already have another mysqld server running on port: 3306 ?</strong></p>\n</blockquote>\n<p><strong>因为我这边的命令行无法识别<code>netstat -nltp|grep mysql</code>，到后面才用<code>netstat  -aon|findstr 3306</code>查到了占用3306端口的进程，记住了进程后面的PID号，用<code>taskkil /f /pid 对应的PID号</code>把进程给杀了才解决问题</strong></p>\n<h3 id=\"无法登陆\"><a href=\"#无法登陆\" class=\"headerlink\" title=\"无法登陆\"></a>无法登陆</h3><p><strong>耗了一些时间后，我用<code>net start mysql</code>开启了数据库后，用<code>mysql -uroot -密码</code>尝试登陆，结果又报了一个这样的错误</strong></p>\n<blockquote>\n<p><strong>mysql: [ERROR] mysql: unknown option ‘-R’.</strong></p>\n</blockquote>\n<p><strong>于是用<code>mysql -uroot -p</code>后再输入密码,才知道原先输入密码前也要加个p，也就是<code>mysql -uroot -p密码</code>。</strong><br><strong>但是接下来又报了一个错误</strong></p>\n<blockquote>\n<p><strong>mysql: [Warning] Using a password on the command line interface can be insecure.</strong><br><strong>ERROR 1045 (28000): Access denied for user ‘root’@’localhost’ (using password: YES)</strong></p>\n</blockquote>\n<p><strong>查了一下发现是密码错误，因为我输入的是安装时的密码，但是初始化的时候密码重置了，所以密码错了，所以我又绕了一次弯路，把date删了重新初始化了一遍，把初始化输出的临时密码记了下来</strong></p>\n<blockquote>\n<p><strong>[Note] A temporary password is generated for root@localhost: TKk51x#bOi0S</strong><br><strong>之后就可以成功登陆了</strong></p>\n</blockquote>\n<h3 id=\"修改密码\"><a href=\"#修改密码\" class=\"headerlink\" title=\"修改密码\"></a>修改密码</h3><p><strong>登陆后没办法使用其他语句，说是必须修改一下密码，而且自动生成的密码太难记了，我想改回自己的密码，但是在网上查了很多指令都用不成功，错误提示的ALTER USER语句也不知道怎么用，所以又上网馊了一下，还看了一下官方文档，总结就是看不懂~~</strong><br><strong>查到最后终于发现了一个可以用的语句</strong></p>\n<blockquote>\n<p><code>alter user &#39;root&#39;@&#39;localhost&#39; identified by &#39;password&#39;;</code></p>\n</blockquote>\n<p><strong>这下问题终于解决了，可以开始进一步学习了。</strong></p>\n<p><strong>虽然遇到了很多问题，但是也知道了很多MySQL和命令行的语句，有些没派上用场就是了，至少折腾了一夜一些有用的语句都变熟悉了。</strong></p>\n"},{"title":"数据结构基础","date":"2019-09-10T16:00:00.000Z","_content":"\n基本概念和术语\n---\n\n**数据(Data)：**客观事物的符号表示，是所有能输入到计算机中并被计算机程序处理的符号的总称\n\n**数据元素(Data Element)：**数据的基本单位，在计算机中通常作为一个整体进行考虑和处理\n\n**数据项(Data Item)：**组成数据元素的、有独立含义的、不可分割的最小单位\n\n**数据对象(Data Object)：**是性质相同的数据元素的集合，是数据的一个子集\n\n\n数据是什么？如何理解数据对象？什么是性质相同的数据元素的集合？\n数据对象相当于数据的一部分内容，而这部分内容里面的元素都有相同的特点，举个例子：\n```text\n数据                                            一个班级里面的学生\n数据对象                                        一个班里学生的信息表\n数据元素                                        学生信息表的每一条数据都是数据元素\n数据项                                          学生信息表里面的每一项信息\n```\n这里面，学生的信息表是学生的一个部分内容，学生可以包含很多内容，除了信息表，还有成绩单，身份内容，这些都算是学生这个数据的一部分，也就是数据的子集，即数据对象。而学生信息表里面会含有很多个信息项，例如姓名学号、专业、性别等等，这些信息项就是数据项，有着独立的含义。信息表里面的每一个学生的数据，都算是一个数据元素，这些学生的数据构和数据项构造成了信息表，所以数据对象是数据元素的集合。\n\n\n### 数据结构\n\n**数据结构(Data Stucture)：是相互之间存在一种或多种特定关系的数据元素的集合。**\n数据结构其实就是带有“结构”的数据元素的集合。不过说是数据元素的集合，我们平时的理解更多的是倾向于结构，学得主要也是结构，但这个名词本身指的还是集合！\n数据结构包括逻辑结构和储存结构两个层次。\n\n#### 逻辑结构\n\n**逻辑结构是对于数据来讲的，从逻辑关系上描述数据，和数据的储存无关，独立于计算机。**\n**数据的逻辑结构分为：线性结构和非线性结构。**\n\n四类基本逻辑结构：\n\n**集合结构：**数据元素除了属于同一集合外，没有其他关系\n**线性结构：**数据元素之间存在一对一的关系\n**树结构：**数据元素之间存在一对多的关系\n**图结构或网状结构：**数据元素之间存在多对多的关系\n\n下面图示，会更容易理解\n\n![数据的逻辑结构层次图](/images/数据逻辑结构层次图.jpg)\n\n#### 储存结构\n\n**储存结构也称为物理结构，指的是数据对象在计算机中的存储方式。**\n通常要求数据对象在存入计算机时既要存储数据元素的数据，也要存储数据元素之间的逻辑关系，数据元素在计算机内用一个结点来表示。\n\n数据元素在计算机中的两种基本储存结构：\n\n**顺序存储结构：**借助元素在存储器中的相对位置来表示数据元素之间的逻辑关系，要求所有的元素依次存放在一片连续的存储空间中\n\n**链式存储结构：**无需占用一整块存储空间，为了表示结点之间的关系，给每个结点附加指针字段，用于存放后继元素的存储地址。\n\n```Text\n课外补充：\n逻辑结构与数据元素本身的形式、内容、相对位置、个数无关。\n一些表面上很不相同的数据可以有相同的逻辑结构\n通常要求同一逻辑结构中的所有数据元素具有相同的特性，这意味着不仅数据元素所包含的数据项的个数要相同，而且对应数据项的类型要一致\n```\n\n## 算法和算法分析\n\n**算法：**是为了解决某类问题而规定的一个有限长的操作序列\n一个算法必须满足的五个重要特征：**有穷性、确定性、可行性、输入、输出**。\n\n一个算法的优劣评价的方面：**正确性、可读性、健壮性、高效性**。\n高效性包括时间和空间两个方面：\n时间高效是指算法设计合理，执行效率高，可以用**时间复杂度**来度量\n空间高效是指算法占用存储容量合理，可以用**空间复杂度**来度量\n**时间复杂度和空间复杂度是衡量算法的两个主要指标。**\n\n衡量算法效率的方法主要有两种：事后统计法和事前分析估算法。\n通常采用事前分析估算法，通过计算算法的渐进复杂度来衡量算法的效率。\n\n### 渐进时间复杂度\n\n**一般情况下对于算法中基本语句的执行的是问题规模n的某个函数f(n)，我们用\"O\"来表示数量级，算法的时间量度记作**\n**T(n) = O(f(n))**\n**它表示随问题规模n的增大，算法执行时间的增长率和 f(n) 的增长率相同，称做算法的渐渐时间复杂度，简称时间复杂度(Time Complexity).**\n\n**问题规模：**问题规模是算法求解问题输入量的多少，是问题大小的本质表示，一般用整数n表示\n**语句频度：**一条语句的重复执行次数\n\n「 以下代码来自书中 」\n\n**一个算法的执行时间大致上等于所有语句执行时间的总和，而语句的执行时间则为该条语句的财富执行次数和执行一次所需时间的乘积。**\n\n```C\n两个n阶矩阵的乘积算法\n设每条语句执行一次所需时间均为单位时间，n为执行规模\n\nfor(i=1; i<=n; i++)                                                     //频度为 n+1\n    for(j=1; j<=n; j++){                                                //频度为 n*(n+1)\n        c[i][j] = 0;                                                    //频度为 n^2\n        for(k=1; k<=n; k++)                                             //频度为 n^2 * (n+1)\n        c[i][j] = c[i][j] + a[i][k] * b[k][j];                          //频度为 n^3\n    }\n\n该算法中所有语句频度的和 f(n) = 2n^3 + 3n^2 + 2n + 1\n```\n\n**为了客观反映一个算法的执行时间，可以通过算法中“基本语句”(重复执行次数和算法的执行时间成正比的语句，它对算法运行时间的贡献最大) 执行次数来度量算法的工作量。**\n**通常，算法的执行时间随问题规模增长而增长，因此对算法的评价只需考虑其随问题规模增长的趋势。**\n\n```Markdown\n上面那个例子,当执行规模n趋向无穷大时\nf(n) / n^3  的极限等于2\n也就是当n充分大时，f(n) 和 n^3 的比是一个不等于0的常数\n即 f(n) 和 n^3 同阶(数量级Order of Magnitude相同)\n时间复杂度T(n) = O(f(n)) = O(n^3)\n```\n\n```Text\n关于常量阶\n当语句频度为1时，算法执行时间是一个与问题规模n无关的常数，即T(n) = O(1)，称为常量阶。\n只要算法执行时间不随问题规模n增长而增长，算法中语句的频度就是某个常数，无论这个常数多大，算法的时间复杂度都是O(1)。\n例如：for(i=0;i<10000;i++){x++;s=0;}\n\n\n关于线性阶\n循环体内两条基本语句的频度均为 f(n)=n，算法的时间复杂度为 T(n) = O(n)，称为线性阶。\n当算法的基本语句频度最大为 n^2 时，T(n) = O(n^2)， 则为平方阶；\n同样，当频度最大为 n^3 时，则为立方阶。\n\n\n对数阶示例\n\ni = 1;\nwhile (i <= n)\n    i = i*3;\n\n设循环体里面的基本语句的频度为 f(n)\n也就是执行了 f(n) 次 i*3\n所以执行完 i的值为 3^f(n)\n由于 i<=n，所以 3^f(n) <= n\n可得到 f(n) <= log_3 n\n所以这个程序的时间复杂度为f(log3 n)\n\n\n最好、最坏、平均时间复杂度\n对于某些问题，算法的基本语句的频度不仅仅和问题的规模有关，还依赖于其他因素，例如：未知的输入值、随机的初始化等等。\n这些问题的算法，在计算时间复杂度的时候需要考虑各种情况。\n称算法在最好情况下的时间复杂度为最好时间复杂度；最坏情况下算法的时间复杂度为最坏时间复杂度，分别指的是算法计算量可能达到的最小值和最大值。\n算法的平均时间复杂度是指算法在所有情况下，按照输入实例以等概率出现时，算法计算量的加权平均值。\n一般来说，人们更关心的是平均情况下和最坏情况下的时间复杂度，但是算法的平均时间复杂度难以确定。\n```\n\n### 渐进空间复杂度\n\n**和时间复杂度类似，渐进空间复杂度(Space Complexity)作为算法所需存储空间的量度，它也是问题规模n的函数，记作S(n) = O(f(n))**\n在分析时，输入数据所占的具体存储量取决于问题，和算法无关，所以秩序分析该算法在实现是所需要的辅助空间就行了。\n若算法实现时所需的辅助存储空间相对于输入数据量而言是个常数，与问题本身无关，则称这个算法为原地工作，辅助空间为O(1)。\n\n```C\n示例：\n\nfor(i=0;i<n/2;i++){\n    t = a[i];\n    a[i] = a[n-i-1];\n    a[n-i-1] = t;\n}\n\n由于算法只需借助一个变量t，与问题规模n的大小无关，所以其空间复杂度为O(1)\n\n\nfor(i=0;i<n;i++)\n    b[i] = a[n-i-1];\nfor(i=0;i<n/2;i++)\n    a[i] = b[i];\n\n算法需要借助一个大小为n的辅助数组b，所以其空间复杂度为O(n)\n```\n\n>参考：人民邮电出版社《数据结构    C语言版|第二版》严蔚敏\n","source":"_posts/数据结构基础.md","raw":"---\ntitle: 数据结构基础\ndate: 2019-9-11\ncategories: 学习笔记\n---\n\n基本概念和术语\n---\n\n**数据(Data)：**客观事物的符号表示，是所有能输入到计算机中并被计算机程序处理的符号的总称\n\n**数据元素(Data Element)：**数据的基本单位，在计算机中通常作为一个整体进行考虑和处理\n\n**数据项(Data Item)：**组成数据元素的、有独立含义的、不可分割的最小单位\n\n**数据对象(Data Object)：**是性质相同的数据元素的集合，是数据的一个子集\n\n\n数据是什么？如何理解数据对象？什么是性质相同的数据元素的集合？\n数据对象相当于数据的一部分内容，而这部分内容里面的元素都有相同的特点，举个例子：\n```text\n数据                                            一个班级里面的学生\n数据对象                                        一个班里学生的信息表\n数据元素                                        学生信息表的每一条数据都是数据元素\n数据项                                          学生信息表里面的每一项信息\n```\n这里面，学生的信息表是学生的一个部分内容，学生可以包含很多内容，除了信息表，还有成绩单，身份内容，这些都算是学生这个数据的一部分，也就是数据的子集，即数据对象。而学生信息表里面会含有很多个信息项，例如姓名学号、专业、性别等等，这些信息项就是数据项，有着独立的含义。信息表里面的每一个学生的数据，都算是一个数据元素，这些学生的数据构和数据项构造成了信息表，所以数据对象是数据元素的集合。\n\n\n### 数据结构\n\n**数据结构(Data Stucture)：是相互之间存在一种或多种特定关系的数据元素的集合。**\n数据结构其实就是带有“结构”的数据元素的集合。不过说是数据元素的集合，我们平时的理解更多的是倾向于结构，学得主要也是结构，但这个名词本身指的还是集合！\n数据结构包括逻辑结构和储存结构两个层次。\n\n#### 逻辑结构\n\n**逻辑结构是对于数据来讲的，从逻辑关系上描述数据，和数据的储存无关，独立于计算机。**\n**数据的逻辑结构分为：线性结构和非线性结构。**\n\n四类基本逻辑结构：\n\n**集合结构：**数据元素除了属于同一集合外，没有其他关系\n**线性结构：**数据元素之间存在一对一的关系\n**树结构：**数据元素之间存在一对多的关系\n**图结构或网状结构：**数据元素之间存在多对多的关系\n\n下面图示，会更容易理解\n\n![数据的逻辑结构层次图](/images/数据逻辑结构层次图.jpg)\n\n#### 储存结构\n\n**储存结构也称为物理结构，指的是数据对象在计算机中的存储方式。**\n通常要求数据对象在存入计算机时既要存储数据元素的数据，也要存储数据元素之间的逻辑关系，数据元素在计算机内用一个结点来表示。\n\n数据元素在计算机中的两种基本储存结构：\n\n**顺序存储结构：**借助元素在存储器中的相对位置来表示数据元素之间的逻辑关系，要求所有的元素依次存放在一片连续的存储空间中\n\n**链式存储结构：**无需占用一整块存储空间，为了表示结点之间的关系，给每个结点附加指针字段，用于存放后继元素的存储地址。\n\n```Text\n课外补充：\n逻辑结构与数据元素本身的形式、内容、相对位置、个数无关。\n一些表面上很不相同的数据可以有相同的逻辑结构\n通常要求同一逻辑结构中的所有数据元素具有相同的特性，这意味着不仅数据元素所包含的数据项的个数要相同，而且对应数据项的类型要一致\n```\n\n## 算法和算法分析\n\n**算法：**是为了解决某类问题而规定的一个有限长的操作序列\n一个算法必须满足的五个重要特征：**有穷性、确定性、可行性、输入、输出**。\n\n一个算法的优劣评价的方面：**正确性、可读性、健壮性、高效性**。\n高效性包括时间和空间两个方面：\n时间高效是指算法设计合理，执行效率高，可以用**时间复杂度**来度量\n空间高效是指算法占用存储容量合理，可以用**空间复杂度**来度量\n**时间复杂度和空间复杂度是衡量算法的两个主要指标。**\n\n衡量算法效率的方法主要有两种：事后统计法和事前分析估算法。\n通常采用事前分析估算法，通过计算算法的渐进复杂度来衡量算法的效率。\n\n### 渐进时间复杂度\n\n**一般情况下对于算法中基本语句的执行的是问题规模n的某个函数f(n)，我们用\"O\"来表示数量级，算法的时间量度记作**\n**T(n) = O(f(n))**\n**它表示随问题规模n的增大，算法执行时间的增长率和 f(n) 的增长率相同，称做算法的渐渐时间复杂度，简称时间复杂度(Time Complexity).**\n\n**问题规模：**问题规模是算法求解问题输入量的多少，是问题大小的本质表示，一般用整数n表示\n**语句频度：**一条语句的重复执行次数\n\n「 以下代码来自书中 」\n\n**一个算法的执行时间大致上等于所有语句执行时间的总和，而语句的执行时间则为该条语句的财富执行次数和执行一次所需时间的乘积。**\n\n```C\n两个n阶矩阵的乘积算法\n设每条语句执行一次所需时间均为单位时间，n为执行规模\n\nfor(i=1; i<=n; i++)                                                     //频度为 n+1\n    for(j=1; j<=n; j++){                                                //频度为 n*(n+1)\n        c[i][j] = 0;                                                    //频度为 n^2\n        for(k=1; k<=n; k++)                                             //频度为 n^2 * (n+1)\n        c[i][j] = c[i][j] + a[i][k] * b[k][j];                          //频度为 n^3\n    }\n\n该算法中所有语句频度的和 f(n) = 2n^3 + 3n^2 + 2n + 1\n```\n\n**为了客观反映一个算法的执行时间，可以通过算法中“基本语句”(重复执行次数和算法的执行时间成正比的语句，它对算法运行时间的贡献最大) 执行次数来度量算法的工作量。**\n**通常，算法的执行时间随问题规模增长而增长，因此对算法的评价只需考虑其随问题规模增长的趋势。**\n\n```Markdown\n上面那个例子,当执行规模n趋向无穷大时\nf(n) / n^3  的极限等于2\n也就是当n充分大时，f(n) 和 n^3 的比是一个不等于0的常数\n即 f(n) 和 n^3 同阶(数量级Order of Magnitude相同)\n时间复杂度T(n) = O(f(n)) = O(n^3)\n```\n\n```Text\n关于常量阶\n当语句频度为1时，算法执行时间是一个与问题规模n无关的常数，即T(n) = O(1)，称为常量阶。\n只要算法执行时间不随问题规模n增长而增长，算法中语句的频度就是某个常数，无论这个常数多大，算法的时间复杂度都是O(1)。\n例如：for(i=0;i<10000;i++){x++;s=0;}\n\n\n关于线性阶\n循环体内两条基本语句的频度均为 f(n)=n，算法的时间复杂度为 T(n) = O(n)，称为线性阶。\n当算法的基本语句频度最大为 n^2 时，T(n) = O(n^2)， 则为平方阶；\n同样，当频度最大为 n^3 时，则为立方阶。\n\n\n对数阶示例\n\ni = 1;\nwhile (i <= n)\n    i = i*3;\n\n设循环体里面的基本语句的频度为 f(n)\n也就是执行了 f(n) 次 i*3\n所以执行完 i的值为 3^f(n)\n由于 i<=n，所以 3^f(n) <= n\n可得到 f(n) <= log_3 n\n所以这个程序的时间复杂度为f(log3 n)\n\n\n最好、最坏、平均时间复杂度\n对于某些问题，算法的基本语句的频度不仅仅和问题的规模有关，还依赖于其他因素，例如：未知的输入值、随机的初始化等等。\n这些问题的算法，在计算时间复杂度的时候需要考虑各种情况。\n称算法在最好情况下的时间复杂度为最好时间复杂度；最坏情况下算法的时间复杂度为最坏时间复杂度，分别指的是算法计算量可能达到的最小值和最大值。\n算法的平均时间复杂度是指算法在所有情况下，按照输入实例以等概率出现时，算法计算量的加权平均值。\n一般来说，人们更关心的是平均情况下和最坏情况下的时间复杂度，但是算法的平均时间复杂度难以确定。\n```\n\n### 渐进空间复杂度\n\n**和时间复杂度类似，渐进空间复杂度(Space Complexity)作为算法所需存储空间的量度，它也是问题规模n的函数，记作S(n) = O(f(n))**\n在分析时，输入数据所占的具体存储量取决于问题，和算法无关，所以秩序分析该算法在实现是所需要的辅助空间就行了。\n若算法实现时所需的辅助存储空间相对于输入数据量而言是个常数，与问题本身无关，则称这个算法为原地工作，辅助空间为O(1)。\n\n```C\n示例：\n\nfor(i=0;i<n/2;i++){\n    t = a[i];\n    a[i] = a[n-i-1];\n    a[n-i-1] = t;\n}\n\n由于算法只需借助一个变量t，与问题规模n的大小无关，所以其空间复杂度为O(1)\n\n\nfor(i=0;i<n;i++)\n    b[i] = a[n-i-1];\nfor(i=0;i<n/2;i++)\n    a[i] = b[i];\n\n算法需要借助一个大小为n的辅助数组b，所以其空间复杂度为O(n)\n```\n\n>参考：人民邮电出版社《数据结构    C语言版|第二版》严蔚敏\n","slug":"数据结构基础","published":1,"updated":"2020-01-23T17:30:19.638Z","_id":"ck5qvznni000cgcv55oxq19gz","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"基本概念和术语\"><a href=\"#基本概念和术语\" class=\"headerlink\" title=\"基本概念和术语\"></a>基本概念和术语</h2><p><strong>数据(Data)：</strong>客观事物的符号表示，是所有能输入到计算机中并被计算机程序处理的符号的总称</p>\n<p><strong>数据元素(Data Element)：</strong>数据的基本单位，在计算机中通常作为一个整体进行考虑和处理</p>\n<p><strong>数据项(Data Item)：</strong>组成数据元素的、有独立含义的、不可分割的最小单位</p>\n<p><strong>数据对象(Data Object)：</strong>是性质相同的数据元素的集合，是数据的一个子集</p>\n<p>数据是什么？如何理解数据对象？什么是性质相同的数据元素的集合？<br>数据对象相当于数据的一部分内容，而这部分内容里面的元素都有相同的特点，举个例子：</p>\n<pre><code class=\"text\">数据                                            一个班级里面的学生\n数据对象                                        一个班里学生的信息表\n数据元素                                        学生信息表的每一条数据都是数据元素\n数据项                                          学生信息表里面的每一项信息</code></pre>\n<p>这里面，学生的信息表是学生的一个部分内容，学生可以包含很多内容，除了信息表，还有成绩单，身份内容，这些都算是学生这个数据的一部分，也就是数据的子集，即数据对象。而学生信息表里面会含有很多个信息项，例如姓名学号、专业、性别等等，这些信息项就是数据项，有着独立的含义。信息表里面的每一个学生的数据，都算是一个数据元素，这些学生的数据构和数据项构造成了信息表，所以数据对象是数据元素的集合。</p>\n<h3 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h3><p><strong>数据结构(Data Stucture)：是相互之间存在一种或多种特定关系的数据元素的集合。</strong><br>数据结构其实就是带有“结构”的数据元素的集合。不过说是数据元素的集合，我们平时的理解更多的是倾向于结构，学得主要也是结构，但这个名词本身指的还是集合！<br>数据结构包括逻辑结构和储存结构两个层次。</p>\n<h4 id=\"逻辑结构\"><a href=\"#逻辑结构\" class=\"headerlink\" title=\"逻辑结构\"></a>逻辑结构</h4><p><strong>逻辑结构是对于数据来讲的，从逻辑关系上描述数据，和数据的储存无关，独立于计算机。</strong><br><strong>数据的逻辑结构分为：线性结构和非线性结构。</strong></p>\n<p>四类基本逻辑结构：</p>\n<p><strong>集合结构：</strong>数据元素除了属于同一集合外，没有其他关系<br><strong>线性结构：</strong>数据元素之间存在一对一的关系<br><strong>树结构：</strong>数据元素之间存在一对多的关系<br><strong>图结构或网状结构：</strong>数据元素之间存在多对多的关系</p>\n<p>下面图示，会更容易理解</p>\n<p><img src=\"/images/%E6%95%B0%E6%8D%AE%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84%E5%B1%82%E6%AC%A1%E5%9B%BE.jpg\" alt=\"数据的逻辑结构层次图\"></p>\n<h4 id=\"储存结构\"><a href=\"#储存结构\" class=\"headerlink\" title=\"储存结构\"></a>储存结构</h4><p><strong>储存结构也称为物理结构，指的是数据对象在计算机中的存储方式。</strong><br>通常要求数据对象在存入计算机时既要存储数据元素的数据，也要存储数据元素之间的逻辑关系，数据元素在计算机内用一个结点来表示。</p>\n<p>数据元素在计算机中的两种基本储存结构：</p>\n<p><strong>顺序存储结构：</strong>借助元素在存储器中的相对位置来表示数据元素之间的逻辑关系，要求所有的元素依次存放在一片连续的存储空间中</p>\n<p><strong>链式存储结构：</strong>无需占用一整块存储空间，为了表示结点之间的关系，给每个结点附加指针字段，用于存放后继元素的存储地址。</p>\n<pre><code class=\"Text\">课外补充：\n逻辑结构与数据元素本身的形式、内容、相对位置、个数无关。\n一些表面上很不相同的数据可以有相同的逻辑结构\n通常要求同一逻辑结构中的所有数据元素具有相同的特性，这意味着不仅数据元素所包含的数据项的个数要相同，而且对应数据项的类型要一致</code></pre>\n<h2 id=\"算法和算法分析\"><a href=\"#算法和算法分析\" class=\"headerlink\" title=\"算法和算法分析\"></a>算法和算法分析</h2><p><strong>算法：</strong>是为了解决某类问题而规定的一个有限长的操作序列<br>一个算法必须满足的五个重要特征：<strong>有穷性、确定性、可行性、输入、输出</strong>。</p>\n<p>一个算法的优劣评价的方面：<strong>正确性、可读性、健壮性、高效性</strong>。<br>高效性包括时间和空间两个方面：<br>时间高效是指算法设计合理，执行效率高，可以用<strong>时间复杂度</strong>来度量<br>空间高效是指算法占用存储容量合理，可以用<strong>空间复杂度</strong>来度量<br><strong>时间复杂度和空间复杂度是衡量算法的两个主要指标。</strong></p>\n<p>衡量算法效率的方法主要有两种：事后统计法和事前分析估算法。<br>通常采用事前分析估算法，通过计算算法的渐进复杂度来衡量算法的效率。</p>\n<h3 id=\"渐进时间复杂度\"><a href=\"#渐进时间复杂度\" class=\"headerlink\" title=\"渐进时间复杂度\"></a>渐进时间复杂度</h3><p><strong>一般情况下对于算法中基本语句的执行的是问题规模n的某个函数f(n)，我们用”O”来表示数量级，算法的时间量度记作</strong><br><strong>T(n) = O(f(n))</strong><br><strong>它表示随问题规模n的增大，算法执行时间的增长率和 f(n) 的增长率相同，称做算法的渐渐时间复杂度，简称时间复杂度(Time Complexity).</strong></p>\n<p><strong>问题规模：</strong>问题规模是算法求解问题输入量的多少，是问题大小的本质表示，一般用整数n表示<br><strong>语句频度：</strong>一条语句的重复执行次数</p>\n<p>「 以下代码来自书中 」</p>\n<p><strong>一个算法的执行时间大致上等于所有语句执行时间的总和，而语句的执行时间则为该条语句的财富执行次数和执行一次所需时间的乘积。</strong></p>\n<pre><code class=\"C\">两个n阶矩阵的乘积算法\n设每条语句执行一次所需时间均为单位时间，n为执行规模\n\nfor(i=1; i&lt;=n; i++)                                                     //频度为 n+1\n    for(j=1; j&lt;=n; j++){                                                //频度为 n*(n+1)\n        c[i][j] = 0;                                                    //频度为 n^2\n        for(k=1; k&lt;=n; k++)                                             //频度为 n^2 * (n+1)\n        c[i][j] = c[i][j] + a[i][k] * b[k][j];                          //频度为 n^3\n    }\n\n该算法中所有语句频度的和 f(n) = 2n^3 + 3n^2 + 2n + 1</code></pre>\n<p><strong>为了客观反映一个算法的执行时间，可以通过算法中“基本语句”(重复执行次数和算法的执行时间成正比的语句，它对算法运行时间的贡献最大) 执行次数来度量算法的工作量。</strong><br><strong>通常，算法的执行时间随问题规模增长而增长，因此对算法的评价只需考虑其随问题规模增长的趋势。</strong></p>\n<pre><code class=\"Markdown\">上面那个例子,当执行规模n趋向无穷大时\nf(n) / n^3  的极限等于2\n也就是当n充分大时，f(n) 和 n^3 的比是一个不等于0的常数\n即 f(n) 和 n^3 同阶(数量级Order of Magnitude相同)\n时间复杂度T(n) = O(f(n)) = O(n^3)</code></pre>\n<pre><code class=\"Text\">关于常量阶\n当语句频度为1时，算法执行时间是一个与问题规模n无关的常数，即T(n) = O(1)，称为常量阶。\n只要算法执行时间不随问题规模n增长而增长，算法中语句的频度就是某个常数，无论这个常数多大，算法的时间复杂度都是O(1)。\n例如：for(i=0;i&lt;10000;i++){x++;s=0;}\n\n\n关于线性阶\n循环体内两条基本语句的频度均为 f(n)=n，算法的时间复杂度为 T(n) = O(n)，称为线性阶。\n当算法的基本语句频度最大为 n^2 时，T(n) = O(n^2)， 则为平方阶；\n同样，当频度最大为 n^3 时，则为立方阶。\n\n\n对数阶示例\n\ni = 1;\nwhile (i &lt;= n)\n    i = i*3;\n\n设循环体里面的基本语句的频度为 f(n)\n也就是执行了 f(n) 次 i*3\n所以执行完 i的值为 3^f(n)\n由于 i&lt;=n，所以 3^f(n) &lt;= n\n可得到 f(n) &lt;= log_3 n\n所以这个程序的时间复杂度为f(log3 n)\n\n\n最好、最坏、平均时间复杂度\n对于某些问题，算法的基本语句的频度不仅仅和问题的规模有关，还依赖于其他因素，例如：未知的输入值、随机的初始化等等。\n这些问题的算法，在计算时间复杂度的时候需要考虑各种情况。\n称算法在最好情况下的时间复杂度为最好时间复杂度；最坏情况下算法的时间复杂度为最坏时间复杂度，分别指的是算法计算量可能达到的最小值和最大值。\n算法的平均时间复杂度是指算法在所有情况下，按照输入实例以等概率出现时，算法计算量的加权平均值。\n一般来说，人们更关心的是平均情况下和最坏情况下的时间复杂度，但是算法的平均时间复杂度难以确定。</code></pre>\n<h3 id=\"渐进空间复杂度\"><a href=\"#渐进空间复杂度\" class=\"headerlink\" title=\"渐进空间复杂度\"></a>渐进空间复杂度</h3><p><strong>和时间复杂度类似，渐进空间复杂度(Space Complexity)作为算法所需存储空间的量度，它也是问题规模n的函数，记作S(n) = O(f(n))</strong><br>在分析时，输入数据所占的具体存储量取决于问题，和算法无关，所以秩序分析该算法在实现是所需要的辅助空间就行了。<br>若算法实现时所需的辅助存储空间相对于输入数据量而言是个常数，与问题本身无关，则称这个算法为原地工作，辅助空间为O(1)。</p>\n<pre><code class=\"C\">示例：\n\nfor(i=0;i&lt;n/2;i++){\n    t = a[i];\n    a[i] = a[n-i-1];\n    a[n-i-1] = t;\n}\n\n由于算法只需借助一个变量t，与问题规模n的大小无关，所以其空间复杂度为O(1)\n\n\nfor(i=0;i&lt;n;i++)\n    b[i] = a[n-i-1];\nfor(i=0;i&lt;n/2;i++)\n    a[i] = b[i];\n\n算法需要借助一个大小为n的辅助数组b，所以其空间复杂度为O(n)</code></pre>\n<blockquote>\n<p>参考：人民邮电出版社《数据结构    C语言版|第二版》严蔚敏</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"基本概念和术语\"><a href=\"#基本概念和术语\" class=\"headerlink\" title=\"基本概念和术语\"></a>基本概念和术语</h2><p><strong>数据(Data)：</strong>客观事物的符号表示，是所有能输入到计算机中并被计算机程序处理的符号的总称</p>\n<p><strong>数据元素(Data Element)：</strong>数据的基本单位，在计算机中通常作为一个整体进行考虑和处理</p>\n<p><strong>数据项(Data Item)：</strong>组成数据元素的、有独立含义的、不可分割的最小单位</p>\n<p><strong>数据对象(Data Object)：</strong>是性质相同的数据元素的集合，是数据的一个子集</p>\n<p>数据是什么？如何理解数据对象？什么是性质相同的数据元素的集合？<br>数据对象相当于数据的一部分内容，而这部分内容里面的元素都有相同的特点，举个例子：</p>\n<pre><code class=\"text\">数据                                            一个班级里面的学生\n数据对象                                        一个班里学生的信息表\n数据元素                                        学生信息表的每一条数据都是数据元素\n数据项                                          学生信息表里面的每一项信息</code></pre>\n<p>这里面，学生的信息表是学生的一个部分内容，学生可以包含很多内容，除了信息表，还有成绩单，身份内容，这些都算是学生这个数据的一部分，也就是数据的子集，即数据对象。而学生信息表里面会含有很多个信息项，例如姓名学号、专业、性别等等，这些信息项就是数据项，有着独立的含义。信息表里面的每一个学生的数据，都算是一个数据元素，这些学生的数据构和数据项构造成了信息表，所以数据对象是数据元素的集合。</p>\n<h3 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h3><p><strong>数据结构(Data Stucture)：是相互之间存在一种或多种特定关系的数据元素的集合。</strong><br>数据结构其实就是带有“结构”的数据元素的集合。不过说是数据元素的集合，我们平时的理解更多的是倾向于结构，学得主要也是结构，但这个名词本身指的还是集合！<br>数据结构包括逻辑结构和储存结构两个层次。</p>\n<h4 id=\"逻辑结构\"><a href=\"#逻辑结构\" class=\"headerlink\" title=\"逻辑结构\"></a>逻辑结构</h4><p><strong>逻辑结构是对于数据来讲的，从逻辑关系上描述数据，和数据的储存无关，独立于计算机。</strong><br><strong>数据的逻辑结构分为：线性结构和非线性结构。</strong></p>\n<p>四类基本逻辑结构：</p>\n<p><strong>集合结构：</strong>数据元素除了属于同一集合外，没有其他关系<br><strong>线性结构：</strong>数据元素之间存在一对一的关系<br><strong>树结构：</strong>数据元素之间存在一对多的关系<br><strong>图结构或网状结构：</strong>数据元素之间存在多对多的关系</p>\n<p>下面图示，会更容易理解</p>\n<p><img src=\"/images/%E6%95%B0%E6%8D%AE%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84%E5%B1%82%E6%AC%A1%E5%9B%BE.jpg\" alt=\"数据的逻辑结构层次图\"></p>\n<h4 id=\"储存结构\"><a href=\"#储存结构\" class=\"headerlink\" title=\"储存结构\"></a>储存结构</h4><p><strong>储存结构也称为物理结构，指的是数据对象在计算机中的存储方式。</strong><br>通常要求数据对象在存入计算机时既要存储数据元素的数据，也要存储数据元素之间的逻辑关系，数据元素在计算机内用一个结点来表示。</p>\n<p>数据元素在计算机中的两种基本储存结构：</p>\n<p><strong>顺序存储结构：</strong>借助元素在存储器中的相对位置来表示数据元素之间的逻辑关系，要求所有的元素依次存放在一片连续的存储空间中</p>\n<p><strong>链式存储结构：</strong>无需占用一整块存储空间，为了表示结点之间的关系，给每个结点附加指针字段，用于存放后继元素的存储地址。</p>\n<pre><code class=\"Text\">课外补充：\n逻辑结构与数据元素本身的形式、内容、相对位置、个数无关。\n一些表面上很不相同的数据可以有相同的逻辑结构\n通常要求同一逻辑结构中的所有数据元素具有相同的特性，这意味着不仅数据元素所包含的数据项的个数要相同，而且对应数据项的类型要一致</code></pre>\n<h2 id=\"算法和算法分析\"><a href=\"#算法和算法分析\" class=\"headerlink\" title=\"算法和算法分析\"></a>算法和算法分析</h2><p><strong>算法：</strong>是为了解决某类问题而规定的一个有限长的操作序列<br>一个算法必须满足的五个重要特征：<strong>有穷性、确定性、可行性、输入、输出</strong>。</p>\n<p>一个算法的优劣评价的方面：<strong>正确性、可读性、健壮性、高效性</strong>。<br>高效性包括时间和空间两个方面：<br>时间高效是指算法设计合理，执行效率高，可以用<strong>时间复杂度</strong>来度量<br>空间高效是指算法占用存储容量合理，可以用<strong>空间复杂度</strong>来度量<br><strong>时间复杂度和空间复杂度是衡量算法的两个主要指标。</strong></p>\n<p>衡量算法效率的方法主要有两种：事后统计法和事前分析估算法。<br>通常采用事前分析估算法，通过计算算法的渐进复杂度来衡量算法的效率。</p>\n<h3 id=\"渐进时间复杂度\"><a href=\"#渐进时间复杂度\" class=\"headerlink\" title=\"渐进时间复杂度\"></a>渐进时间复杂度</h3><p><strong>一般情况下对于算法中基本语句的执行的是问题规模n的某个函数f(n)，我们用”O”来表示数量级，算法的时间量度记作</strong><br><strong>T(n) = O(f(n))</strong><br><strong>它表示随问题规模n的增大，算法执行时间的增长率和 f(n) 的增长率相同，称做算法的渐渐时间复杂度，简称时间复杂度(Time Complexity).</strong></p>\n<p><strong>问题规模：</strong>问题规模是算法求解问题输入量的多少，是问题大小的本质表示，一般用整数n表示<br><strong>语句频度：</strong>一条语句的重复执行次数</p>\n<p>「 以下代码来自书中 」</p>\n<p><strong>一个算法的执行时间大致上等于所有语句执行时间的总和，而语句的执行时间则为该条语句的财富执行次数和执行一次所需时间的乘积。</strong></p>\n<pre><code class=\"C\">两个n阶矩阵的乘积算法\n设每条语句执行一次所需时间均为单位时间，n为执行规模\n\nfor(i=1; i&lt;=n; i++)                                                     //频度为 n+1\n    for(j=1; j&lt;=n; j++){                                                //频度为 n*(n+1)\n        c[i][j] = 0;                                                    //频度为 n^2\n        for(k=1; k&lt;=n; k++)                                             //频度为 n^2 * (n+1)\n        c[i][j] = c[i][j] + a[i][k] * b[k][j];                          //频度为 n^3\n    }\n\n该算法中所有语句频度的和 f(n) = 2n^3 + 3n^2 + 2n + 1</code></pre>\n<p><strong>为了客观反映一个算法的执行时间，可以通过算法中“基本语句”(重复执行次数和算法的执行时间成正比的语句，它对算法运行时间的贡献最大) 执行次数来度量算法的工作量。</strong><br><strong>通常，算法的执行时间随问题规模增长而增长，因此对算法的评价只需考虑其随问题规模增长的趋势。</strong></p>\n<pre><code class=\"Markdown\">上面那个例子,当执行规模n趋向无穷大时\nf(n) / n^3  的极限等于2\n也就是当n充分大时，f(n) 和 n^3 的比是一个不等于0的常数\n即 f(n) 和 n^3 同阶(数量级Order of Magnitude相同)\n时间复杂度T(n) = O(f(n)) = O(n^3)</code></pre>\n<pre><code class=\"Text\">关于常量阶\n当语句频度为1时，算法执行时间是一个与问题规模n无关的常数，即T(n) = O(1)，称为常量阶。\n只要算法执行时间不随问题规模n增长而增长，算法中语句的频度就是某个常数，无论这个常数多大，算法的时间复杂度都是O(1)。\n例如：for(i=0;i&lt;10000;i++){x++;s=0;}\n\n\n关于线性阶\n循环体内两条基本语句的频度均为 f(n)=n，算法的时间复杂度为 T(n) = O(n)，称为线性阶。\n当算法的基本语句频度最大为 n^2 时，T(n) = O(n^2)， 则为平方阶；\n同样，当频度最大为 n^3 时，则为立方阶。\n\n\n对数阶示例\n\ni = 1;\nwhile (i &lt;= n)\n    i = i*3;\n\n设循环体里面的基本语句的频度为 f(n)\n也就是执行了 f(n) 次 i*3\n所以执行完 i的值为 3^f(n)\n由于 i&lt;=n，所以 3^f(n) &lt;= n\n可得到 f(n) &lt;= log_3 n\n所以这个程序的时间复杂度为f(log3 n)\n\n\n最好、最坏、平均时间复杂度\n对于某些问题，算法的基本语句的频度不仅仅和问题的规模有关，还依赖于其他因素，例如：未知的输入值、随机的初始化等等。\n这些问题的算法，在计算时间复杂度的时候需要考虑各种情况。\n称算法在最好情况下的时间复杂度为最好时间复杂度；最坏情况下算法的时间复杂度为最坏时间复杂度，分别指的是算法计算量可能达到的最小值和最大值。\n算法的平均时间复杂度是指算法在所有情况下，按照输入实例以等概率出现时，算法计算量的加权平均值。\n一般来说，人们更关心的是平均情况下和最坏情况下的时间复杂度，但是算法的平均时间复杂度难以确定。</code></pre>\n<h3 id=\"渐进空间复杂度\"><a href=\"#渐进空间复杂度\" class=\"headerlink\" title=\"渐进空间复杂度\"></a>渐进空间复杂度</h3><p><strong>和时间复杂度类似，渐进空间复杂度(Space Complexity)作为算法所需存储空间的量度，它也是问题规模n的函数，记作S(n) = O(f(n))</strong><br>在分析时，输入数据所占的具体存储量取决于问题，和算法无关，所以秩序分析该算法在实现是所需要的辅助空间就行了。<br>若算法实现时所需的辅助存储空间相对于输入数据量而言是个常数，与问题本身无关，则称这个算法为原地工作，辅助空间为O(1)。</p>\n<pre><code class=\"C\">示例：\n\nfor(i=0;i&lt;n/2;i++){\n    t = a[i];\n    a[i] = a[n-i-1];\n    a[n-i-1] = t;\n}\n\n由于算法只需借助一个变量t，与问题规模n的大小无关，所以其空间复杂度为O(1)\n\n\nfor(i=0;i&lt;n;i++)\n    b[i] = a[n-i-1];\nfor(i=0;i&lt;n/2;i++)\n    a[i] = b[i];\n\n算法需要借助一个大小为n的辅助数组b，所以其空间复杂度为O(n)</code></pre>\n<blockquote>\n<p>参考：人民邮电出版社《数据结构    C语言版|第二版》严蔚敏</p>\n</blockquote>\n"},{"title":"用树结构获取自然数拆分结果","date":"2019-11-09T16:00:00.000Z","_content":"\n**任何一个大于1的自然数n，都可以拆分成若干个小于n的自然数相加，现在输入一个数n，列出该数的所有拆分可能**\n像这种获取所有可能性的问题，我第一想到的当然是...\n好吧，这次其实我第一次想到的不是树，而是for循环，其实就是被那么规律的排列给误导了~\n但是最后还是靠树来实现了\n\n不过这一次的问题没定义Tree类了，直接定义了Node类传入列表进行计算存储。\n其实这个问题就是从1到n-1开始遍历，将遍历到的数存到列表里面，每次存完1个数将列表传入下一个节点，再从1开始存，直到列表的和等于n的值，把这个列表进行排序然后存入全局列表result里面，最后再打印出来。\n\n以下是实现代码\n\n```Python\n# 储存结果\nresult = []\n\n# 定义全局变量n\nn=0\n\nclass Node:\n    def __init__(self,num_list):\n        # 计算列表里值的和\n        list_sum = sum(num_list)\n        # 遍历1到当前可储存的最大值\n        for i in range(1,n-list_sum+1):\n            # 复制已存储自然数的列表\n            new_num_list = num_list[:]\n            # 将可存储的值添加进列表\n            new_num_list.append(i)\n            # 如果添加新值后列表里全部元素的和等于n，则该节点为尾节点\n            if list_sum+i == n:\n                # 判断存的自然数是否全都小于n\n                if len(new_num_list)!=1:\n                    # 对存储的自然数进行排序\n                    new_num_list.sort()\n                    # 判断该结果是否已存在\n                    if new_num_list not in result:\n                        result.append(new_num_list)\n            # 如果不是尾节点，继续添加节点\n            if list_sum+i < n:\n                Node(new_num_list)\n\nif __name__ == \"__main__\":\n    print(\"Enter a number greater than two\")\n    # 设置n的值\n    n = int(input())\n    # 开始拆分\n    num_list = []\n    Node(num_list)\n    # 展示结果\n    for i in result:\n        print(i)\n\n```\n\n其实无论是拆分还是组合，只要是求全部可能性的问题，用树结构都可以很好的解决，如果有其它问题请在评论区留言。\n附上GitHub代码链接：<https://github.com/arukione/PythonLearning>\n","source":"_posts/用树结构获取自然数拆分结果.md","raw":"---\ntitle: 用树结构获取自然数拆分结果\ndate: 2019-11-10\ncategories: 学习笔记\ntags:\n    -Python\n---\n\n**任何一个大于1的自然数n，都可以拆分成若干个小于n的自然数相加，现在输入一个数n，列出该数的所有拆分可能**\n像这种获取所有可能性的问题，我第一想到的当然是...\n好吧，这次其实我第一次想到的不是树，而是for循环，其实就是被那么规律的排列给误导了~\n但是最后还是靠树来实现了\n\n不过这一次的问题没定义Tree类了，直接定义了Node类传入列表进行计算存储。\n其实这个问题就是从1到n-1开始遍历，将遍历到的数存到列表里面，每次存完1个数将列表传入下一个节点，再从1开始存，直到列表的和等于n的值，把这个列表进行排序然后存入全局列表result里面，最后再打印出来。\n\n以下是实现代码\n\n```Python\n# 储存结果\nresult = []\n\n# 定义全局变量n\nn=0\n\nclass Node:\n    def __init__(self,num_list):\n        # 计算列表里值的和\n        list_sum = sum(num_list)\n        # 遍历1到当前可储存的最大值\n        for i in range(1,n-list_sum+1):\n            # 复制已存储自然数的列表\n            new_num_list = num_list[:]\n            # 将可存储的值添加进列表\n            new_num_list.append(i)\n            # 如果添加新值后列表里全部元素的和等于n，则该节点为尾节点\n            if list_sum+i == n:\n                # 判断存的自然数是否全都小于n\n                if len(new_num_list)!=1:\n                    # 对存储的自然数进行排序\n                    new_num_list.sort()\n                    # 判断该结果是否已存在\n                    if new_num_list not in result:\n                        result.append(new_num_list)\n            # 如果不是尾节点，继续添加节点\n            if list_sum+i < n:\n                Node(new_num_list)\n\nif __name__ == \"__main__\":\n    print(\"Enter a number greater than two\")\n    # 设置n的值\n    n = int(input())\n    # 开始拆分\n    num_list = []\n    Node(num_list)\n    # 展示结果\n    for i in result:\n        print(i)\n\n```\n\n其实无论是拆分还是组合，只要是求全部可能性的问题，用树结构都可以很好的解决，如果有其它问题请在评论区留言。\n附上GitHub代码链接：<https://github.com/arukione/PythonLearning>\n","slug":"用树结构获取自然数拆分结果","published":1,"updated":"2020-01-23T07:56:38.924Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5qvznnm000egcv5bt9l6uet","content":"<p><strong>任何一个大于1的自然数n，都可以拆分成若干个小于n的自然数相加，现在输入一个数n，列出该数的所有拆分可能</strong><br>像这种获取所有可能性的问题，我第一想到的当然是…<br>好吧，这次其实我第一次想到的不是树，而是for循环，其实就是被那么规律的排列给误导了~<br>但是最后还是靠树来实现了</p>\n<p>不过这一次的问题没定义Tree类了，直接定义了Node类传入列表进行计算存储。<br>其实这个问题就是从1到n-1开始遍历，将遍历到的数存到列表里面，每次存完1个数将列表传入下一个节点，再从1开始存，直到列表的和等于n的值，把这个列表进行排序然后存入全局列表result里面，最后再打印出来。</p>\n<p>以下是实现代码</p>\n<pre><code class=\"Python\"># 储存结果\nresult = []\n\n# 定义全局变量n\nn=0\n\nclass Node:\n    def __init__(self,num_list):\n        # 计算列表里值的和\n        list_sum = sum(num_list)\n        # 遍历1到当前可储存的最大值\n        for i in range(1,n-list_sum+1):\n            # 复制已存储自然数的列表\n            new_num_list = num_list[:]\n            # 将可存储的值添加进列表\n            new_num_list.append(i)\n            # 如果添加新值后列表里全部元素的和等于n，则该节点为尾节点\n            if list_sum+i == n:\n                # 判断存的自然数是否全都小于n\n                if len(new_num_list)!=1:\n                    # 对存储的自然数进行排序\n                    new_num_list.sort()\n                    # 判断该结果是否已存在\n                    if new_num_list not in result:\n                        result.append(new_num_list)\n            # 如果不是尾节点，继续添加节点\n            if list_sum+i &lt; n:\n                Node(new_num_list)\n\nif __name__ == &quot;__main__&quot;:\n    print(&quot;Enter a number greater than two&quot;)\n    # 设置n的值\n    n = int(input())\n    # 开始拆分\n    num_list = []\n    Node(num_list)\n    # 展示结果\n    for i in result:\n        print(i)\n</code></pre>\n<p>其实无论是拆分还是组合，只要是求全部可能性的问题，用树结构都可以很好的解决，如果有其它问题请在评论区留言。<br>附上GitHub代码链接：<a href=\"https://github.com/arukione/PythonLearning\" target=\"_blank\" rel=\"noopener\">https://github.com/arukione/PythonLearning</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>任何一个大于1的自然数n，都可以拆分成若干个小于n的自然数相加，现在输入一个数n，列出该数的所有拆分可能</strong><br>像这种获取所有可能性的问题，我第一想到的当然是…<br>好吧，这次其实我第一次想到的不是树，而是for循环，其实就是被那么规律的排列给误导了~<br>但是最后还是靠树来实现了</p>\n<p>不过这一次的问题没定义Tree类了，直接定义了Node类传入列表进行计算存储。<br>其实这个问题就是从1到n-1开始遍历，将遍历到的数存到列表里面，每次存完1个数将列表传入下一个节点，再从1开始存，直到列表的和等于n的值，把这个列表进行排序然后存入全局列表result里面，最后再打印出来。</p>\n<p>以下是实现代码</p>\n<pre><code class=\"Python\"># 储存结果\nresult = []\n\n# 定义全局变量n\nn=0\n\nclass Node:\n    def __init__(self,num_list):\n        # 计算列表里值的和\n        list_sum = sum(num_list)\n        # 遍历1到当前可储存的最大值\n        for i in range(1,n-list_sum+1):\n            # 复制已存储自然数的列表\n            new_num_list = num_list[:]\n            # 将可存储的值添加进列表\n            new_num_list.append(i)\n            # 如果添加新值后列表里全部元素的和等于n，则该节点为尾节点\n            if list_sum+i == n:\n                # 判断存的自然数是否全都小于n\n                if len(new_num_list)!=1:\n                    # 对存储的自然数进行排序\n                    new_num_list.sort()\n                    # 判断该结果是否已存在\n                    if new_num_list not in result:\n                        result.append(new_num_list)\n            # 如果不是尾节点，继续添加节点\n            if list_sum+i &lt; n:\n                Node(new_num_list)\n\nif __name__ == &quot;__main__&quot;:\n    print(&quot;Enter a number greater than two&quot;)\n    # 设置n的值\n    n = int(input())\n    # 开始拆分\n    num_list = []\n    Node(num_list)\n    # 展示结果\n    for i in result:\n        print(i)\n</code></pre>\n<p>其实无论是拆分还是组合，只要是求全部可能性的问题，用树结构都可以很好的解决，如果有其它问题请在评论区留言。<br>附上GitHub代码链接：<a href=\"https://github.com/arukione/PythonLearning\" target=\"_blank\" rel=\"noopener\">https://github.com/arukione/PythonLearning</a></p>\n"},{"title":"用树结构获取字符排列组合","date":"2019-11-09T16:00:00.000Z","_content":"\n**假如有一串字符串，要对字符串里所有字符进行排列，列出所有排列组合的可能**\n对于这种获取所有可能性的问题我第一想到的就是用树结构来实现，显然这个问题不能用二叉树，那我们就不用二叉树了，反正也没要求一定要用(hhhhh)\n\n对于这种问题，我们知道遍历到最后的树叶就是其中的一种结果，所以我们定义一个全局列表来储存全部树叶的结果。\n对于这个问题，并没有所谓的树根，树的开头就是所有可能的第一个字符。\n所以我们定义一个树的类来对第一次传入节点进行操作；\n定义一个节点类来作为树节点，并直接把向下添加的节点写在构造函数里面，只要符合要求就一直向下传入节点，直到全部字符都遍历完，到达树叶的时候将该结果存储起来。\n\n```Python\n# 存储树叶结果\nresult = []\n\n\n# 树结构\nclass Tree:\n\n    def __init__(self,strings):\n        # 树根节点\n        self.nodes = []\n        if strings != []:\n            for index in range(0,len(strings)):\n                # 把字符传入节点\n                node = Node(index,strings[index],strings)\n                # 添加子节点到树根\n                self.nodes.append(node)\n\n\n# 节点结构\nclass Node:\n    def __init__(self,index,string,strings):\n        # 树节点的值\n        self.value = string\n        # 树节点的子节点\n        self.nodes = []\n        # 复制新的字符列表\n        self.strings = strings[:]\n        # 将已拼接入节点值的字符从字符列表里删除\n        self.strings.pop(index)\n        # 如果字符列表为空，则结束添加节点，将当前树叶节点保存的值存进result\n        if len(self.strings) == 0:\n            result.append(self.value)\n        # 不为空，继续将字符存入新节点添加到当前节点的子节点中\n        else:\n            for i in range(0,len(self.strings)):\n                node = Node(i,self.value+self.strings[i],self.strings)\n                self.nodes.append(node)\n```\n\n以下是执行的主方法\n先从键盘获取字符串，再将字符串转成列表以便进行遍历，然后将字符列表传入树进行操作\n最后按照不同字符开头分段打印出结果\n\n```Python\nif __name__ == \"__main__\":\n    string = str(input())\n\n    strings = list(string)\n    tree = Tree(strings)\n\n    for i in range(0,len(strings)):\n        length = int(len(result)/len(strings))\n        print(result[i*length:i*length+length])\n\n```\n\n对于遍历所有可能的问题，树结构往往会是我第一考虑的解决方法，因为这种结构基本可以将需要的可能都列出来，即使会有累赘的元素，但是所有可能往往都可以很好的列出来，实现起来也很方便。\n有问题反馈请在评论区留言。\nGitHub源代码链接：<https://github.com/arukione/PythonLearning>\n","source":"_posts/用树结构获取字符排列组合.md","raw":"---\ntitle: 用树结构获取字符排列组合\ndate: 2019-11-10\ncategories: 学习笔记\ntags:\n    -Python\n---\n\n**假如有一串字符串，要对字符串里所有字符进行排列，列出所有排列组合的可能**\n对于这种获取所有可能性的问题我第一想到的就是用树结构来实现，显然这个问题不能用二叉树，那我们就不用二叉树了，反正也没要求一定要用(hhhhh)\n\n对于这种问题，我们知道遍历到最后的树叶就是其中的一种结果，所以我们定义一个全局列表来储存全部树叶的结果。\n对于这个问题，并没有所谓的树根，树的开头就是所有可能的第一个字符。\n所以我们定义一个树的类来对第一次传入节点进行操作；\n定义一个节点类来作为树节点，并直接把向下添加的节点写在构造函数里面，只要符合要求就一直向下传入节点，直到全部字符都遍历完，到达树叶的时候将该结果存储起来。\n\n```Python\n# 存储树叶结果\nresult = []\n\n\n# 树结构\nclass Tree:\n\n    def __init__(self,strings):\n        # 树根节点\n        self.nodes = []\n        if strings != []:\n            for index in range(0,len(strings)):\n                # 把字符传入节点\n                node = Node(index,strings[index],strings)\n                # 添加子节点到树根\n                self.nodes.append(node)\n\n\n# 节点结构\nclass Node:\n    def __init__(self,index,string,strings):\n        # 树节点的值\n        self.value = string\n        # 树节点的子节点\n        self.nodes = []\n        # 复制新的字符列表\n        self.strings = strings[:]\n        # 将已拼接入节点值的字符从字符列表里删除\n        self.strings.pop(index)\n        # 如果字符列表为空，则结束添加节点，将当前树叶节点保存的值存进result\n        if len(self.strings) == 0:\n            result.append(self.value)\n        # 不为空，继续将字符存入新节点添加到当前节点的子节点中\n        else:\n            for i in range(0,len(self.strings)):\n                node = Node(i,self.value+self.strings[i],self.strings)\n                self.nodes.append(node)\n```\n\n以下是执行的主方法\n先从键盘获取字符串，再将字符串转成列表以便进行遍历，然后将字符列表传入树进行操作\n最后按照不同字符开头分段打印出结果\n\n```Python\nif __name__ == \"__main__\":\n    string = str(input())\n\n    strings = list(string)\n    tree = Tree(strings)\n\n    for i in range(0,len(strings)):\n        length = int(len(result)/len(strings))\n        print(result[i*length:i*length+length])\n\n```\n\n对于遍历所有可能的问题，树结构往往会是我第一考虑的解决方法，因为这种结构基本可以将需要的可能都列出来，即使会有累赘的元素，但是所有可能往往都可以很好的列出来，实现起来也很方便。\n有问题反馈请在评论区留言。\nGitHub源代码链接：<https://github.com/arukione/PythonLearning>\n","slug":"用树结构获取字符排列组合","published":1,"updated":"2020-01-23T07:18:41.637Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5qvznns000igcv5530u8tuw","content":"<p><strong>假如有一串字符串，要对字符串里所有字符进行排列，列出所有排列组合的可能</strong><br>对于这种获取所有可能性的问题我第一想到的就是用树结构来实现，显然这个问题不能用二叉树，那我们就不用二叉树了，反正也没要求一定要用(hhhhh)</p>\n<p>对于这种问题，我们知道遍历到最后的树叶就是其中的一种结果，所以我们定义一个全局列表来储存全部树叶的结果。<br>对于这个问题，并没有所谓的树根，树的开头就是所有可能的第一个字符。<br>所以我们定义一个树的类来对第一次传入节点进行操作；<br>定义一个节点类来作为树节点，并直接把向下添加的节点写在构造函数里面，只要符合要求就一直向下传入节点，直到全部字符都遍历完，到达树叶的时候将该结果存储起来。</p>\n<pre><code class=\"Python\"># 存储树叶结果\nresult = []\n\n\n# 树结构\nclass Tree:\n\n    def __init__(self,strings):\n        # 树根节点\n        self.nodes = []\n        if strings != []:\n            for index in range(0,len(strings)):\n                # 把字符传入节点\n                node = Node(index,strings[index],strings)\n                # 添加子节点到树根\n                self.nodes.append(node)\n\n\n# 节点结构\nclass Node:\n    def __init__(self,index,string,strings):\n        # 树节点的值\n        self.value = string\n        # 树节点的子节点\n        self.nodes = []\n        # 复制新的字符列表\n        self.strings = strings[:]\n        # 将已拼接入节点值的字符从字符列表里删除\n        self.strings.pop(index)\n        # 如果字符列表为空，则结束添加节点，将当前树叶节点保存的值存进result\n        if len(self.strings) == 0:\n            result.append(self.value)\n        # 不为空，继续将字符存入新节点添加到当前节点的子节点中\n        else:\n            for i in range(0,len(self.strings)):\n                node = Node(i,self.value+self.strings[i],self.strings)\n                self.nodes.append(node)</code></pre>\n<p>以下是执行的主方法<br>先从键盘获取字符串，再将字符串转成列表以便进行遍历，然后将字符列表传入树进行操作<br>最后按照不同字符开头分段打印出结果</p>\n<pre><code class=\"Python\">if __name__ == &quot;__main__&quot;:\n    string = str(input())\n\n    strings = list(string)\n    tree = Tree(strings)\n\n    for i in range(0,len(strings)):\n        length = int(len(result)/len(strings))\n        print(result[i*length:i*length+length])\n</code></pre>\n<p>对于遍历所有可能的问题，树结构往往会是我第一考虑的解决方法，因为这种结构基本可以将需要的可能都列出来，即使会有累赘的元素，但是所有可能往往都可以很好的列出来，实现起来也很方便。<br>有问题反馈请在评论区留言。<br>GitHub源代码链接：<a href=\"https://github.com/arukione/PythonLearning\" target=\"_blank\" rel=\"noopener\">https://github.com/arukione/PythonLearning</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>假如有一串字符串，要对字符串里所有字符进行排列，列出所有排列组合的可能</strong><br>对于这种获取所有可能性的问题我第一想到的就是用树结构来实现，显然这个问题不能用二叉树，那我们就不用二叉树了，反正也没要求一定要用(hhhhh)</p>\n<p>对于这种问题，我们知道遍历到最后的树叶就是其中的一种结果，所以我们定义一个全局列表来储存全部树叶的结果。<br>对于这个问题，并没有所谓的树根，树的开头就是所有可能的第一个字符。<br>所以我们定义一个树的类来对第一次传入节点进行操作；<br>定义一个节点类来作为树节点，并直接把向下添加的节点写在构造函数里面，只要符合要求就一直向下传入节点，直到全部字符都遍历完，到达树叶的时候将该结果存储起来。</p>\n<pre><code class=\"Python\"># 存储树叶结果\nresult = []\n\n\n# 树结构\nclass Tree:\n\n    def __init__(self,strings):\n        # 树根节点\n        self.nodes = []\n        if strings != []:\n            for index in range(0,len(strings)):\n                # 把字符传入节点\n                node = Node(index,strings[index],strings)\n                # 添加子节点到树根\n                self.nodes.append(node)\n\n\n# 节点结构\nclass Node:\n    def __init__(self,index,string,strings):\n        # 树节点的值\n        self.value = string\n        # 树节点的子节点\n        self.nodes = []\n        # 复制新的字符列表\n        self.strings = strings[:]\n        # 将已拼接入节点值的字符从字符列表里删除\n        self.strings.pop(index)\n        # 如果字符列表为空，则结束添加节点，将当前树叶节点保存的值存进result\n        if len(self.strings) == 0:\n            result.append(self.value)\n        # 不为空，继续将字符存入新节点添加到当前节点的子节点中\n        else:\n            for i in range(0,len(self.strings)):\n                node = Node(i,self.value+self.strings[i],self.strings)\n                self.nodes.append(node)</code></pre>\n<p>以下是执行的主方法<br>先从键盘获取字符串，再将字符串转成列表以便进行遍历，然后将字符列表传入树进行操作<br>最后按照不同字符开头分段打印出结果</p>\n<pre><code class=\"Python\">if __name__ == &quot;__main__&quot;:\n    string = str(input())\n\n    strings = list(string)\n    tree = Tree(strings)\n\n    for i in range(0,len(strings)):\n        length = int(len(result)/len(strings))\n        print(result[i*length:i*length+length])\n</code></pre>\n<p>对于遍历所有可能的问题，树结构往往会是我第一考虑的解决方法，因为这种结构基本可以将需要的可能都列出来，即使会有累赘的元素，但是所有可能往往都可以很好的列出来，实现起来也很方便。<br>有问题反馈请在评论区留言。<br>GitHub源代码链接：<a href=\"https://github.com/arukione/PythonLearning\" target=\"_blank\" rel=\"noopener\">https://github.com/arukione/PythonLearning</a></p>\n"},{"title":"关于沉迷于东方Project这件事","date":"2020-01-23T16:00:00.000Z","_content":"\n这件事要从当初玩饥荒开始说起。\n\n快期末的时候被朋友拉去玩饥荒，依我这性格，刚入手的游戏肯定会沉迷其中，当时看各种玩法，安装各种模组，尤其是喜欢安装那些人物的模组，毕竟原本就很喜欢二次元的东西\n\n其中一个人物模组就是东方Project的一个人物\"幽幽子\"，当时并不知道她是怎么玩的，就拿个扇子到处跑，然后感觉不好玩就换了个人物了。\n\n后来一个偶然的机会，看到了关于这个模组的介绍视频，就点进去看了一下(毕竟还是想知道这个设计是怎么玩的)\n\n附上视频地址：https://www.bilibili.com/video/av26511125/\n\n视频里介绍模组玩法的时候，也有介绍幽幽子的故事背景，当时就给幽幽子的人设和故事给吸引了，开始了寻找幽幽子相关内容的路程！\n\n然后就...一发不可收拾，开始往整个东方Project扩展了\n\n在网上到处找东方Project的故事介绍和视频，虽然知道是游戏，不过本人并没有打算入坑游戏的意思，毕竟像这种二次元的内容，我还是偏向喜欢看视频(什么时候才能动画化啊~滑稽)\n\n东方整个设定刚好符合我的口味(满是美少女的妖怪世界？)，其中的红魔馆的二小姐和妖妖梦的幽幽子的设定是我最喜欢的，当然感触最深的还是幽幽子和西行妖的设定。\n关于歌曲的，肯定得说说<華鳥風月>。东方的歌曲风格并不是我喜欢的类型，不过这首歌的曲调和里面的一些歌词我倒是挺喜欢的，例如我的about页面里的\"正しさなんてもの、人のモノサシによって変わる\"这句话，就是歌词4句ああ后的那前两句。\n博客的主页背景和文章背景也是来自东方，毕竟重新修改博客的这段时间刚好沉迷于这个，连桌面背景也都是这个(笑)。\n\n在网上看到有关于东方的同人视频作品，看百科似乎是作者不想轻易动画化，想做成剧场版，嘛~对我来说只要是视频都会期待一下，不知道官方动画作品出来那一天什么时候会到\n","source":"_posts/关于沉迷于东方Project这件事.md","raw":"---\ntitle: 关于沉迷于东方Project这件事\ndate: 2020-1-24\ncategories: 生活日常\n---\n\n这件事要从当初玩饥荒开始说起。\n\n快期末的时候被朋友拉去玩饥荒，依我这性格，刚入手的游戏肯定会沉迷其中，当时看各种玩法，安装各种模组，尤其是喜欢安装那些人物的模组，毕竟原本就很喜欢二次元的东西\n\n其中一个人物模组就是东方Project的一个人物\"幽幽子\"，当时并不知道她是怎么玩的，就拿个扇子到处跑，然后感觉不好玩就换了个人物了。\n\n后来一个偶然的机会，看到了关于这个模组的介绍视频，就点进去看了一下(毕竟还是想知道这个设计是怎么玩的)\n\n附上视频地址：https://www.bilibili.com/video/av26511125/\n\n视频里介绍模组玩法的时候，也有介绍幽幽子的故事背景，当时就给幽幽子的人设和故事给吸引了，开始了寻找幽幽子相关内容的路程！\n\n然后就...一发不可收拾，开始往整个东方Project扩展了\n\n在网上到处找东方Project的故事介绍和视频，虽然知道是游戏，不过本人并没有打算入坑游戏的意思，毕竟像这种二次元的内容，我还是偏向喜欢看视频(什么时候才能动画化啊~滑稽)\n\n东方整个设定刚好符合我的口味(满是美少女的妖怪世界？)，其中的红魔馆的二小姐和妖妖梦的幽幽子的设定是我最喜欢的，当然感触最深的还是幽幽子和西行妖的设定。\n关于歌曲的，肯定得说说<華鳥風月>。东方的歌曲风格并不是我喜欢的类型，不过这首歌的曲调和里面的一些歌词我倒是挺喜欢的，例如我的about页面里的\"正しさなんてもの、人のモノサシによって変わる\"这句话，就是歌词4句ああ后的那前两句。\n博客的主页背景和文章背景也是来自东方，毕竟重新修改博客的这段时间刚好沉迷于这个，连桌面背景也都是这个(笑)。\n\n在网上看到有关于东方的同人视频作品，看百科似乎是作者不想轻易动画化，想做成剧场版，嘛~对我来说只要是视频都会期待一下，不知道官方动画作品出来那一天什么时候会到\n","slug":"关于沉迷于东方Project这件事","published":1,"updated":"2020-01-24T03:55:10.806Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5rmu7tx00005cv5edkgcdou","content":"<p>这件事要从当初玩饥荒开始说起。</p>\n<p>快期末的时候被朋友拉去玩饥荒，依我这性格，刚入手的游戏肯定会沉迷其中，当时看各种玩法，安装各种模组，尤其是喜欢安装那些人物的模组，毕竟原本就很喜欢二次元的东西</p>\n<p>其中一个人物模组就是东方Project的一个人物”幽幽子”，当时并不知道她是怎么玩的，就拿个扇子到处跑，然后感觉不好玩就换了个人物了。</p>\n<p>后来一个偶然的机会，看到了关于这个模组的介绍视频，就点进去看了一下(毕竟还是想知道这个设计是怎么玩的)</p>\n<p>附上视频地址：<a href=\"https://www.bilibili.com/video/av26511125/\" target=\"_blank\" rel=\"noopener\">https://www.bilibili.com/video/av26511125/</a></p>\n<p>视频里介绍模组玩法的时候，也有介绍幽幽子的故事背景，当时就给幽幽子的人设和故事给吸引了，开始了寻找幽幽子相关内容的路程！</p>\n<p>然后就…一发不可收拾，开始往整个东方Project扩展了</p>\n<p>在网上到处找东方Project的故事介绍和视频，虽然知道是游戏，不过本人并没有打算入坑游戏的意思，毕竟像这种二次元的内容，我还是偏向喜欢看视频(什么时候才能动画化啊~滑稽)</p>\n<p>东方整个设定刚好符合我的口味(满是美少女的妖怪世界？)，其中的红魔馆的二小姐和妖妖梦的幽幽子的设定是我最喜欢的，当然感触最深的还是幽幽子和西行妖的设定。<br>关于歌曲的，肯定得说说&lt;華鳥風月&gt;。东方的歌曲风格并不是我喜欢的类型，不过这首歌的曲调和里面的一些歌词我倒是挺喜欢的，例如我的about页面里的”正しさなんてもの、人のモノサシによって変わる”这句话，就是歌词4句ああ后的那前两句。<br>博客的主页背景和文章背景也是来自东方，毕竟重新修改博客的这段时间刚好沉迷于这个，连桌面背景也都是这个(笑)。</p>\n<p>在网上看到有关于东方的同人视频作品，看百科似乎是作者不想轻易动画化，想做成剧场版，嘛~对我来说只要是视频都会期待一下，不知道官方动画作品出来那一天什么时候会到</p>\n","site":{"data":{}},"excerpt":"","more":"<p>这件事要从当初玩饥荒开始说起。</p>\n<p>快期末的时候被朋友拉去玩饥荒，依我这性格，刚入手的游戏肯定会沉迷其中，当时看各种玩法，安装各种模组，尤其是喜欢安装那些人物的模组，毕竟原本就很喜欢二次元的东西</p>\n<p>其中一个人物模组就是东方Project的一个人物”幽幽子”，当时并不知道她是怎么玩的，就拿个扇子到处跑，然后感觉不好玩就换了个人物了。</p>\n<p>后来一个偶然的机会，看到了关于这个模组的介绍视频，就点进去看了一下(毕竟还是想知道这个设计是怎么玩的)</p>\n<p>附上视频地址：<a href=\"https://www.bilibili.com/video/av26511125/\" target=\"_blank\" rel=\"noopener\">https://www.bilibili.com/video/av26511125/</a></p>\n<p>视频里介绍模组玩法的时候，也有介绍幽幽子的故事背景，当时就给幽幽子的人设和故事给吸引了，开始了寻找幽幽子相关内容的路程！</p>\n<p>然后就…一发不可收拾，开始往整个东方Project扩展了</p>\n<p>在网上到处找东方Project的故事介绍和视频，虽然知道是游戏，不过本人并没有打算入坑游戏的意思，毕竟像这种二次元的内容，我还是偏向喜欢看视频(什么时候才能动画化啊~滑稽)</p>\n<p>东方整个设定刚好符合我的口味(满是美少女的妖怪世界？)，其中的红魔馆的二小姐和妖妖梦的幽幽子的设定是我最喜欢的，当然感触最深的还是幽幽子和西行妖的设定。<br>关于歌曲的，肯定得说说&lt;華鳥風月&gt;。东方的歌曲风格并不是我喜欢的类型，不过这首歌的曲调和里面的一些歌词我倒是挺喜欢的，例如我的about页面里的”正しさなんてもの、人のモノサシによって変わる”这句话，就是歌词4句ああ后的那前两句。<br>博客的主页背景和文章背景也是来自东方，毕竟重新修改博客的这段时间刚好沉迷于这个，连桌面背景也都是这个(笑)。</p>\n<p>在网上看到有关于东方的同人视频作品，看百科似乎是作者不想轻易动画化，想做成剧场版，嘛~对我来说只要是视频都会期待一下，不知道官方动画作品出来那一天什么时候会到</p>\n"},{"title":"使用setuptools和twine把项目打成pip包","date":"2020-01-24T16:00:00.000Z","_content":"\n本文章是根据根据官方教程在实际后写下的，可以边参考官方教程边阅读本文章，这样可能有助于您理解打包pip软件包\n\n另外本人使用的是Python3，操作可能会和Python2有点不同，同时使用的命令是参考了其他的教程，和官方命令也不太一样，免去了许多参数的选择，更加简单。\n\n如果希望更加全面地理解和打包pip软件包请参考\n\n官方教程：https://packaging.python.org/tutorials/packaging-projects/\n\n需要使用到的东西\n---\n\n两个Python包：setuptools、twine\n\n一个PyPI账号：https://pypi.org/\n\n打一个pip软件包一定要有这两个工具，setuptools用于创建构建脚本，twine用于上传项目，上传的pip包都会放在这里PyPI\n\n打包一个项目的文件结构\n---\n\n```Text\n软件包根目录/\n    打包的项目/\n        __init__.py\n        ...\n    setup.py\n    LICENSE\n    README.md\n```\n\n根目录的名字不知道对项目名有没有影响，我都是直接取发行名称\n\n在这个目录下，最简单的配置包括4个部分：\n\n```Text\n要打包的项目：你准备打包成pip包的项目\nsetup.py：构建脚本，里面写的是软件包的相关信息和代码配置信息\nLICENSE：软件包使用的许可证\nREADME.md：说明文件\n```\n\n打包配置\n---\n\n打包的项目就不说了，可能你是直接打包已有项目，也可能是打算打包从头写的项目，打包的关键步骤主要是setup.py的配置和上传命令的使用，上传项目时软件包的信息都是根据setup里面的配置来上传的\n\n**把官方setup.py的配置简化一下就是以下的样子,三个点代表省略**\n\n```Python\nimport setuptools\n\n# 这里从README导入详细说明\nwith open(\"README.md\", \"r\") as fh:\n    long_description = fh.read()\n\nsetuptools.setup(\n    name=\"example-pkg-YOUR-USERNAME-HERE\", # pip软件包发行的名称\n    version=\"0.0.1\", # 本次上传的版本\n    author=\"Example Author\", # 作者名称\n    author_email=\"author@example.com\", # 作者邮箱\n    description=\"A small example package\", # 软件包摘要\n    long_description=long_description, # 软件包详细说明\n    long_description_content_type=\"text/markdown\", # 引用详细说明的文件格式\n    url=\"https://github.com/pypa/sampleproject\", # 项目的主页地址，大部分是使用该项目在自己代码储存库的地址\n    license=\"MIT\" # 许可证类型\n    packages=setuptools.find_packages(), # 要打包的所有Python包列表\n    # 是列出了你的包的额外元数据，给你的包进行分类，下面的意思是“该软件包仅与Python 3兼容，已获得MIT许可，与操作系统无关”\n    classifiers=[\n        \"Programming Language :: Python :: 3\",\n        \"License :: OSI Approved :: MIT License\",\n        \"Operating System :: OS Independent\",\n    ],\n    # 能够使用你的项目的Python版本\n    python_requires='>=3.6',\n    # 你的项目的依赖项，安装你的软件包时，pip也会自动安装以下依赖项，举个例子--pymysql\n    install_requires = [\n        'pymysql',\n        ...\n    ]\n    ...\n)\n```\n\n**官方全部字段的配置说明：https://packaging.python.org/guides/distributing-packages-using-setuptools/**\n\n**配置文件的时候有几个注意点：**\n**1、上传不同版本的软件包，version要修改，因为生成的压缩包版本后缀是根据这一行配置的**\n**2、packages可以手动列出需要打包的Python包列表，如果使用`find_package()`的话则是脚本自动发现所有软件包和子软件包**\n**3、关于classifiers的配置根据不同项目配置都不一样，参考官方分类器列表：https://pypi.org/classifiers/**\n**4、如果设置了python_requires，那么所有不符合要求的Python版本都会被pip阻止安装这个软件包**\n\n**配置完setup.py，接下来就是根据你的需要选择许可证：https://choosealicense.com/**\n**选择完许可证要把许可证文本写入LICENSE文件，或者也可以在使用GitHub Desktop创建仓库时创建许可证，如果setup.py里有配置license这一项记得修改成对应的类型**\n\n打包\n---\n\n打包前，要先check一下，看看setup的配置是否有效\n\n在软件包根目录使用命令：`setup.py check`\n\n如果只显示了running check就是正常的\n\n如果没问题使用sdist进行打包\n\n`setup.py sdist`\n\n生成的压缩包会放在dist/下面，把这些包上传就完成了，但是上传前还要进行一次检查，看看压缩包是否符合要求\n\n检查命令：`twine check dist/*`\n\n上传命令：`twine upload dist/*`\n\n输入用户名和密码就可以了\n\n**这里也有几个注意点：**\n**1、有些教程会使用`setup.py register`来进行注册上传，但是这个方法其实已经弃用了，官方推荐是直接使用`twine upload`**\n**2、dist/*是指dist下的全部文件，如果上传的压缩包含有以前的版本，因为该版本已经上传过了，会有错误提示，可以把以前版本的压缩包删掉，也可以自己选择上传的包，而不是全部上传**\n**3、我这里没有配置用户文件，配置文件可以免去验证用户的流程**\n**4、官方推荐是注册令牌来代替用户名和密码上传，注册令牌是一种更安全可靠的方式**\n\n如果以上步骤都没问题，你就可以在自己的账号上面看到上传的pip软件包了\n\n——更多内容待更新——\n","source":"_posts/使用twine把项目打成pip包.md","raw":"---\ntitle: 使用setuptools和twine把项目打成pip包\ndate: 2020-1-25\ncategories: 技术文章\ntags:\n    -Python\n---\n\n本文章是根据根据官方教程在实际后写下的，可以边参考官方教程边阅读本文章，这样可能有助于您理解打包pip软件包\n\n另外本人使用的是Python3，操作可能会和Python2有点不同，同时使用的命令是参考了其他的教程，和官方命令也不太一样，免去了许多参数的选择，更加简单。\n\n如果希望更加全面地理解和打包pip软件包请参考\n\n官方教程：https://packaging.python.org/tutorials/packaging-projects/\n\n需要使用到的东西\n---\n\n两个Python包：setuptools、twine\n\n一个PyPI账号：https://pypi.org/\n\n打一个pip软件包一定要有这两个工具，setuptools用于创建构建脚本，twine用于上传项目，上传的pip包都会放在这里PyPI\n\n打包一个项目的文件结构\n---\n\n```Text\n软件包根目录/\n    打包的项目/\n        __init__.py\n        ...\n    setup.py\n    LICENSE\n    README.md\n```\n\n根目录的名字不知道对项目名有没有影响，我都是直接取发行名称\n\n在这个目录下，最简单的配置包括4个部分：\n\n```Text\n要打包的项目：你准备打包成pip包的项目\nsetup.py：构建脚本，里面写的是软件包的相关信息和代码配置信息\nLICENSE：软件包使用的许可证\nREADME.md：说明文件\n```\n\n打包配置\n---\n\n打包的项目就不说了，可能你是直接打包已有项目，也可能是打算打包从头写的项目，打包的关键步骤主要是setup.py的配置和上传命令的使用，上传项目时软件包的信息都是根据setup里面的配置来上传的\n\n**把官方setup.py的配置简化一下就是以下的样子,三个点代表省略**\n\n```Python\nimport setuptools\n\n# 这里从README导入详细说明\nwith open(\"README.md\", \"r\") as fh:\n    long_description = fh.read()\n\nsetuptools.setup(\n    name=\"example-pkg-YOUR-USERNAME-HERE\", # pip软件包发行的名称\n    version=\"0.0.1\", # 本次上传的版本\n    author=\"Example Author\", # 作者名称\n    author_email=\"author@example.com\", # 作者邮箱\n    description=\"A small example package\", # 软件包摘要\n    long_description=long_description, # 软件包详细说明\n    long_description_content_type=\"text/markdown\", # 引用详细说明的文件格式\n    url=\"https://github.com/pypa/sampleproject\", # 项目的主页地址，大部分是使用该项目在自己代码储存库的地址\n    license=\"MIT\" # 许可证类型\n    packages=setuptools.find_packages(), # 要打包的所有Python包列表\n    # 是列出了你的包的额外元数据，给你的包进行分类，下面的意思是“该软件包仅与Python 3兼容，已获得MIT许可，与操作系统无关”\n    classifiers=[\n        \"Programming Language :: Python :: 3\",\n        \"License :: OSI Approved :: MIT License\",\n        \"Operating System :: OS Independent\",\n    ],\n    # 能够使用你的项目的Python版本\n    python_requires='>=3.6',\n    # 你的项目的依赖项，安装你的软件包时，pip也会自动安装以下依赖项，举个例子--pymysql\n    install_requires = [\n        'pymysql',\n        ...\n    ]\n    ...\n)\n```\n\n**官方全部字段的配置说明：https://packaging.python.org/guides/distributing-packages-using-setuptools/**\n\n**配置文件的时候有几个注意点：**\n**1、上传不同版本的软件包，version要修改，因为生成的压缩包版本后缀是根据这一行配置的**\n**2、packages可以手动列出需要打包的Python包列表，如果使用`find_package()`的话则是脚本自动发现所有软件包和子软件包**\n**3、关于classifiers的配置根据不同项目配置都不一样，参考官方分类器列表：https://pypi.org/classifiers/**\n**4、如果设置了python_requires，那么所有不符合要求的Python版本都会被pip阻止安装这个软件包**\n\n**配置完setup.py，接下来就是根据你的需要选择许可证：https://choosealicense.com/**\n**选择完许可证要把许可证文本写入LICENSE文件，或者也可以在使用GitHub Desktop创建仓库时创建许可证，如果setup.py里有配置license这一项记得修改成对应的类型**\n\n打包\n---\n\n打包前，要先check一下，看看setup的配置是否有效\n\n在软件包根目录使用命令：`setup.py check`\n\n如果只显示了running check就是正常的\n\n如果没问题使用sdist进行打包\n\n`setup.py sdist`\n\n生成的压缩包会放在dist/下面，把这些包上传就完成了，但是上传前还要进行一次检查，看看压缩包是否符合要求\n\n检查命令：`twine check dist/*`\n\n上传命令：`twine upload dist/*`\n\n输入用户名和密码就可以了\n\n**这里也有几个注意点：**\n**1、有些教程会使用`setup.py register`来进行注册上传，但是这个方法其实已经弃用了，官方推荐是直接使用`twine upload`**\n**2、dist/*是指dist下的全部文件，如果上传的压缩包含有以前的版本，因为该版本已经上传过了，会有错误提示，可以把以前版本的压缩包删掉，也可以自己选择上传的包，而不是全部上传**\n**3、我这里没有配置用户文件，配置文件可以免去验证用户的流程**\n**4、官方推荐是注册令牌来代替用户名和密码上传，注册令牌是一种更安全可靠的方式**\n\n如果以上步骤都没问题，你就可以在自己的账号上面看到上传的pip软件包了\n\n——更多内容待更新——\n","slug":"使用twine把项目打成pip包","published":1,"updated":"2020-01-25T08:22:14.137Z","_id":"ck5tbi8xp0000lkv53hvg1xwv","comments":1,"layout":"post","photos":[],"link":"","content":"<p>本文章是根据根据官方教程在实际后写下的，可以边参考官方教程边阅读本文章，这样可能有助于您理解打包pip软件包</p>\n<p>另外本人使用的是Python3，操作可能会和Python2有点不同，同时使用的命令是参考了其他的教程，和官方命令也不太一样，免去了许多参数的选择，更加简单。</p>\n<p>如果希望更加全面地理解和打包pip软件包请参考</p>\n<p>官方教程：<a href=\"https://packaging.python.org/tutorials/packaging-projects/\" target=\"_blank\" rel=\"noopener\">https://packaging.python.org/tutorials/packaging-projects/</a></p>\n<h2 id=\"需要使用到的东西\"><a href=\"#需要使用到的东西\" class=\"headerlink\" title=\"需要使用到的东西\"></a>需要使用到的东西</h2><p>两个Python包：setuptools、twine</p>\n<p>一个PyPI账号：<a href=\"https://pypi.org/\" target=\"_blank\" rel=\"noopener\">https://pypi.org/</a></p>\n<p>打一个pip软件包一定要有这两个工具，setuptools用于创建构建脚本，twine用于上传项目，上传的pip包都会放在这里PyPI</p>\n<h2 id=\"打包一个项目的文件结构\"><a href=\"#打包一个项目的文件结构\" class=\"headerlink\" title=\"打包一个项目的文件结构\"></a>打包一个项目的文件结构</h2><pre><code class=\"Text\">软件包根目录/\n    打包的项目/\n        __init__.py\n        ...\n    setup.py\n    LICENSE\n    README.md</code></pre>\n<p>根目录的名字不知道对项目名有没有影响，我都是直接取发行名称</p>\n<p>在这个目录下，最简单的配置包括4个部分：</p>\n<pre><code class=\"Text\">要打包的项目：你准备打包成pip包的项目\nsetup.py：构建脚本，里面写的是软件包的相关信息和代码配置信息\nLICENSE：软件包使用的许可证\nREADME.md：说明文件</code></pre>\n<h2 id=\"打包配置\"><a href=\"#打包配置\" class=\"headerlink\" title=\"打包配置\"></a>打包配置</h2><p>打包的项目就不说了，可能你是直接打包已有项目，也可能是打算打包从头写的项目，打包的关键步骤主要是setup.py的配置和上传命令的使用，上传项目时软件包的信息都是根据setup里面的配置来上传的</p>\n<p><strong>把官方setup.py的配置简化一下就是以下的样子,三个点代表省略</strong></p>\n<pre><code class=\"Python\">import setuptools\n\n# 这里从README导入详细说明\nwith open(&quot;README.md&quot;, &quot;r&quot;) as fh:\n    long_description = fh.read()\n\nsetuptools.setup(\n    name=&quot;example-pkg-YOUR-USERNAME-HERE&quot;, # pip软件包发行的名称\n    version=&quot;0.0.1&quot;, # 本次上传的版本\n    author=&quot;Example Author&quot;, # 作者名称\n    author_email=&quot;author@example.com&quot;, # 作者邮箱\n    description=&quot;A small example package&quot;, # 软件包摘要\n    long_description=long_description, # 软件包详细说明\n    long_description_content_type=&quot;text/markdown&quot;, # 引用详细说明的文件格式\n    url=&quot;https://github.com/pypa/sampleproject&quot;, # 项目的主页地址，大部分是使用该项目在自己代码储存库的地址\n    license=&quot;MIT&quot; # 许可证类型\n    packages=setuptools.find_packages(), # 要打包的所有Python包列表\n    # 是列出了你的包的额外元数据，给你的包进行分类，下面的意思是“该软件包仅与Python 3兼容，已获得MIT许可，与操作系统无关”\n    classifiers=[\n        &quot;Programming Language :: Python :: 3&quot;,\n        &quot;License :: OSI Approved :: MIT License&quot;,\n        &quot;Operating System :: OS Independent&quot;,\n    ],\n    # 能够使用你的项目的Python版本\n    python_requires=&#39;&gt;=3.6&#39;,\n    # 你的项目的依赖项，安装你的软件包时，pip也会自动安装以下依赖项，举个例子--pymysql\n    install_requires = [\n        &#39;pymysql&#39;,\n        ...\n    ]\n    ...\n)</code></pre>\n<p><strong>官方全部字段的配置说明：<a href=\"https://packaging.python.org/guides/distributing-packages-using-setuptools/\" target=\"_blank\" rel=\"noopener\">https://packaging.python.org/guides/distributing-packages-using-setuptools/</a></strong></p>\n<p><strong>配置文件的时候有几个注意点：</strong><br><strong>1、上传不同版本的软件包，version要修改，因为生成的压缩包版本后缀是根据这一行配置的</strong><br><strong>2、packages可以手动列出需要打包的Python包列表，如果使用<code>find_package()</code>的话则是脚本自动发现所有软件包和子软件包</strong><br><strong>3、关于classifiers的配置根据不同项目配置都不一样，参考官方分类器列表：<a href=\"https://pypi.org/classifiers/\" target=\"_blank\" rel=\"noopener\">https://pypi.org/classifiers/</a></strong><br><strong>4、如果设置了python_requires，那么所有不符合要求的Python版本都会被pip阻止安装这个软件包</strong></p>\n<p><strong>配置完setup.py，接下来就是根据你的需要选择许可证：<a href=\"https://choosealicense.com/\" target=\"_blank\" rel=\"noopener\">https://choosealicense.com/</a></strong><br><strong>选择完许可证要把许可证文本写入LICENSE文件，或者也可以在使用GitHub Desktop创建仓库时创建许可证，如果setup.py里有配置license这一项记得修改成对应的类型</strong></p>\n<h2 id=\"打包\"><a href=\"#打包\" class=\"headerlink\" title=\"打包\"></a>打包</h2><p>打包前，要先check一下，看看setup的配置是否有效</p>\n<p>在软件包根目录使用命令：<code>setup.py check</code></p>\n<p>如果只显示了running check就是正常的</p>\n<p>如果没问题使用sdist进行打包</p>\n<p><code>setup.py sdist</code></p>\n<p>生成的压缩包会放在dist/下面，把这些包上传就完成了，但是上传前还要进行一次检查，看看压缩包是否符合要求</p>\n<p>检查命令：<code>twine check dist/*</code></p>\n<p>上传命令：<code>twine upload dist/*</code></p>\n<p>输入用户名和密码就可以了</p>\n<p><strong>这里也有几个注意点：</strong><br><strong>1、有些教程会使用<code>setup.py register</code>来进行注册上传，但是这个方法其实已经弃用了，官方推荐是直接使用<code>twine upload</code></strong><br><strong>2、dist/*是指dist下的全部文件，如果上传的压缩包含有以前的版本，因为该版本已经上传过了，会有错误提示，可以把以前版本的压缩包删掉，也可以自己选择上传的包，而不是全部上传</strong><br><strong>3、我这里没有配置用户文件，配置文件可以免去验证用户的流程</strong><br><strong>4、官方推荐是注册令牌来代替用户名和密码上传，注册令牌是一种更安全可靠的方式</strong></p>\n<p>如果以上步骤都没问题，你就可以在自己的账号上面看到上传的pip软件包了</p>\n<p>——更多内容待更新——</p>\n","site":{"data":{}},"excerpt":"","more":"<p>本文章是根据根据官方教程在实际后写下的，可以边参考官方教程边阅读本文章，这样可能有助于您理解打包pip软件包</p>\n<p>另外本人使用的是Python3，操作可能会和Python2有点不同，同时使用的命令是参考了其他的教程，和官方命令也不太一样，免去了许多参数的选择，更加简单。</p>\n<p>如果希望更加全面地理解和打包pip软件包请参考</p>\n<p>官方教程：<a href=\"https://packaging.python.org/tutorials/packaging-projects/\" target=\"_blank\" rel=\"noopener\">https://packaging.python.org/tutorials/packaging-projects/</a></p>\n<h2 id=\"需要使用到的东西\"><a href=\"#需要使用到的东西\" class=\"headerlink\" title=\"需要使用到的东西\"></a>需要使用到的东西</h2><p>两个Python包：setuptools、twine</p>\n<p>一个PyPI账号：<a href=\"https://pypi.org/\" target=\"_blank\" rel=\"noopener\">https://pypi.org/</a></p>\n<p>打一个pip软件包一定要有这两个工具，setuptools用于创建构建脚本，twine用于上传项目，上传的pip包都会放在这里PyPI</p>\n<h2 id=\"打包一个项目的文件结构\"><a href=\"#打包一个项目的文件结构\" class=\"headerlink\" title=\"打包一个项目的文件结构\"></a>打包一个项目的文件结构</h2><pre><code class=\"Text\">软件包根目录/\n    打包的项目/\n        __init__.py\n        ...\n    setup.py\n    LICENSE\n    README.md</code></pre>\n<p>根目录的名字不知道对项目名有没有影响，我都是直接取发行名称</p>\n<p>在这个目录下，最简单的配置包括4个部分：</p>\n<pre><code class=\"Text\">要打包的项目：你准备打包成pip包的项目\nsetup.py：构建脚本，里面写的是软件包的相关信息和代码配置信息\nLICENSE：软件包使用的许可证\nREADME.md：说明文件</code></pre>\n<h2 id=\"打包配置\"><a href=\"#打包配置\" class=\"headerlink\" title=\"打包配置\"></a>打包配置</h2><p>打包的项目就不说了，可能你是直接打包已有项目，也可能是打算打包从头写的项目，打包的关键步骤主要是setup.py的配置和上传命令的使用，上传项目时软件包的信息都是根据setup里面的配置来上传的</p>\n<p><strong>把官方setup.py的配置简化一下就是以下的样子,三个点代表省略</strong></p>\n<pre><code class=\"Python\">import setuptools\n\n# 这里从README导入详细说明\nwith open(&quot;README.md&quot;, &quot;r&quot;) as fh:\n    long_description = fh.read()\n\nsetuptools.setup(\n    name=&quot;example-pkg-YOUR-USERNAME-HERE&quot;, # pip软件包发行的名称\n    version=&quot;0.0.1&quot;, # 本次上传的版本\n    author=&quot;Example Author&quot;, # 作者名称\n    author_email=&quot;author@example.com&quot;, # 作者邮箱\n    description=&quot;A small example package&quot;, # 软件包摘要\n    long_description=long_description, # 软件包详细说明\n    long_description_content_type=&quot;text/markdown&quot;, # 引用详细说明的文件格式\n    url=&quot;https://github.com/pypa/sampleproject&quot;, # 项目的主页地址，大部分是使用该项目在自己代码储存库的地址\n    license=&quot;MIT&quot; # 许可证类型\n    packages=setuptools.find_packages(), # 要打包的所有Python包列表\n    # 是列出了你的包的额外元数据，给你的包进行分类，下面的意思是“该软件包仅与Python 3兼容，已获得MIT许可，与操作系统无关”\n    classifiers=[\n        &quot;Programming Language :: Python :: 3&quot;,\n        &quot;License :: OSI Approved :: MIT License&quot;,\n        &quot;Operating System :: OS Independent&quot;,\n    ],\n    # 能够使用你的项目的Python版本\n    python_requires=&#39;&gt;=3.6&#39;,\n    # 你的项目的依赖项，安装你的软件包时，pip也会自动安装以下依赖项，举个例子--pymysql\n    install_requires = [\n        &#39;pymysql&#39;,\n        ...\n    ]\n    ...\n)</code></pre>\n<p><strong>官方全部字段的配置说明：<a href=\"https://packaging.python.org/guides/distributing-packages-using-setuptools/\" target=\"_blank\" rel=\"noopener\">https://packaging.python.org/guides/distributing-packages-using-setuptools/</a></strong></p>\n<p><strong>配置文件的时候有几个注意点：</strong><br><strong>1、上传不同版本的软件包，version要修改，因为生成的压缩包版本后缀是根据这一行配置的</strong><br><strong>2、packages可以手动列出需要打包的Python包列表，如果使用<code>find_package()</code>的话则是脚本自动发现所有软件包和子软件包</strong><br><strong>3、关于classifiers的配置根据不同项目配置都不一样，参考官方分类器列表：<a href=\"https://pypi.org/classifiers/\" target=\"_blank\" rel=\"noopener\">https://pypi.org/classifiers/</a></strong><br><strong>4、如果设置了python_requires，那么所有不符合要求的Python版本都会被pip阻止安装这个软件包</strong></p>\n<p><strong>配置完setup.py，接下来就是根据你的需要选择许可证：<a href=\"https://choosealicense.com/\" target=\"_blank\" rel=\"noopener\">https://choosealicense.com/</a></strong><br><strong>选择完许可证要把许可证文本写入LICENSE文件，或者也可以在使用GitHub Desktop创建仓库时创建许可证，如果setup.py里有配置license这一项记得修改成对应的类型</strong></p>\n<h2 id=\"打包\"><a href=\"#打包\" class=\"headerlink\" title=\"打包\"></a>打包</h2><p>打包前，要先check一下，看看setup的配置是否有效</p>\n<p>在软件包根目录使用命令：<code>setup.py check</code></p>\n<p>如果只显示了running check就是正常的</p>\n<p>如果没问题使用sdist进行打包</p>\n<p><code>setup.py sdist</code></p>\n<p>生成的压缩包会放在dist/下面，把这些包上传就完成了，但是上传前还要进行一次检查，看看压缩包是否符合要求</p>\n<p>检查命令：<code>twine check dist/*</code></p>\n<p>上传命令：<code>twine upload dist/*</code></p>\n<p>输入用户名和密码就可以了</p>\n<p><strong>这里也有几个注意点：</strong><br><strong>1、有些教程会使用<code>setup.py register</code>来进行注册上传，但是这个方法其实已经弃用了，官方推荐是直接使用<code>twine upload</code></strong><br><strong>2、dist/*是指dist下的全部文件，如果上传的压缩包含有以前的版本，因为该版本已经上传过了，会有错误提示，可以把以前版本的压缩包删掉，也可以自己选择上传的包，而不是全部上传</strong><br><strong>3、我这里没有配置用户文件，配置文件可以免去验证用户的流程</strong><br><strong>4、官方推荐是注册令牌来代替用户名和密码上传，注册令牌是一种更安全可靠的方式</strong></p>\n<p>如果以上步骤都没问题，你就可以在自己的账号上面看到上传的pip软件包了</p>\n<p>——更多内容待更新——</p>\n"},{"title":"算法导论python快速排序代码理解","date":"2020-01-24T16:00:00.000Z","_content":"\n写易班2020新年专栏项目的时候，想给文章按照列表里文章的点赞数和评论数的和来从大到小排序，毕竟是网站，为了用户体验，访问速度肯定是不能慢的。\n\n但是Python这语言本身执行效率就堪忧...以前做题目的时候，发现同样是2千万次循环，同样的算法，Java几百毫秒就解决了，Python用了7秒？\n\n想让排序快点就只能选择快速排序了，虽然看学校数据结构的书有看到快速排序的思想，但实际没有去实现过所以去网上找了关于快速排序的Python代码\n\n偶然在一篇文章看到了《算法导论》中的快速排序，当时觉得，哇塞，代码居然这么精简(虽然后来看到了更加精简的代码，我还是太菜了，还够不到大佬的后脚跟~)，当时为了赶时间就从这个代码下手理解了。\n\n```Python\n# 据说是《算法导论》中的快速排序\n\ndef quick_sort(array, l, r):\n    if l < r:\n        q = partition(array, l, r)\n        quick_sort(array, l, q - 1)\n        quick_sort(array, q + 1, r)\n\ndef partition(array, l, r):\n    x = array[r]\n    i = l - 1\n    for j in range(l, r):\n        if array[j] <= x:\n            i += 1\n            array[i], array[j] = array[j], array[i]\n    array[i + 1], array[r] = array[r], array[i + 1]\n    return i + 1\n```\n\n怎么理解这个快速排序的代码呢？\n\n嘛，首先是要知道快速排序的思路，忘记的不知道的先去补课。\n\n从这个代码可以看出，每次排序用了一次循环，代码中的l就是left，r就是right，分别代表操作的列表的左下标和右下标，初始传入的下标就是0和len(array)-1\n\npartition是分片的意思，其实在分片的时候，就是进行了一次排序了。\n\npartition函数中把列表最右边的值作为划分值，交换点下标为传入列表最右边-1，为什么是-1，而不是l呢，因为这个代码后面每一次交换位置分点的下标都会向右移，为了防止漏掉l下标，所以要先减一，第一次交换的时候+1就变成l下标了。当然代码也可以改成下面这种直接把l赋值给i的形式\n\n```Python\ndef partition(array, l, r):\n    x = array[r]\n    i = l\n    for j in range(l, r):\n        if array[j] <= x:\n            array[i], array[j] = array[j], array[i]\n            i += 1\n    array[i], array[r] = array[r], array[i]\n    return i\n```\n\nfor循环是遍历下标从l到r-1的元素，由于下标为r的元素是我们的分片点，所以不需要进行比较，当遍历到的元素值小于划分值，就把这个元素向左边的i移动，这样到最后，所有小于划分值的元素都会在i下标位置的左边，而i下标位置右边的，都是大于划分值的，但是此时i下标的元素仍然是大于划分值的，我们要把划分的元素放到划分点，所以最后要把i下标的元素和划分元素(最右边那个没有被遍历到的元素)交换位置，这样就完成了分片，然后返回分片点的下标，然后回到quick_sort函数继续递归。\n\n在quick_sort函数中的q是partition函数返回是划分点下标，所以已经不需要进行排序了，只需要对分片后的两边列表进行排序就行了，所以调用quick_sort函数(`quick_sort(array, l, q - 1)`和`quick_sort(array, q + 1, r)`)，继续对两边子列表进行排序，直到最后分片的两个元素排序好返回分片点下标，由于就剩下两个元素，所以排序完返回的下标肯定是这两个元素其中一个，这时传入q-1和另外一个下标到quick_sort已经无法满足`if l < r`了，所以该子列表排序完成，结束递归，等所有子列表都排序完，整个列表就从小到大排序好了。\n\n当然我们也可以吧partition里的`<=`改成`>=`，这样就是所有大于划分值的元素都在i下标位置的左边，列表讲从大到小排序。\n\n由于快速排序是原地排序，在Python里直接采取原列表交换元素的方式，按照Python语言的特性不需要进行返回，原本传入的列表就会被排序好，当然也就无法传入元组(tuple)了\n","source":"_posts/算法导论python快速排序代码理解.md","raw":"---\ntitle: 算法导论python快速排序代码理解\ndate: 2020-1-25\ncategories: 学习笔记\ntags:\n    -Python\n---\n\n写易班2020新年专栏项目的时候，想给文章按照列表里文章的点赞数和评论数的和来从大到小排序，毕竟是网站，为了用户体验，访问速度肯定是不能慢的。\n\n但是Python这语言本身执行效率就堪忧...以前做题目的时候，发现同样是2千万次循环，同样的算法，Java几百毫秒就解决了，Python用了7秒？\n\n想让排序快点就只能选择快速排序了，虽然看学校数据结构的书有看到快速排序的思想，但实际没有去实现过所以去网上找了关于快速排序的Python代码\n\n偶然在一篇文章看到了《算法导论》中的快速排序，当时觉得，哇塞，代码居然这么精简(虽然后来看到了更加精简的代码，我还是太菜了，还够不到大佬的后脚跟~)，当时为了赶时间就从这个代码下手理解了。\n\n```Python\n# 据说是《算法导论》中的快速排序\n\ndef quick_sort(array, l, r):\n    if l < r:\n        q = partition(array, l, r)\n        quick_sort(array, l, q - 1)\n        quick_sort(array, q + 1, r)\n\ndef partition(array, l, r):\n    x = array[r]\n    i = l - 1\n    for j in range(l, r):\n        if array[j] <= x:\n            i += 1\n            array[i], array[j] = array[j], array[i]\n    array[i + 1], array[r] = array[r], array[i + 1]\n    return i + 1\n```\n\n怎么理解这个快速排序的代码呢？\n\n嘛，首先是要知道快速排序的思路，忘记的不知道的先去补课。\n\n从这个代码可以看出，每次排序用了一次循环，代码中的l就是left，r就是right，分别代表操作的列表的左下标和右下标，初始传入的下标就是0和len(array)-1\n\npartition是分片的意思，其实在分片的时候，就是进行了一次排序了。\n\npartition函数中把列表最右边的值作为划分值，交换点下标为传入列表最右边-1，为什么是-1，而不是l呢，因为这个代码后面每一次交换位置分点的下标都会向右移，为了防止漏掉l下标，所以要先减一，第一次交换的时候+1就变成l下标了。当然代码也可以改成下面这种直接把l赋值给i的形式\n\n```Python\ndef partition(array, l, r):\n    x = array[r]\n    i = l\n    for j in range(l, r):\n        if array[j] <= x:\n            array[i], array[j] = array[j], array[i]\n            i += 1\n    array[i], array[r] = array[r], array[i]\n    return i\n```\n\nfor循环是遍历下标从l到r-1的元素，由于下标为r的元素是我们的分片点，所以不需要进行比较，当遍历到的元素值小于划分值，就把这个元素向左边的i移动，这样到最后，所有小于划分值的元素都会在i下标位置的左边，而i下标位置右边的，都是大于划分值的，但是此时i下标的元素仍然是大于划分值的，我们要把划分的元素放到划分点，所以最后要把i下标的元素和划分元素(最右边那个没有被遍历到的元素)交换位置，这样就完成了分片，然后返回分片点的下标，然后回到quick_sort函数继续递归。\n\n在quick_sort函数中的q是partition函数返回是划分点下标，所以已经不需要进行排序了，只需要对分片后的两边列表进行排序就行了，所以调用quick_sort函数(`quick_sort(array, l, q - 1)`和`quick_sort(array, q + 1, r)`)，继续对两边子列表进行排序，直到最后分片的两个元素排序好返回分片点下标，由于就剩下两个元素，所以排序完返回的下标肯定是这两个元素其中一个，这时传入q-1和另外一个下标到quick_sort已经无法满足`if l < r`了，所以该子列表排序完成，结束递归，等所有子列表都排序完，整个列表就从小到大排序好了。\n\n当然我们也可以吧partition里的`<=`改成`>=`，这样就是所有大于划分值的元素都在i下标位置的左边，列表讲从大到小排序。\n\n由于快速排序是原地排序，在Python里直接采取原列表交换元素的方式，按照Python语言的特性不需要进行返回，原本传入的列表就会被排序好，当然也就无法传入元组(tuple)了\n","slug":"算法导论python快速排序代码理解","published":1,"updated":"2020-01-25T09:33:58.137Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5tedt7q0000e8v5gfamanyf","content":"<p>写易班2020新年专栏项目的时候，想给文章按照列表里文章的点赞数和评论数的和来从大到小排序，毕竟是网站，为了用户体验，访问速度肯定是不能慢的。</p>\n<p>但是Python这语言本身执行效率就堪忧…以前做题目的时候，发现同样是2千万次循环，同样的算法，Java几百毫秒就解决了，Python用了7秒？</p>\n<p>想让排序快点就只能选择快速排序了，虽然看学校数据结构的书有看到快速排序的思想，但实际没有去实现过所以去网上找了关于快速排序的Python代码</p>\n<p>偶然在一篇文章看到了《算法导论》中的快速排序，当时觉得，哇塞，代码居然这么精简(虽然后来看到了更加精简的代码，我还是太菜了，还够不到大佬的后脚跟~)，当时为了赶时间就从这个代码下手理解了。</p>\n<pre><code class=\"Python\"># 据说是《算法导论》中的快速排序\n\ndef quick_sort(array, l, r):\n    if l &lt; r:\n        q = partition(array, l, r)\n        quick_sort(array, l, q - 1)\n        quick_sort(array, q + 1, r)\n\ndef partition(array, l, r):\n    x = array[r]\n    i = l - 1\n    for j in range(l, r):\n        if array[j] &lt;= x:\n            i += 1\n            array[i], array[j] = array[j], array[i]\n    array[i + 1], array[r] = array[r], array[i + 1]\n    return i + 1</code></pre>\n<p>怎么理解这个快速排序的代码呢？</p>\n<p>嘛，首先是要知道快速排序的思路，忘记的不知道的先去补课。</p>\n<p>从这个代码可以看出，每次排序用了一次循环，代码中的l就是left，r就是right，分别代表操作的列表的左下标和右下标，初始传入的下标就是0和len(array)-1</p>\n<p>partition是分片的意思，其实在分片的时候，就是进行了一次排序了。</p>\n<p>partition函数中把列表最右边的值作为划分值，交换点下标为传入列表最右边-1，为什么是-1，而不是l呢，因为这个代码后面每一次交换位置分点的下标都会向右移，为了防止漏掉l下标，所以要先减一，第一次交换的时候+1就变成l下标了。当然代码也可以改成下面这种直接把l赋值给i的形式</p>\n<pre><code class=\"Python\">def partition(array, l, r):\n    x = array[r]\n    i = l\n    for j in range(l, r):\n        if array[j] &lt;= x:\n            array[i], array[j] = array[j], array[i]\n            i += 1\n    array[i], array[r] = array[r], array[i]\n    return i</code></pre>\n<p>for循环是遍历下标从l到r-1的元素，由于下标为r的元素是我们的分片点，所以不需要进行比较，当遍历到的元素值小于划分值，就把这个元素向左边的i移动，这样到最后，所有小于划分值的元素都会在i下标位置的左边，而i下标位置右边的，都是大于划分值的，但是此时i下标的元素仍然是大于划分值的，我们要把划分的元素放到划分点，所以最后要把i下标的元素和划分元素(最右边那个没有被遍历到的元素)交换位置，这样就完成了分片，然后返回分片点的下标，然后回到quick_sort函数继续递归。</p>\n<p>在quick_sort函数中的q是partition函数返回是划分点下标，所以已经不需要进行排序了，只需要对分片后的两边列表进行排序就行了，所以调用quick_sort函数(<code>quick_sort(array, l, q - 1)</code>和<code>quick_sort(array, q + 1, r)</code>)，继续对两边子列表进行排序，直到最后分片的两个元素排序好返回分片点下标，由于就剩下两个元素，所以排序完返回的下标肯定是这两个元素其中一个，这时传入q-1和另外一个下标到quick_sort已经无法满足<code>if l &lt; r</code>了，所以该子列表排序完成，结束递归，等所有子列表都排序完，整个列表就从小到大排序好了。</p>\n<p>当然我们也可以吧partition里的<code>&lt;=</code>改成<code>&gt;=</code>，这样就是所有大于划分值的元素都在i下标位置的左边，列表讲从大到小排序。</p>\n<p>由于快速排序是原地排序，在Python里直接采取原列表交换元素的方式，按照Python语言的特性不需要进行返回，原本传入的列表就会被排序好，当然也就无法传入元组(tuple)了</p>\n","site":{"data":{}},"excerpt":"","more":"<p>写易班2020新年专栏项目的时候，想给文章按照列表里文章的点赞数和评论数的和来从大到小排序，毕竟是网站，为了用户体验，访问速度肯定是不能慢的。</p>\n<p>但是Python这语言本身执行效率就堪忧…以前做题目的时候，发现同样是2千万次循环，同样的算法，Java几百毫秒就解决了，Python用了7秒？</p>\n<p>想让排序快点就只能选择快速排序了，虽然看学校数据结构的书有看到快速排序的思想，但实际没有去实现过所以去网上找了关于快速排序的Python代码</p>\n<p>偶然在一篇文章看到了《算法导论》中的快速排序，当时觉得，哇塞，代码居然这么精简(虽然后来看到了更加精简的代码，我还是太菜了，还够不到大佬的后脚跟~)，当时为了赶时间就从这个代码下手理解了。</p>\n<pre><code class=\"Python\"># 据说是《算法导论》中的快速排序\n\ndef quick_sort(array, l, r):\n    if l &lt; r:\n        q = partition(array, l, r)\n        quick_sort(array, l, q - 1)\n        quick_sort(array, q + 1, r)\n\ndef partition(array, l, r):\n    x = array[r]\n    i = l - 1\n    for j in range(l, r):\n        if array[j] &lt;= x:\n            i += 1\n            array[i], array[j] = array[j], array[i]\n    array[i + 1], array[r] = array[r], array[i + 1]\n    return i + 1</code></pre>\n<p>怎么理解这个快速排序的代码呢？</p>\n<p>嘛，首先是要知道快速排序的思路，忘记的不知道的先去补课。</p>\n<p>从这个代码可以看出，每次排序用了一次循环，代码中的l就是left，r就是right，分别代表操作的列表的左下标和右下标，初始传入的下标就是0和len(array)-1</p>\n<p>partition是分片的意思，其实在分片的时候，就是进行了一次排序了。</p>\n<p>partition函数中把列表最右边的值作为划分值，交换点下标为传入列表最右边-1，为什么是-1，而不是l呢，因为这个代码后面每一次交换位置分点的下标都会向右移，为了防止漏掉l下标，所以要先减一，第一次交换的时候+1就变成l下标了。当然代码也可以改成下面这种直接把l赋值给i的形式</p>\n<pre><code class=\"Python\">def partition(array, l, r):\n    x = array[r]\n    i = l\n    for j in range(l, r):\n        if array[j] &lt;= x:\n            array[i], array[j] = array[j], array[i]\n            i += 1\n    array[i], array[r] = array[r], array[i]\n    return i</code></pre>\n<p>for循环是遍历下标从l到r-1的元素，由于下标为r的元素是我们的分片点，所以不需要进行比较，当遍历到的元素值小于划分值，就把这个元素向左边的i移动，这样到最后，所有小于划分值的元素都会在i下标位置的左边，而i下标位置右边的，都是大于划分值的，但是此时i下标的元素仍然是大于划分值的，我们要把划分的元素放到划分点，所以最后要把i下标的元素和划分元素(最右边那个没有被遍历到的元素)交换位置，这样就完成了分片，然后返回分片点的下标，然后回到quick_sort函数继续递归。</p>\n<p>在quick_sort函数中的q是partition函数返回是划分点下标，所以已经不需要进行排序了，只需要对分片后的两边列表进行排序就行了，所以调用quick_sort函数(<code>quick_sort(array, l, q - 1)</code>和<code>quick_sort(array, q + 1, r)</code>)，继续对两边子列表进行排序，直到最后分片的两个元素排序好返回分片点下标，由于就剩下两个元素，所以排序完返回的下标肯定是这两个元素其中一个，这时传入q-1和另外一个下标到quick_sort已经无法满足<code>if l &lt; r</code>了，所以该子列表排序完成，结束递归，等所有子列表都排序完，整个列表就从小到大排序好了。</p>\n<p>当然我们也可以吧partition里的<code>&lt;=</code>改成<code>&gt;=</code>，这样就是所有大于划分值的元素都在i下标位置的左边，列表讲从大到小排序。</p>\n<p>由于快速排序是原地排序，在Python里直接采取原列表交换元素的方式，按照Python语言的特性不需要进行返回，原本传入的列表就会被排序好，当然也就无法传入元组(tuple)了</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"ck5qvznmn0002gcv59ha799s1","category_id":"ck5qvznmu0004gcv54ryvhy4u","_id":"ck5qvznnz000kgcv53wt82z9i"},{"post_id":"ck5qvznns000igcv5530u8tuw","category_id":"ck5qvznnp000fgcv5620l0wus","_id":"ck5qvzno4000pgcv590ir588o"},{"post_id":"ck5qvznmz0006gcv55dr166zl","category_id":"ck5qvznnp000fgcv5620l0wus","_id":"ck5qvzno5000sgcv53dz8cnlp"},{"post_id":"ck5qvznn30007gcv5hlyu98u2","category_id":"ck5qvzno0000mgcv5adtcefzz","_id":"ck5qvzno7000vgcv5bk2z3spr"},{"post_id":"ck5qvznn70008gcv532ke5nqg","category_id":"ck5qvznnp000fgcv5620l0wus","_id":"ck5qvznoa000xgcv5g3oxfmtm"},{"post_id":"ck5qvznni000cgcv55oxq19gz","category_id":"ck5qvznnp000fgcv5620l0wus","_id":"ck5qvznod000ygcv5817udgc4"},{"post_id":"ck5qvznnm000egcv5bt9l6uet","category_id":"ck5qvznnp000fgcv5620l0wus","_id":"ck5qvznog000zgcv5b4sp2xfv"},{"post_id":"ck5rmu7tx00005cv5edkgcdou","category_id":"ck5rmu7us00015cv5e52abcxy","_id":"ck5rmu7v000025cv55e0506wg"},{"post_id":"ck5tbi8xp0000lkv53hvg1xwv","category_id":"ck5qvzno0000mgcv5adtcefzz","_id":"ck5tbi8y30001lkv5hnvd4579"},{"post_id":"ck5qvznm60000gcv55by36f6n","category_id":"ck5qvzno0000mgcv5adtcefzz","_id":"ck5tbi8y40002lkv58w7q6cgv"},{"post_id":"ck5tedt7q0000e8v5gfamanyf","category_id":"ck5qvznnp000fgcv5620l0wus","_id":"ck5tedt8d0002e8v5btdkeg75"}],"PostTag":[{"post_id":"ck5qvznn30007gcv5hlyu98u2","tag_id":"ck5qvznmy0005gcv5ga2t8ajm","_id":"ck5qvznnh000bgcv51e548nuu"},{"post_id":"ck5qvznm60000gcv55by36f6n","tag_id":"ck5qvznmy0005gcv5ga2t8ajm","_id":"ck5qvznnl000dgcv5ffo7gd1r"},{"post_id":"ck5qvznmn0002gcv59ha799s1","tag_id":"ck5qvznna000agcv5ahfi7xxg","_id":"ck5qvznnw000jgcv57wpbdckc"},{"post_id":"ck5qvznnm000egcv5bt9l6uet","tag_id":"ck5qvznmy0005gcv5ga2t8ajm","_id":"ck5qvznnz000lgcv58kprdnve"},{"post_id":"ck5qvznns000igcv5530u8tuw","tag_id":"ck5qvznmy0005gcv5ga2t8ajm","_id":"ck5qvzno3000ogcv5hd390gle"},{"post_id":"ck5qvznmz0006gcv55dr166zl","tag_id":"ck5qvznnq000hgcv59bgm1w9p","_id":"ck5qvzno4000qgcv5ffrf9voc"},{"post_id":"ck5qvznn70008gcv532ke5nqg","tag_id":"ck5qvzno1000ngcv511xg2xae","_id":"ck5qvzno6000tgcv59ive1x70"},{"post_id":"ck5tedt7q0000e8v5gfamanyf","tag_id":"ck5qvznmy0005gcv5ga2t8ajm","_id":"ck5tedt8c0001e8v5hkplbrp3"},{"post_id":"ck5tbi8xp0000lkv53hvg1xwv","tag_id":"ck5qvznmy0005gcv5ga2t8ajm","_id":"ck5tedt8j0003e8v562q376j6"}],"Tag":[{"name":"-Python","_id":"ck5qvznmy0005gcv5ga2t8ajm"},{"name":"-博客","_id":"ck5qvznna000agcv5ahfi7xxg"},{"name":"-深度学习 -神经网络","_id":"ck5qvznnq000hgcv59bgm1w9p"},{"name":"-MySQL","_id":"ck5qvzno1000ngcv511xg2xae"},{"name":"-Flask","_id":"ck5r0gw8s00003cv5bh31e7jn"}]}}