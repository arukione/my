{"meta":{"version":1,"warehouse":"3.0.1"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/images/avatar.png","path":"images/avatar.png","modified":0,"renderable":0},{"_id":"themes/3-hexo/source/css/custom.css","path":"css/custom.css","modified":0,"renderable":1},{"_id":"source/images/Python特性/TypeError1.png","path":"images/Python特性/TypeError1.png","modified":0,"renderable":0},{"_id":"source/images/Python特性/dynamic1.png","path":"images/Python特性/dynamic1.png","modified":0,"renderable":0},{"_id":"source/images/Python特性/dynamic2.png","path":"images/Python特性/dynamic2.png","modified":0,"renderable":0},{"_id":"source/images/Python特性/dynamic3.png","path":"images/Python特性/dynamic3.png","modified":0,"renderable":0},{"_id":"source/images/Python特性/dynamic4.png","path":"images/Python特性/dynamic4.png","modified":0,"renderable":0},{"_id":"source/images/Python特性/introduce.png","path":"images/Python特性/introduce.png","modified":0,"renderable":0},{"_id":"themes/3-hexo/source/css/gitalk.css","path":"css/gitalk.css","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/mobile.styl","path":"css/mobile.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/js/iconfont.js","path":"js/iconfont.js","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/js/jquery.pjax.js","path":"js/jquery.pjax.js","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/js/jquery.autocomplete.min.js","path":"js/jquery.autocomplete.min.js","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/js/search.js","path":"js/search.js","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/js/script.js","path":"js/script.js","modified":0,"renderable":1},{"_id":"source/images/数据结构基础/数据逻辑结构层次图.jpg","path":"images/数据结构基础/数据逻辑结构层次图.jpg","modified":0,"renderable":0},{"_id":"themes/3-hexo/source/img/alipay.jpg","path":"img/alipay.jpg","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/img/article-list-background.jpg","path":"img/article-list-background.jpg","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/img/weixin.jpg","path":"img/weixin.jpg","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/icomoon.eot","path":"css/fonts/icomoon.eot","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/icomoon.svg","path":"css/fonts/icomoon.svg","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/icomoon.ttf","path":"css/fonts/icomoon.ttf","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/icomoon.woff","path":"css/fonts/icomoon.woff","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/iconfont.eot","path":"css/fonts/iconfont.eot","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/iconfont.svg","path":"css/fonts/iconfont.svg","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/iconfont.ttf","path":"css/fonts/iconfont.ttf","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/iconfont.woff","path":"css/fonts/iconfont.woff","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/atom-dark.styl","path":"css/hl_theme/atom-dark.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/selection.json","path":"css/fonts/selection.json","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/brown-paper.styl","path":"css/hl_theme/brown-paper.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/atom-light.styl","path":"css/hl_theme/atom-light.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/darcula.styl","path":"css/hl_theme/darcula.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/github-gist.styl","path":"css/hl_theme/github-gist.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/github.styl","path":"css/hl_theme/github.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/gruvbox-dark.styl","path":"css/hl_theme/gruvbox-dark.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/gruvbox-light.styl","path":"css/hl_theme/gruvbox-light.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/kimbie-dark.styl","path":"css/hl_theme/kimbie-dark.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/kimbie-light.styl","path":"css/hl_theme/kimbie-light.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/railscasts.styl","path":"css/hl_theme/railscasts.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/rainbow.styl","path":"css/hl_theme/rainbow.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/school-book.styl","path":"css/hl_theme/school-book.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/sublime.styl","path":"css/hl_theme/sublime.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/sunburst.styl","path":"css/hl_theme/sunburst.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/zenbum.styl","path":"css/hl_theme/zenbum.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/js/gitment.js","path":"js/gitment.js","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/js/gitalk.js","path":"js/gitalk.js","modified":0,"renderable":1},{"_id":"source/images/t7s2020/KV-2017.jpg","path":"images/t7s2020/KV-2017.jpg","modified":0,"renderable":0},{"_id":"source/images/t7s2020/KV-2020.jpg","path":"images/t7s2020/KV-2020.jpg","modified":0,"renderable":0},{"_id":"source/images/t7s2020/KV-2015.jpg","path":"images/t7s2020/KV-2015.jpg","modified":0,"renderable":0},{"_id":"source/images/t7s2020/KV-2014.jpg","path":"images/t7s2020/KV-2014.jpg","modified":0,"renderable":0},{"_id":"themes/3-hexo/source/img/preview.png","path":"img/preview.png","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/img/article.jpg","path":"img/article.jpg","modified":0,"renderable":1},{"_id":"source/images/t7s2020/E5-2.jpg","path":"images/t7s2020/E5-2.jpg","modified":0,"renderable":0},{"_id":"source/images/t7s2020/E5-3.jpg","path":"images/t7s2020/E5-3.jpg","modified":0,"renderable":0},{"_id":"source/images/t7s2020/E5-1.jpg","path":"images/t7s2020/E5-1.jpg","modified":0,"renderable":0},{"_id":"source/images/t7s2020/letter.jpg","path":"images/t7s2020/letter.jpg","modified":0,"renderable":0}],"Cache":[{"_id":"source/CNAME","hash":"440ddcd92585f97aa09ec6414ee6c46599ff9ea3","modified":1568529324463},{"_id":"themes/3-hexo/.DS_Store","hash":"0770f9d42bfdd8d420de48fed463015e001cf579","modified":1578923033834},{"_id":"themes/3-hexo/README.md","hash":"754d6f873d73f4a7faf5530fa4062e9a696a8fd4","modified":1578923033839},{"_id":"themes/3-hexo/_config.yml","hash":"bffd52a9ae29a9dcfc65217bf64e417babf9117c","modified":1582455103854},{"_id":"themes/3-hexo/.gitignore","hash":"560a43fddfe4559ed1a17e7362874454519f189b","modified":1578923033837},{"_id":"source/about/index.md","hash":"6b3dc656908d5673b61f1eaa0169538e29c191be","modified":1581920624159},{"_id":"source/_posts/2020.2.6 Java学习笔记.md","hash":"9f43b3fae67c679a3847a6e450ee31793161e7cb","modified":1580973532439},{"_id":"source/_posts/MySQL安装到登陆的问题.md","hash":"375070b75710b7957f0f0f7c3c00dd2030e05be8","modified":1580967483441},{"_id":"source/_posts/Nginx性能优化-worke进程.md","hash":"a210d84e7d5208792b0afdb3bcebeb1cdb401573","modified":1581164904832},{"_id":"source/_posts/python程序打包成exe文件.md","hash":"612b9eafa66ce8f9646b9768e2ae509bc94d0914","modified":1580979800627},{"_id":"source/_posts/t7s六周年.md","hash":"2db342f5abab3ce6f8f503a5a037a21c7492240a","modified":1582454788441},{"_id":"source/_posts/使用Hexo-NexT时遇到的问题.md","hash":"834d11af2e22b5f990e939a9d49e4e35cd26b360","modified":1580980785729},{"_id":"source/_posts/使用twine把项目打成pip包.md","hash":"64cd953868915eff3f7823320abf305d44754342","modified":1580980652281},{"_id":"source/_posts/关于沉迷于东方Project这件事.md","hash":"658162b651f2b741db5ced59568e16baee5a5289","modified":1580979373642},{"_id":"source/_posts/强类型与动态类型的Python.md","hash":"801da627056f9c029be1e58f861d522255238c02","modified":1580323331373},{"_id":"source/_posts/基于operator构建的Nested-List.md","hash":"8f1915aac3bd447b0bd5e84815e324c50e6ad496","modified":1580446129195},{"_id":"source/_posts/数据结构基础.md","hash":"caba70ecda16ff2ddb33e85032adb857b007469f","modified":1582448746211},{"_id":"source/_posts/用于小型网站后端的Web-MySQL.md","hash":"f0a1df16be155616992a230ad0522590d02ae075","modified":1580736734340},{"_id":"source/_posts/机器学习资源分享.md","hash":"82783f41ea5412a8e8d860ee6c7ef2a043c9e958","modified":1580980548183},{"_id":"source/_posts/算法导论python快速排序代码理解.md","hash":"e6959da00a87d9ccc89294cd951c8c18968790ef","modified":1580323352658},{"_id":"source/_posts/用树结构获取自然数拆分结果.md","hash":"25c639294cbb8ec36e3a7134f3b99e4c7de380fb","modified":1580967294240},{"_id":"source/_posts/用树结构获取字符排列组合.md","hash":"4398923c189a6c049ed6d8bb751478d348742689","modified":1580967304187},{"_id":"source/_posts/蓝桥杯B组试题B：年号字串.md","hash":"cd12ecf85c3ee590a1b3ef1aa20f2e1c73f8524a","modified":1580982062587},{"_id":"source/_posts/闲着没事造轮子.md","hash":"d2a4def884fe3067f356cef9693a617eec32eee7","modified":1580407766726},{"_id":"source/images/avatar.png","hash":"a30b0de04ca86766504064fdfcfc7b3d7df934b9","modified":1582454236237},{"_id":"source/install/index.md","hash":"7cce4fb216f614793757ec18c0c310e9acde4734","modified":1580010262309},{"_id":"source/journey/index.md","hash":"f32732a1b0b5b75ad447ce9b668c9ea1b617bb57","modified":1582991858220},{"_id":"source/tags/index.md","hash":"9b2a982e4c99510b905657e3f265b1ed31c9fd83","modified":1579763726790},{"_id":"themes/3-hexo/layout/index.ejs","hash":"99aecf628b29c3345ddf819fe3d26e88788600ea","modified":1578923033915},{"_id":"themes/3-hexo/layout/indexs.md","hash":"f3e89ee3668bfe3e9ea05952de526f6cbab5d2fc","modified":1581920842542},{"_id":"themes/3-hexo/layout/post.ejs","hash":"aeda285031ba8d4e94225e82b364bcf5f79fce1d","modified":1578923033921},{"_id":"themes/3-hexo/source/.DS_Store","hash":"fdcc907c46e093a14b153c5dc8c038461997ed3c","modified":1578923033930},{"_id":"themes/3-hexo/source/css/custom.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1579768370912},{"_id":"source/images/Python特性/TypeError1.png","hash":"3bee26a28c50c682d37353c54c744db7400cd199","modified":1579763415371},{"_id":"source/images/Python特性/dynamic1.png","hash":"7cfda8f81fdb8694d258c841fe8686bfe38962b7","modified":1579763431604},{"_id":"source/images/Python特性/dynamic2.png","hash":"cae1d97b658295f80fc8db83559ec3e187e82ccc","modified":1579763439186},{"_id":"source/images/Python特性/dynamic3.png","hash":"e857dffd839825e4c728826c2b5e4fc9e31e67bc","modified":1579763444001},{"_id":"source/images/Python特性/dynamic4.png","hash":"a05bce4e0d48e3a0cabc8002f2312df0510af1b7","modified":1579763452161},{"_id":"source/images/Python特性/introduce.png","hash":"dca90e3f78c4c98397a89d5794bbcd1ce88fac53","modified":1579763459122},{"_id":"themes/3-hexo/layout/_partial/article.ejs","hash":"0ccec30a2a6799451afe9a213fa5310d1ad06c0d","modified":1578923033850},{"_id":"themes/3-hexo/layout/_partial/article_copyright.ejs","hash":"e46b7a68a5cd417330cca6fb5a5e65855fbed77b","modified":1578923033853},{"_id":"themes/3-hexo/layout/_partial/comment.ejs","hash":"d18f94e04ef0cf7abb432a8e707ccb3abc7fe435","modified":1578923033857},{"_id":"themes/3-hexo/layout/_partial/copyright.ejs","hash":"faffe25aec33936fa2ec9d8f0e34e16ef3d90c25","modified":1578923033875},{"_id":"themes/3-hexo/layout/_partial/dashang.ejs","hash":"c41a62155c416ca7d4bd90a7e2cd0ec06f174ab6","modified":1578923033878},{"_id":"themes/3-hexo/layout/_partial/footer.ejs","hash":"b8444ec0ce36ffc2e06510502c9eec2840954616","modified":1578923033883},{"_id":"themes/3-hexo/layout/_partial/friends.ejs","hash":"558a3d4bad578819fb07729fe1b50d9b81da8b93","modified":1578923033889},{"_id":"themes/3-hexo/layout/_partial/full-toc.ejs","hash":"38285b8d5272a14bfa4769163c8d569abff4c95f","modified":1578923033892},{"_id":"themes/3-hexo/layout/_partial/mathjax.ejs","hash":"e2be0e37f3d48e63e65a47d819bfb800b9aa3784","modified":1578923033898},{"_id":"themes/3-hexo/layout/_partial/nav-left.ejs","hash":"c14bc1393f779dff7854089621804dceea236d82","modified":1578923033903},{"_id":"themes/3-hexo/layout/_partial/meta.ejs","hash":"ef387e80043b62e1925a068267f2377cac64adc7","modified":1578923033900},{"_id":"themes/3-hexo/layout/_partial/header.ejs","hash":"915d5f10dd8f3dcd19cb75010e23689e8f385caf","modified":1578923033894},{"_id":"themes/3-hexo/layout/_partial/nav-right.ejs","hash":"98326675546fc6828a45e8b95250899b4ee2d821","modified":1578923033906},{"_id":"themes/3-hexo/layout/_partial/tag.ejs","hash":"d4b69b53e15abe71d2abeaff8eefa7695c12f0f6","modified":1578923033910},{"_id":"themes/3-hexo/layout/_partial/toc-ref.ejs","hash":"33f7a4bfca1bb9835ec8f0d1e73188d1f56cc8b9","modified":1578923033912},{"_id":"themes/3-hexo/source/css/gitalk.css","hash":"3dc58e9a3fd63a3144d5fe850eb55e3dc885c9fb","modified":1578923034009},{"_id":"themes/3-hexo/source/css/mobile.styl","hash":"b1e082a1b3a96842e1943edab2c1827d6a1ce85a","modified":1581167561638},{"_id":"themes/3-hexo/source/css/style.styl","hash":"4e02689474ac6e39ea404be5a46b96c63923652a","modified":1579786767197},{"_id":"themes/3-hexo/source/js/iconfont.js","hash":"3a0869ca1b09af07d82987e343a3bc4cb9558ecb","modified":1578923034134},{"_id":"themes/3-hexo/source/js/jquery.pjax.js","hash":"8c2a4f10a4da3d9615a3a81542494c6d21479b3d","modified":1578923034142},{"_id":"themes/3-hexo/source/js/jquery.autocomplete.min.js","hash":"2462169ad7f4a8ae9f9f4063995cbe7fed45cd77","modified":1578923034138},{"_id":"themes/3-hexo/source/js/search.js","hash":"788c610149a5f9361295f9f0207c8523f37ddb8b","modified":1578923034152},{"_id":"themes/3-hexo/source/js/script.js","hash":"14772b08b9c3d5c99a4b54748be9666deaae2778","modified":1578923034147},{"_id":"source/images/数据结构基础/数据逻辑结构层次图.jpg","hash":"12d91d50cfa6c3f47248332e16094adc5165e7c4","modified":1579800039620},{"_id":"themes/3-hexo/source/img/alipay.jpg","hash":"e70a57b660caa38f36f30794e8d657a218841fd5","modified":1579759706462},{"_id":"themes/3-hexo/source/img/article-list-background.jpg","hash":"b579af6819ee49d524b074167201adef09575629","modified":1579792141978},{"_id":"themes/3-hexo/source/img/weixin.jpg","hash":"f536bdbf78f988e57562f715c0a5b96b6cde4bba","modified":1579759766148},{"_id":"themes/3-hexo/layout/_partial/comments/click2show.ejs","hash":"05b09c45b379ffeb4f48c1604044d88829f90799","modified":1578923033862},{"_id":"themes/3-hexo/layout/_partial/comments/disqus.ejs","hash":"32ce7b48d366b9c888ff2ceb911a3cd82f864537","modified":1578923033865},{"_id":"themes/3-hexo/layout/_partial/comments/gitalk.ejs","hash":"01567e010cf4f2dd141fe2019490d3f0d5aa2529","modified":1578923033870},{"_id":"themes/3-hexo/layout/_partial/comments/gentie.ejs","hash":"908d9046502612d24780ca354bd9392a009b4d7b","modified":1578923033868},{"_id":"themes/3-hexo/layout/_partial/comments/gitment.ejs","hash":"eaf2b6f297282606b630ad55fb9e38af7e2829dc","modified":1578923033873},{"_id":"themes/3-hexo/source/css/_partial/comment.styl","hash":"fe00fb1269b4fe1f3d5ab917891926222ce47275","modified":1578923033938},{"_id":"themes/3-hexo/source/css/_partial/dashang.styl","hash":"f0eac1dc1f5dbed1769d032bb5fd5f002faaee26","modified":1578923033941},{"_id":"themes/3-hexo/source/css/_partial/autocomplete.styl","hash":"1ffe51e3b77afefcd94d386a718506d5b055ad94","modified":1578923033935},{"_id":"themes/3-hexo/source/css/_partial/fade.styl","hash":"02c7510a26f306e240f23ddbf772a69be2c890dd","modified":1578923033944},{"_id":"themes/3-hexo/source/css/_partial/font.styl","hash":"d14328a267248fa8bc5f877f32eb5baafb1eaaea","modified":1579781522396},{"_id":"themes/3-hexo/source/css/_partial/full-toc.styl","hash":"4102753dad0cc1ee9ed673f7253ba097a960c3b7","modified":1578923033950},{"_id":"themes/3-hexo/source/css/_partial/nav-left.styl","hash":"25076e6360293f44c5251ac8dbbee52391d7d9a0","modified":1581166899275},{"_id":"themes/3-hexo/source/css/_partial/nprogress.styl","hash":"2620a02169a6aeb75137fd368eac2c36423d8498","modified":1578923033963},{"_id":"themes/3-hexo/source/css/_partial/nav-right.styl","hash":"8f138dc674c995d7c24899e7aa6ae4c8ee1fce0e","modified":1581166179826},{"_id":"themes/3-hexo/source/css/_partial/post.styl","hash":"a6838250bbe91026788aa87084dee4210099a981","modified":1581149795698},{"_id":"themes/3-hexo/source/css/_partial/num-load.styl","hash":"f7ef35459ece22e1da950b86126be1c2bfe97fcf","modified":1578923033966},{"_id":"themes/3-hexo/source/css/fonts/icomoon.eot","hash":"b6195bedc1cb2f9cfcb26cc27021f2e94be2ab0a","modified":1578923033974},{"_id":"themes/3-hexo/source/css/fonts/icomoon.svg","hash":"b5e7562c8494b0ddb3a70ecc5545ef7340d8e971","modified":1578923033978},{"_id":"themes/3-hexo/source/css/fonts/icomoon.ttf","hash":"eb976d8b8559fcddfc2658a03a4350cb566fc06b","modified":1578923033981},{"_id":"themes/3-hexo/source/css/fonts/icomoon.woff","hash":"3985d29416bb9b19f50a2f20f2bbbce47f10af8d","modified":1578923033984},{"_id":"themes/3-hexo/source/css/fonts/iconfont.eot","hash":"3dfe8e557d9dfaf39bca088a02b76deb82dbaa3d","modified":1578923033987},{"_id":"themes/3-hexo/source/css/fonts/iconfont.svg","hash":"7e54ae44c02faa319c4fe128e1e6bda38eae5c9d","modified":1578923033991},{"_id":"themes/3-hexo/source/css/fonts/iconfont.ttf","hash":"aa087561480fb9c2cfd541e33d1e99d5ac1a56bb","modified":1578923033999},{"_id":"themes/3-hexo/source/css/fonts/iconfont.woff","hash":"f8ed131ccf13f4bdd3ec11fc3e997339dd7b66ba","modified":1578923034002},{"_id":"themes/3-hexo/source/css/hl_theme/atom-dark.styl","hash":"f3eb4e5feda9cbd6242ccf44ca064e2979b5d719","modified":1578923034014},{"_id":"themes/3-hexo/source/css/fonts/selection.json","hash":"b6456a4eabcffd95e822d1d7adce96da524d481a","modified":1578923034006},{"_id":"themes/3-hexo/source/css/hl_theme/brown-paper.styl","hash":"03af387edcc1cf8c18d12e9c440fd51b6cf425b6","modified":1578923034021},{"_id":"themes/3-hexo/source/css/hl_theme/atom-light.styl","hash":"69d184a682bcaeba2b180b437dc4431bc3be38aa","modified":1578923034018},{"_id":"themes/3-hexo/source/css/hl_theme/darcula.styl","hash":"2bfc14f27ccca108b4b3755782de8366e8bd001e","modified":1578923034024},{"_id":"themes/3-hexo/source/css/hl_theme/github-gist.styl","hash":"5e05b19832c1099bd9d284bc3ed00dc8a3d7ee23","modified":1578923034029},{"_id":"themes/3-hexo/source/css/hl_theme/github.styl","hash":"53276ff1f224f691dfe811e82c0af7f4476abf5d","modified":1578923034032},{"_id":"themes/3-hexo/source/css/hl_theme/gruvbox-dark.styl","hash":"315ad610d303caba9eac80a7d51002193a15478a","modified":1578923034036},{"_id":"themes/3-hexo/source/css/hl_theme/gruvbox-light.styl","hash":"1bece084b1dbbbd4af064f05feffd8c332b96a48","modified":1578923034038},{"_id":"themes/3-hexo/source/css/hl_theme/kimbie-dark.styl","hash":"e9c190f9ffc37a13cac430512e4e0c760205be4a","modified":1578923034041},{"_id":"themes/3-hexo/source/css/hl_theme/kimbie-light.styl","hash":"0c3ccd0d64e7504c7061d246dc32737f502f64e4","modified":1578923034045},{"_id":"themes/3-hexo/source/css/hl_theme/railscasts.styl","hash":"a6e8cfd2202afd7893f5268f3437421e35066e7b","modified":1578923034047},{"_id":"themes/3-hexo/source/css/hl_theme/rainbow.styl","hash":"e5c37646a9d9c1094f9aab7a7c65a4b242e8db00","modified":1578923034052},{"_id":"themes/3-hexo/source/css/hl_theme/school-book.styl","hash":"51659351b391a2be5c68728bb51b7ad467c5e0db","modified":1578923034055},{"_id":"themes/3-hexo/source/css/hl_theme/sublime.styl","hash":"501d75ef0f4385bea24d9b9b4cc434ba68d4be27","modified":1578923034058},{"_id":"themes/3-hexo/source/css/hl_theme/sunburst.styl","hash":"2aa9817e68fb2ed216781ea04b733039ebe18214","modified":1578923034062},{"_id":"themes/3-hexo/source/css/hl_theme/zenbum.styl","hash":"92941a6ae73b74f44ad7c559c5548c44073c644a","modified":1578923034065},{"_id":"themes/3-hexo/source/js/gitment.js","hash":"67984b83cd46ff4300d4fd959bf6c17dd66b4136","modified":1578923034131},{"_id":"themes/3-hexo/source/install/AS SSD Benchmark.zip","hash":"818c029f1ec61f52da994a8b0eafe1654417f1f1","modified":1580009127286},{"_id":"themes/3-hexo/source/js/gitalk.js","hash":"536f28c4354a13582af826d9d9b2cb27cec07dc6","modified":1578923034120},{"_id":"source/images/t7s2020/KV-2017.jpg","hash":"9a1014653bc709d717bb363f8de6e2015c337f03","modified":1582172401235},{"_id":"source/images/t7s2020/KV-2020.jpg","hash":"6ce6863c87fc7dbec7b4b448838a6bda1998c79f","modified":1582172696215},{"_id":"source/images/t7s2020/KV-2015.jpg","hash":"cd0865372c745099f16fbda569c9d82587da0c71","modified":1582172514156},{"_id":"source/images/t7s2020/KV-2014.jpg","hash":"6383dbd5533237cff758b34f4365fa5eaa7808f1","modified":1582172496197},{"_id":"themes/3-hexo/source/img/preview.png","hash":"851f8138c456c79c7177a4a6953da0c74390112c","modified":1579954114396},{"_id":"themes/3-hexo/source/img/article.jpg","hash":"506dcade3f6153eb2c350a67c615d84c710c8ac6","modified":1579791586441},{"_id":"themes/3-hexo/source/install/Git-2.25.0-64-bit.exe","hash":"af87796ee35491daae8ae0864063e7f4357cb6f2","modified":1579963078315},{"_id":"public/about/index.html","hash":"ce2ae7db61f956cd1462a88742a5a43fefd0e93a","modified":1582990988925},{"_id":"public/journey/index.html","hash":"ac93ea81a3684febe0ab4c4a75d8527683a50e65","modified":1582992102302},{"_id":"public/install/index.html","hash":"2a62a358bda96a7d7d1a28438a89656ba436a8b2","modified":1582454857389},{"_id":"public/tags/index.html","hash":"f1422bb97ef230cafb2b5073688f9acc43124437","modified":1582990988925},{"_id":"public/2020/02/23/t7s六周年/index.html","hash":"9852050089edb6c0392c0d475e7b50376d36ebcd","modified":1582645690956},{"_id":"public/2020/02/08/Nginx性能优化-worke进程/index.html","hash":"689d2fed02544f172b0f6f916cc9de0bf29f3074","modified":1582990988925},{"_id":"public/2020/02/06/2020.2.6 Java学习笔记/index.html","hash":"715b489b78482a5b1146034aa24fc54cba8ebf29","modified":1582990988925},{"_id":"public/2020/02/06/蓝桥杯B组试题B：年号字串/index.html","hash":"9fb0b371082743013311794b954bca1a055ef7a4","modified":1582990988925},{"_id":"public/2020/01/30/基于operator构建的Nested-List/index.html","hash":"2d2072d83b5e02567678ea7deec91221e08267d1","modified":1582990988925},{"_id":"public/2020/01/30/闲着没事造轮子/index.html","hash":"c49040b6a81a0f1a1b93179aa8615e4e9c710a32","modified":1582990988925},{"_id":"public/2020/01/30/用于小型网站后端的Web-MySQL/index.html","hash":"5498d1a85c5df040c2c6d29a4393bfaf546a0b81","modified":1582990988925},{"_id":"public/2020/01/25/使用twine把项目打成pip包/index.html","hash":"668c3dc02b1598f6b0689697bdb3f96a6e3dbee9","modified":1582990988925},{"_id":"public/2020/01/25/算法导论python快速排序代码理解/index.html","hash":"d1e16c89e64b5e537722220b973d4faad72e1bab","modified":1582990988925},{"_id":"public/2020/01/24/关于沉迷于东方Project这件事/index.html","hash":"60655415598d3461dd832f833594eca692cb305f","modified":1582990988925},{"_id":"public/2019/11/10/强类型与动态类型的Python/index.html","hash":"aca14fd996de0c07c5e8abb17f57471b7339e2b6","modified":1582990988925},{"_id":"public/2019/11/10/用树结构获取自然数拆分结果/index.html","hash":"fca6a995a54608bcfdece7e0f567552f7e373179","modified":1582990988925},{"_id":"public/2019/11/10/用树结构获取字符排列组合/index.html","hash":"132ce17c66a4c0a58789f309c799ed27931605d6","modified":1582990988925},{"_id":"public/2019/09/11/数据结构基础/index.html","hash":"f4ebd7cb338a1819a30a638939fb7293d87e16c4","modified":1582990988925},{"_id":"public/2019/06/02/python程序打包成exe文件/index.html","hash":"97179e14278f7dac2a4c4a683824085bb794c5c1","modified":1582990988925},{"_id":"public/2019/04/08/MySQL安装到登陆的问题/index.html","hash":"3b674abdd0046c259a7f1b606bf643a9386599dc","modified":1582990988925},{"_id":"public/2019/04/04/机器学习资源分享/index.html","hash":"0af14e294dc936ede106192ff40c4c784aee3e74","modified":1582990988925},{"_id":"public/2019/03/29/使用Hexo-NexT时遇到的问题/index.html","hash":"b6997a2fa9faa3d0ac442f5449b03ec790626941","modified":1582990988925},{"_id":"public/categories/学习笔记/index.html","hash":"853636fdc77233fd99cf23871859a4f1e13ad343","modified":1582990988925},{"_id":"public/categories/技术文章/index.html","hash":"853636fdc77233fd99cf23871859a4f1e13ad343","modified":1582990988925},{"_id":"public/categories/生活日常/index.html","hash":"853636fdc77233fd99cf23871859a4f1e13ad343","modified":1582990988925},{"_id":"public/categories/开发记录/index.html","hash":"853636fdc77233fd99cf23871859a4f1e13ad343","modified":1582990988925},{"_id":"public/categories/算法代码/index.html","hash":"853636fdc77233fd99cf23871859a4f1e13ad343","modified":1582990988925},{"_id":"public/archives/index.html","hash":"853636fdc77233fd99cf23871859a4f1e13ad343","modified":1582990988925},{"_id":"public/archives/page/2/index.html","hash":"853636fdc77233fd99cf23871859a4f1e13ad343","modified":1582990988925},{"_id":"public/archives/2019/index.html","hash":"853636fdc77233fd99cf23871859a4f1e13ad343","modified":1582990988925},{"_id":"public/archives/2019/03/index.html","hash":"853636fdc77233fd99cf23871859a4f1e13ad343","modified":1582990988925},{"_id":"public/archives/2019/04/index.html","hash":"853636fdc77233fd99cf23871859a4f1e13ad343","modified":1582990988925},{"_id":"public/archives/2019/06/index.html","hash":"853636fdc77233fd99cf23871859a4f1e13ad343","modified":1582990988925},{"_id":"public/archives/2019/09/index.html","hash":"853636fdc77233fd99cf23871859a4f1e13ad343","modified":1582990988925},{"_id":"public/archives/2019/11/index.html","hash":"853636fdc77233fd99cf23871859a4f1e13ad343","modified":1582990988925},{"_id":"public/archives/2020/index.html","hash":"853636fdc77233fd99cf23871859a4f1e13ad343","modified":1582990988925},{"_id":"public/archives/2020/01/index.html","hash":"853636fdc77233fd99cf23871859a4f1e13ad343","modified":1582990988925},{"_id":"public/archives/2020/02/index.html","hash":"853636fdc77233fd99cf23871859a4f1e13ad343","modified":1582990988925},{"_id":"public/tags/Java/index.html","hash":"853636fdc77233fd99cf23871859a4f1e13ad343","modified":1582990988925},{"_id":"public/tags/Nginx/index.html","hash":"853636fdc77233fd99cf23871859a4f1e13ad343","modified":1582990988925},{"_id":"public/tags/MySQL/index.html","hash":"853636fdc77233fd99cf23871859a4f1e13ad343","modified":1582990988925},{"_id":"public/tags/Python/index.html","hash":"853636fdc77233fd99cf23871859a4f1e13ad343","modified":1582990988925},{"_id":"public/tags/博客/index.html","hash":"853636fdc77233fd99cf23871859a4f1e13ad343","modified":1582990988925},{"_id":"public/tags/神经网络/index.html","hash":"853636fdc77233fd99cf23871859a4f1e13ad343","modified":1582990988925},{"_id":"public/tags/深度学习/index.html","hash":"853636fdc77233fd99cf23871859a4f1e13ad343","modified":1582990988925},{"_id":"public/index.html","hash":"853636fdc77233fd99cf23871859a4f1e13ad343","modified":1582990988925},{"_id":"public/page/2/index.html","hash":"853636fdc77233fd99cf23871859a4f1e13ad343","modified":1582990988925},{"_id":"public/CNAME","hash":"440ddcd92585f97aa09ec6414ee6c46599ff9ea3","modified":1582454857389},{"_id":"public/images/avatar.png","hash":"a30b0de04ca86766504064fdfcfc7b3d7df934b9","modified":1582454857389},{"_id":"public/images/Python特性/TypeError1.png","hash":"3bee26a28c50c682d37353c54c744db7400cd199","modified":1582454857389},{"_id":"public/images/Python特性/dynamic1.png","hash":"7cfda8f81fdb8694d258c841fe8686bfe38962b7","modified":1582454857389},{"_id":"public/images/Python特性/dynamic2.png","hash":"cae1d97b658295f80fc8db83559ec3e187e82ccc","modified":1582454857389},{"_id":"public/images/Python特性/dynamic3.png","hash":"e857dffd839825e4c728826c2b5e4fc9e31e67bc","modified":1582454857389},{"_id":"public/images/Python特性/dynamic4.png","hash":"a05bce4e0d48e3a0cabc8002f2312df0510af1b7","modified":1582454857389},{"_id":"public/images/Python特性/introduce.png","hash":"dca90e3f78c4c98397a89d5794bbcd1ce88fac53","modified":1582454857389},{"_id":"public/images/数据结构基础/数据逻辑结构层次图.jpg","hash":"12d91d50cfa6c3f47248332e16094adc5165e7c4","modified":1582454857389},{"_id":"public/css/fonts/icomoon.eot","hash":"b6195bedc1cb2f9cfcb26cc27021f2e94be2ab0a","modified":1582454857389},{"_id":"public/css/fonts/icomoon.woff","hash":"3985d29416bb9b19f50a2f20f2bbbce47f10af8d","modified":1582454857389},{"_id":"public/css/fonts/icomoon.ttf","hash":"eb976d8b8559fcddfc2658a03a4350cb566fc06b","modified":1582454857389},{"_id":"public/css/fonts/icomoon.svg","hash":"b5e7562c8494b0ddb3a70ecc5545ef7340d8e971","modified":1582454857389},{"_id":"public/css/fonts/iconfont.eot","hash":"3dfe8e557d9dfaf39bca088a02b76deb82dbaa3d","modified":1582454857389},{"_id":"public/css/fonts/iconfont.svg","hash":"7e54ae44c02faa319c4fe128e1e6bda38eae5c9d","modified":1582454857389},{"_id":"public/css/fonts/iconfont.ttf","hash":"aa087561480fb9c2cfd541e33d1e99d5ac1a56bb","modified":1582454857389},{"_id":"public/css/fonts/iconfont.woff","hash":"f8ed131ccf13f4bdd3ec11fc3e997339dd7b66ba","modified":1582454857389},{"_id":"public/img/alipay.jpg","hash":"e70a57b660caa38f36f30794e8d657a218841fd5","modified":1582454857389},{"_id":"public/img/article-list-background.jpg","hash":"b579af6819ee49d524b074167201adef09575629","modified":1582454857389},{"_id":"public/img/weixin.jpg","hash":"f536bdbf78f988e57562f715c0a5b96b6cde4bba","modified":1582454857389},{"_id":"public/css/custom.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1582454857389},{"_id":"public/css/mobile.css","hash":"84b30a9fcce0a2514ba7a168ebf8e3f9043684a0","modified":1582454857389},{"_id":"public/js/search.js","hash":"c80c9a231ee040c7adc07a477793873fb85ce8bc","modified":1582454857389},{"_id":"public/js/jquery.autocomplete.min.js","hash":"7b8ac4d06c9e763963832529f44a56ad42a81e5f","modified":1582454857389},{"_id":"public/css/hl_theme/atom-dark.css","hash":"88d11052a24e8100af6248eb4dbe1ce7b0e96408","modified":1582454857389},{"_id":"public/css/hl_theme/atom-light.css","hash":"a3c8f3ee9a655594eff7ac545cb2e6914c1abcc2","modified":1582454857389},{"_id":"public/css/hl_theme/darcula.css","hash":"4341074bae4bc9f0b86e32b623e27babc0159b6e","modified":1582454857389},{"_id":"public/css/hl_theme/github-gist.css","hash":"7a41c1c479d09df875f99f1f6d94aac42e9e2ad0","modified":1582454857389},{"_id":"public/css/hl_theme/brown-paper.css","hash":"500c8e750373f6656ff49a7857c871ceedcf8777","modified":1582454857389},{"_id":"public/css/hl_theme/github.css","hash":"e05a0806a508a26b9f3f3794b6b588ec6504ad3f","modified":1582454857389},{"_id":"public/css/hl_theme/gruvbox-dark.css","hash":"8c440d9b4ee19ac03eaee3c6af78ba52e5ba5535","modified":1582454857389},{"_id":"public/css/hl_theme/kimbie-light.css","hash":"0c61926c989163faefb031d27bce3e287d6e10f2","modified":1582454857389},{"_id":"public/css/hl_theme/gruvbox-light.css","hash":"30514aaa242a34647aa666cfca4fc74c595ea8f2","modified":1582454857389},{"_id":"public/css/hl_theme/kimbie-dark.css","hash":"728527fcc308da454722c119b89e6da3025bd1e3","modified":1582454857389},{"_id":"public/css/hl_theme/rainbow.css","hash":"7ff4251938076ddb7e4e49413db82653e5b61321","modified":1582454857389},{"_id":"public/css/hl_theme/railscasts.css","hash":"511f2fd2a84d426e5da5cb17880cc08f73beb002","modified":1582454857389},{"_id":"public/css/hl_theme/school-book.css","hash":"ffbbcd13a74ac2404262c50b7a43053dfd0096ff","modified":1582454857389},{"_id":"public/css/hl_theme/sunburst.css","hash":"8a135abac1512cf430d1d1ad2304b79afa1a4d6e","modified":1582454857389},{"_id":"public/css/hl_theme/zenbum.css","hash":"0a78f74a93568e20b32ca7427c719e9bae9a0b55","modified":1582454857389},{"_id":"public/css/hl_theme/sublime.css","hash":"f65c5b116d9213afb9c324384a2f3bc86cb71121","modified":1582454857389},{"_id":"public/css/gitalk.css","hash":"58177ce227c50ee359fbf99a4fdd26058887afc5","modified":1582454857389},{"_id":"public/css/style.css","hash":"d342a6d98eadc31c197cefb7eaa2ad21fec6ceed","modified":1582454857389},{"_id":"public/js/jquery.pjax.js","hash":"191c49fdb40dff115a49cfd2b30dffb888d86550","modified":1582454857389},{"_id":"public/js/iconfont.js","hash":"3a0869ca1b09af07d82987e343a3bc4cb9558ecb","modified":1582454857389},{"_id":"public/js/script.js","hash":"7502191e29366a11323dc72ae365b1aed254e6f2","modified":1582454857389},{"_id":"public/js/gitment.js","hash":"59a1e03f2b0ce61dd9bd405d3c52d3e07cc10dec","modified":1582454857389},{"_id":"public/css/fonts/selection.json","hash":"047b615ea32dc48dae5b964061427d41feaaafdf","modified":1582454857389},{"_id":"public/js/gitalk.js","hash":"d1eb82a3280981bd652d9a8e323060e4311c547b","modified":1582454857389},{"_id":"public/install/AS SSD Benchmark.zip","hash":"818c029f1ec61f52da994a8b0eafe1654417f1f1","modified":1582454857389},{"_id":"public/images/t7s2020/KV-2017.jpg","hash":"9a1014653bc709d717bb363f8de6e2015c337f03","modified":1582454857389},{"_id":"public/images/t7s2020/KV-2020.jpg","hash":"6ce6863c87fc7dbec7b4b448838a6bda1998c79f","modified":1582454857389},{"_id":"public/images/t7s2020/KV-2015.jpg","hash":"cd0865372c745099f16fbda569c9d82587da0c71","modified":1582454857389},{"_id":"public/images/t7s2020/KV-2014.jpg","hash":"6383dbd5533237cff758b34f4365fa5eaa7808f1","modified":1582454857389},{"_id":"public/img/preview.png","hash":"851f8138c456c79c7177a4a6953da0c74390112c","modified":1582454857389},{"_id":"public/img/article.jpg","hash":"506dcade3f6153eb2c350a67c615d84c710c8ac6","modified":1582454857389},{"_id":"public/install/Git-2.25.0-64-bit.exe","hash":"af87796ee35491daae8ae0864063e7f4357cb6f2","modified":1582454857389},{"_id":"source/_posts/2020.2.25 SpringBoot学习笔记.md","hash":"20899526b3af915a91061fd7264eb05331ed68a5","modified":1582645451886},{"_id":"public/2020/02/25/2020.2.25 SpringBoot学习笔记/index.html","hash":"6068ae292b6aa4fdad66b668750e73dc0edd00e5","modified":1582990988925},{"_id":"public/archives/2020/page/2/index.html","hash":"853636fdc77233fd99cf23871859a4f1e13ad343","modified":1582990988925},{"_id":"public/tags/spring-projects/index.html","hash":"853636fdc77233fd99cf23871859a4f1e13ad343","modified":1582990988925},{"_id":"source/_posts/2020新年的t7s.md","hash":"39d0e06f4574a5512dabf9f562a149cb8e295d74","modified":1582990891816},{"_id":"source/images/t7s2020/E5-2.jpg","hash":"8d67facbcbb138e26a2285aea5ae297d9c3a4ae1","modified":1582990234071},{"_id":"source/images/t7s2020/E5-3.jpg","hash":"4446a83a461c473dc68ec35d12054cbeea93aef5","modified":1582990236185},{"_id":"source/images/t7s2020/E5-1.jpg","hash":"56b746fd4ee51a03e93cde936f036ebc43d018b2","modified":1582990238220},{"_id":"source/images/t7s2020/letter.jpg","hash":"6287ddf3e9c11bf40f93614a7e4cb364326adb0a","modified":1582990246495},{"_id":"public/2020/02/23/2020新年的t7s/index.html","hash":"6e4cd01dd4a223b8ddeccf5c9ba4672821c39927","modified":1582990988925},{"_id":"public/images/t7s2020/E5-3.jpg","hash":"4446a83a461c473dc68ec35d12054cbeea93aef5","modified":1582990988925},{"_id":"public/images/t7s2020/E5-1.jpg","hash":"56b746fd4ee51a03e93cde936f036ebc43d018b2","modified":1582990988925},{"_id":"public/images/t7s2020/E5-2.jpg","hash":"8d67facbcbb138e26a2285aea5ae297d9c3a4ae1","modified":1582990988925},{"_id":"public/images/t7s2020/letter.jpg","hash":"6287ddf3e9c11bf40f93614a7e4cb364326adb0a","modified":1582990988925}],"Category":[{"name":"学习笔记","_id":"ck6ywrivk000354v56h050jng"},{"name":"技术文章","_id":"ck6ywrivx000j54v5hsfxf9lu"},{"name":"生活日常","_id":"ck6ywriw2000q54v59xod7ubv"},{"name":"开发记录","_id":"ck6ywriwb001554v54e1jbeth"},{"name":"算法代码","_id":"ck6ywriwh001r54v58hvdfb9m"}],"Data":[],"Page":[{"title":"关于我自己","_content":"\n## [**有机少年**](#有机少年)\n\n**为什么叫有机少年, 因为以前高中的时候QQ名字是这样的, 后来到了7群群友都叫我有机, 不知不觉就接受了这个名字了, 现实中也有人叫我有机, 不过在IT圈我用aruki比较多**\n**说来惭愧, 因为以前高中是学日语的, 想用有机的日语罗马音做另外的一个名字, 所以就用了aruki这个名字**\n\n**当时想的是有\"有\"在日语经常使用的是\"あります\"也就是\"ある\", 但实际上\"有\"的日语是\"ゆう\"或者\"おる\", 实际上\"有机\"这个词语日语应该是\"ゆうき\", 也就是yuki**\n**学艺不精加上没查清除导致的问题, 但是现在用着其实也习惯了, 各个平台使用的都是这个名字。**\n\n**至于为什么博客是arukione, 因为当时买域名的时候, 发现aruki.com的域名已经有人用了, 刚好那时候接触了Hackerone, 就学了这个命名风格, 在aruki后面加了one**\n**arukione.cn也是被我买了, 不过暂时用在了部门开发时使用的服务器(顺带一提, 目前服务器还是个人的....)**\n\n## [**关于我自己的兴趣爱好**](#关于我自己的兴趣爱好)\n\n**从小到大喜欢玩游戏, 现在玩的主要是王者和东京七姐妹, 可以说我大部分类型的游戏都玩**\n**以前喜欢打篮球, 现在到球场只能感叹“年轻真好”**\n**喜欢听歌, 喜欢唱歌, 喜欢看动漫, 也喜欢游戏同人作品**\n**现在对计算机方面的技术非常痴迷, 一个是兴趣点刚好在这, 一个是自身学习能力和执着于探究的性格, 也有一些童年的原因, 现在能一整天都躲在室内看电脑**\n**可以说是一个二次猿+程序猿+技术宅, 嗯, 同时也是一个直男吧...**\n\n## [**一点个人信息**](#一点个人信息)\n\n**软件工程专业学生, 有点强迫症, 不希望自己代码里出现黄色警告(开发时间充裕的情况下)**\n**现实日常不太擅长说话, 倒是挺喜欢边观察边思考别人说话和做事**\n**博客从大一的时候就搭建了, 当时没什么东西可以写的, 倒是这段时间不嫌费劲不怕浪费时间挺执着于给博客弄漂亮一点, 换了几个主题**\n**目前主要使用的编程语言是Java和Python**\n\n## [**自己给自己的几句话**](#自己给自己的几句话)\n\n**1、在错误中反思, 在批评中成长**\n**2、正しさなんてもの、人のモノサシによって変わる(所谓的正义因不同人的标准而不同)**\n**3、不给他人决定道路, 不让自己走上歪路**\n\n## [**联系方式**](#联系方式)\n\n**邮箱:**\n    **Gmail邮箱: zqljiebin@gmail.com  (侧边栏邮箱)**\n    **QQ邮箱: 1281359826@qq.com**\n\n**以下添加备注来源博客:**\n    **QQ: 1281359826**\n    **WX: jiehaobin**\n\n**其它:**\n    **Telegram: <htt[s://t.me/arukione]>  (很少用)**\n    **GitHub: <https://github.com/arukione>   (侧边栏GitHub)**\n\n## [**一点其它信息**](#一点其他信息)\n\n**计算机旅途：<https://www.arukione.com/journey>**\n","source":"about/index.md","raw":"---\ntitle: 关于我自己\n---\n\n## [**有机少年**](#有机少年)\n\n**为什么叫有机少年, 因为以前高中的时候QQ名字是这样的, 后来到了7群群友都叫我有机, 不知不觉就接受了这个名字了, 现实中也有人叫我有机, 不过在IT圈我用aruki比较多**\n**说来惭愧, 因为以前高中是学日语的, 想用有机的日语罗马音做另外的一个名字, 所以就用了aruki这个名字**\n\n**当时想的是有\"有\"在日语经常使用的是\"あります\"也就是\"ある\", 但实际上\"有\"的日语是\"ゆう\"或者\"おる\", 实际上\"有机\"这个词语日语应该是\"ゆうき\", 也就是yuki**\n**学艺不精加上没查清除导致的问题, 但是现在用着其实也习惯了, 各个平台使用的都是这个名字。**\n\n**至于为什么博客是arukione, 因为当时买域名的时候, 发现aruki.com的域名已经有人用了, 刚好那时候接触了Hackerone, 就学了这个命名风格, 在aruki后面加了one**\n**arukione.cn也是被我买了, 不过暂时用在了部门开发时使用的服务器(顺带一提, 目前服务器还是个人的....)**\n\n## [**关于我自己的兴趣爱好**](#关于我自己的兴趣爱好)\n\n**从小到大喜欢玩游戏, 现在玩的主要是王者和东京七姐妹, 可以说我大部分类型的游戏都玩**\n**以前喜欢打篮球, 现在到球场只能感叹“年轻真好”**\n**喜欢听歌, 喜欢唱歌, 喜欢看动漫, 也喜欢游戏同人作品**\n**现在对计算机方面的技术非常痴迷, 一个是兴趣点刚好在这, 一个是自身学习能力和执着于探究的性格, 也有一些童年的原因, 现在能一整天都躲在室内看电脑**\n**可以说是一个二次猿+程序猿+技术宅, 嗯, 同时也是一个直男吧...**\n\n## [**一点个人信息**](#一点个人信息)\n\n**软件工程专业学生, 有点强迫症, 不希望自己代码里出现黄色警告(开发时间充裕的情况下)**\n**现实日常不太擅长说话, 倒是挺喜欢边观察边思考别人说话和做事**\n**博客从大一的时候就搭建了, 当时没什么东西可以写的, 倒是这段时间不嫌费劲不怕浪费时间挺执着于给博客弄漂亮一点, 换了几个主题**\n**目前主要使用的编程语言是Java和Python**\n\n## [**自己给自己的几句话**](#自己给自己的几句话)\n\n**1、在错误中反思, 在批评中成长**\n**2、正しさなんてもの、人のモノサシによって変わる(所谓的正义因不同人的标准而不同)**\n**3、不给他人决定道路, 不让自己走上歪路**\n\n## [**联系方式**](#联系方式)\n\n**邮箱:**\n    **Gmail邮箱: zqljiebin@gmail.com  (侧边栏邮箱)**\n    **QQ邮箱: 1281359826@qq.com**\n\n**以下添加备注来源博客:**\n    **QQ: 1281359826**\n    **WX: jiehaobin**\n\n**其它:**\n    **Telegram: <htt[s://t.me/arukione]>  (很少用)**\n    **GitHub: <https://github.com/arukione>   (侧边栏GitHub)**\n\n## [**一点其它信息**](#一点其他信息)\n\n**计算机旅途：<https://www.arukione.com/journey>**\n","date":"2020-02-17T06:23:44.159Z","updated":"2020-02-17T06:23:44.159Z","path":"about/index.html","comments":1,"layout":"page","_id":"ck6ywrivc000054v558or8jye","content":"<h2 id=\"有机少年\"><a href=\"#有机少年\" class=\"headerlink\" title=\"有机少年\"></a><a href=\"#有机少年\"><strong>有机少年</strong></a></h2><p><strong>为什么叫有机少年, 因为以前高中的时候QQ名字是这样的, 后来到了7群群友都叫我有机, 不知不觉就接受了这个名字了, 现实中也有人叫我有机, 不过在IT圈我用aruki比较多</strong><br><strong>说来惭愧, 因为以前高中是学日语的, 想用有机的日语罗马音做另外的一个名字, 所以就用了aruki这个名字</strong></p>\n<p><strong>当时想的是有”有”在日语经常使用的是”あります”也就是”ある”, 但实际上”有”的日语是”ゆう”或者”おる”, 实际上”有机”这个词语日语应该是”ゆうき”, 也就是yuki</strong><br><strong>学艺不精加上没查清除导致的问题, 但是现在用着其实也习惯了, 各个平台使用的都是这个名字。</strong></p>\n<p><strong>至于为什么博客是arukione, 因为当时买域名的时候, 发现aruki.com的域名已经有人用了, 刚好那时候接触了Hackerone, 就学了这个命名风格, 在aruki后面加了one</strong><br><strong>arukione.cn也是被我买了, 不过暂时用在了部门开发时使用的服务器(顺带一提, 目前服务器还是个人的….)</strong></p>\n<h2 id=\"关于我自己的兴趣爱好\"><a href=\"#关于我自己的兴趣爱好\" class=\"headerlink\" title=\"关于我自己的兴趣爱好\"></a><a href=\"#关于我自己的兴趣爱好\"><strong>关于我自己的兴趣爱好</strong></a></h2><p><strong>从小到大喜欢玩游戏, 现在玩的主要是王者和东京七姐妹, 可以说我大部分类型的游戏都玩</strong><br><strong>以前喜欢打篮球, 现在到球场只能感叹“年轻真好”</strong><br><strong>喜欢听歌, 喜欢唱歌, 喜欢看动漫, 也喜欢游戏同人作品</strong><br><strong>现在对计算机方面的技术非常痴迷, 一个是兴趣点刚好在这, 一个是自身学习能力和执着于探究的性格, 也有一些童年的原因, 现在能一整天都躲在室内看电脑</strong><br><strong>可以说是一个二次猿+程序猿+技术宅, 嗯, 同时也是一个直男吧…</strong></p>\n<h2 id=\"一点个人信息\"><a href=\"#一点个人信息\" class=\"headerlink\" title=\"一点个人信息\"></a><a href=\"#一点个人信息\"><strong>一点个人信息</strong></a></h2><p><strong>软件工程专业学生, 有点强迫症, 不希望自己代码里出现黄色警告(开发时间充裕的情况下)</strong><br><strong>现实日常不太擅长说话, 倒是挺喜欢边观察边思考别人说话和做事</strong><br><strong>博客从大一的时候就搭建了, 当时没什么东西可以写的, 倒是这段时间不嫌费劲不怕浪费时间挺执着于给博客弄漂亮一点, 换了几个主题</strong><br><strong>目前主要使用的编程语言是Java和Python</strong></p>\n<h2 id=\"自己给自己的几句话\"><a href=\"#自己给自己的几句话\" class=\"headerlink\" title=\"自己给自己的几句话\"></a><a href=\"#自己给自己的几句话\"><strong>自己给自己的几句话</strong></a></h2><p><strong>1、在错误中反思, 在批评中成长</strong><br><strong>2、正しさなんてもの、人のモノサシによって変わる(所谓的正义因不同人的标准而不同)</strong><br><strong>3、不给他人决定道路, 不让自己走上歪路</strong></p>\n<h2 id=\"联系方式\"><a href=\"#联系方式\" class=\"headerlink\" title=\"联系方式\"></a><a href=\"#联系方式\"><strong>联系方式</strong></a></h2><p><strong>邮箱:</strong><br>    <strong>Gmail邮箱: <a href=\"mailto:zqljiebin@gmail.com\">zqljiebin@gmail.com</a>  (侧边栏邮箱)</strong><br>    <strong>QQ邮箱: <a href=\"mailto:1281359826@qq.com\">1281359826@qq.com</a></strong></p>\n<p><strong>以下添加备注来源博客:</strong><br>    <strong>QQ: 1281359826</strong><br>    <strong>WX: jiehaobin</strong></p>\n<p><strong>其它:</strong><br>    <strong>Telegram: &lt;htt[s://t.me/arukione]&gt;  (很少用)</strong><br>    <strong>GitHub: <a href=\"https://github.com/arukione\" target=\"_blank\" rel=\"noopener\">https://github.com/arukione</a>   (侧边栏GitHub)</strong></p>\n<h2 id=\"一点其它信息\"><a href=\"#一点其它信息\" class=\"headerlink\" title=\"一点其它信息\"></a><a href=\"#一点其他信息\"><strong>一点其它信息</strong></a></h2><p><strong>计算机旅途：<a href=\"https://www.arukione.com/journey\" target=\"_blank\" rel=\"noopener\">https://www.arukione.com/journey</a></strong></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"有机少年\"><a href=\"#有机少年\" class=\"headerlink\" title=\"有机少年\"></a><a href=\"#有机少年\"><strong>有机少年</strong></a></h2><p><strong>为什么叫有机少年, 因为以前高中的时候QQ名字是这样的, 后来到了7群群友都叫我有机, 不知不觉就接受了这个名字了, 现实中也有人叫我有机, 不过在IT圈我用aruki比较多</strong><br><strong>说来惭愧, 因为以前高中是学日语的, 想用有机的日语罗马音做另外的一个名字, 所以就用了aruki这个名字</strong></p>\n<p><strong>当时想的是有”有”在日语经常使用的是”あります”也就是”ある”, 但实际上”有”的日语是”ゆう”或者”おる”, 实际上”有机”这个词语日语应该是”ゆうき”, 也就是yuki</strong><br><strong>学艺不精加上没查清除导致的问题, 但是现在用着其实也习惯了, 各个平台使用的都是这个名字。</strong></p>\n<p><strong>至于为什么博客是arukione, 因为当时买域名的时候, 发现aruki.com的域名已经有人用了, 刚好那时候接触了Hackerone, 就学了这个命名风格, 在aruki后面加了one</strong><br><strong>arukione.cn也是被我买了, 不过暂时用在了部门开发时使用的服务器(顺带一提, 目前服务器还是个人的….)</strong></p>\n<h2 id=\"关于我自己的兴趣爱好\"><a href=\"#关于我自己的兴趣爱好\" class=\"headerlink\" title=\"关于我自己的兴趣爱好\"></a><a href=\"#关于我自己的兴趣爱好\"><strong>关于我自己的兴趣爱好</strong></a></h2><p><strong>从小到大喜欢玩游戏, 现在玩的主要是王者和东京七姐妹, 可以说我大部分类型的游戏都玩</strong><br><strong>以前喜欢打篮球, 现在到球场只能感叹“年轻真好”</strong><br><strong>喜欢听歌, 喜欢唱歌, 喜欢看动漫, 也喜欢游戏同人作品</strong><br><strong>现在对计算机方面的技术非常痴迷, 一个是兴趣点刚好在这, 一个是自身学习能力和执着于探究的性格, 也有一些童年的原因, 现在能一整天都躲在室内看电脑</strong><br><strong>可以说是一个二次猿+程序猿+技术宅, 嗯, 同时也是一个直男吧…</strong></p>\n<h2 id=\"一点个人信息\"><a href=\"#一点个人信息\" class=\"headerlink\" title=\"一点个人信息\"></a><a href=\"#一点个人信息\"><strong>一点个人信息</strong></a></h2><p><strong>软件工程专业学生, 有点强迫症, 不希望自己代码里出现黄色警告(开发时间充裕的情况下)</strong><br><strong>现实日常不太擅长说话, 倒是挺喜欢边观察边思考别人说话和做事</strong><br><strong>博客从大一的时候就搭建了, 当时没什么东西可以写的, 倒是这段时间不嫌费劲不怕浪费时间挺执着于给博客弄漂亮一点, 换了几个主题</strong><br><strong>目前主要使用的编程语言是Java和Python</strong></p>\n<h2 id=\"自己给自己的几句话\"><a href=\"#自己给自己的几句话\" class=\"headerlink\" title=\"自己给自己的几句话\"></a><a href=\"#自己给自己的几句话\"><strong>自己给自己的几句话</strong></a></h2><p><strong>1、在错误中反思, 在批评中成长</strong><br><strong>2、正しさなんてもの、人のモノサシによって変わる(所谓的正义因不同人的标准而不同)</strong><br><strong>3、不给他人决定道路, 不让自己走上歪路</strong></p>\n<h2 id=\"联系方式\"><a href=\"#联系方式\" class=\"headerlink\" title=\"联系方式\"></a><a href=\"#联系方式\"><strong>联系方式</strong></a></h2><p><strong>邮箱:</strong><br>    <strong>Gmail邮箱: <a href=\"mailto:zqljiebin@gmail.com\">zqljiebin@gmail.com</a>  (侧边栏邮箱)</strong><br>    <strong>QQ邮箱: <a href=\"mailto:1281359826@qq.com\">1281359826@qq.com</a></strong></p>\n<p><strong>以下添加备注来源博客:</strong><br>    <strong>QQ: 1281359826</strong><br>    <strong>WX: jiehaobin</strong></p>\n<p><strong>其它:</strong><br>    <strong>Telegram: &lt;htt[s://t.me/arukione]&gt;  (很少用)</strong><br>    <strong>GitHub: <a href=\"https://github.com/arukione\" target=\"_blank\" rel=\"noopener\">https://github.com/arukione</a>   (侧边栏GitHub)</strong></p>\n<h2 id=\"一点其它信息\"><a href=\"#一点其它信息\" class=\"headerlink\" title=\"一点其它信息\"></a><a href=\"#一点其他信息\"><strong>一点其它信息</strong></a></h2><p><strong>计算机旅途：<a href=\"https://www.arukione.com/journey\" target=\"_blank\" rel=\"noopener\">https://www.arukione.com/journey</a></strong></p>\n"},{"title":"计算机旅途","_content":"\n## [**实际项目**](#实际项目)\n\n|**所属**|**项目名称**|**开始时间**|**开发周期**|**源码地址**|\n|:---|:---:|:---:|:---:|:---:|\n|**城院校易班学生工作站**|**城院易班微信小程序**|**2019-11**|**2个星期**|**无**|\n|**城院校易班学生工作站**|**2020新年祝福专栏网站**|**2020-1**|**18天**|**<https://github.com/arukione/2020NewYear>**|\n\n## [**2018年**](#2018年)\n\n**加强自己对计算机的认识, 更深层地去理解计算机的工作原理**\n**从C语言开始认识程序**\n**接下来是自己买了服务器搭建梯子, 第一次接触脚本**\n**慢慢的听到了许多自己没接触过的东西, 例如github、Node.js、还有前端啊, 但是自己都不知道是什么东西**\n\n### [*寒假:*](#寒假)\n\n**自己买了前端的书学习, 知道了如何构建网站**\n**参与了wiki的建设, 发现了更多自己不知道的知识**\n**和vultr的客服交流, 开启了服务器25号端口**\n**学习Java, 认识到了面向对象**\n\n## [**2019年**](#2019年)\n\n**访问了HackOne网站, 开始对网络安全产生兴趣**\n**接触Linux系统**\n**学习了github, 明白了github的作用和使用方法**\n**接触Python, 发现Python的优点**\n**购买了域名, 尝试搭建博客**\n**初次使用git和githubDesktop, 并搭建了自己的博客**\n**用githubDesktop给博客做备份**\n**学习Linux系统和Python、Java, 开始接触数据库**\n**学习MySQL数据库和Python**\n**使用Python写一个爬虫, 借了数据库的书进行进一步学习和练习**\n**学习AI, 入门机器学习**\n**第一次写了一个可以识别数字的神经网络**\n**学习Python数据结构**\n**接触网络和使用刷入固件的路由器**\n\n### [*七月:*](#七月)\n\n**暑假开始使用Ubuntu系统**\n**进一步学习机器学习算法, 入门TensorFlow深度学习框架**\n**学习卷积神经网络结构(CNN)**\n**学习对抗神经网络（DCGAN）**\n**使用Tesra平台, 尝试在系统用GPU训练网络, 结果安装驱动的时候把Ubuntu系统搞坏了（呜呜呜）**\n**开始使用Debian系统**\n\n### [*十月:*](#十月)\n\n**接触Python的web框架Django和Flask**\n**学习小程序开发**\n**参加蓝桥杯, 选择Python语言比赛, 参加学校培训**\n**进行部门小程序开发, 使用Flask作为后端**\n**买了Nginx、Flask、操作系统概念、分布式系统概念与设计、Docker技术的书**\n**学习Nginx, 用Nginx和uWSGI给Flask搭建web服务**\n**学习ssl, 为后端网站开启https给小程序做接口用**\n**继续学习Flask、Nginx, 终于搞懂了KMP算法**\n**为了给部门小朋友讲课, 制作PPT, 了解到了许多包括Android开发、Node.js和前端框架等相关的知识**\n\n## [**2020年**](#2020年)\n\n### [*一月:*](#一月)\n\n**学习Ajax, 开始了解前后端分离**\n**第一次一个人完成了可以发文章, 带评论和点赞的网站, 学到了很多东西**\n**重新弄博客, 换了3-hexo的主题, 自己修改styl文件配样式, 感觉和css差不多**\n**上传了两个简单封装的pip软件包Web-MySQL和Nested-List**\n**了解了一些开源协议, 编写了两个pip软件包在GitHub上的README说明文件**\n**回归Java, 学习Maven**\n**了解了SSM(SpringMVC+Spring+MyBatis)**\n**了解一下Spring Boot和Spring Cloud**\n**为了赶时间没有看完SSM就直接看SpringBoot了，幸好以前有用Py做Web开发的经验，学起来还算顺利**\n**学习Docker和Redis的使用**\n**不想使用Thymeleaf模板引擎, 学习Vue.js采用前后端分离的方式开发**\n","source":"journey/index.md","raw":"---\ntitle: 计算机旅途\n---\n\n## [**实际项目**](#实际项目)\n\n|**所属**|**项目名称**|**开始时间**|**开发周期**|**源码地址**|\n|:---|:---:|:---:|:---:|:---:|\n|**城院校易班学生工作站**|**城院易班微信小程序**|**2019-11**|**2个星期**|**无**|\n|**城院校易班学生工作站**|**2020新年祝福专栏网站**|**2020-1**|**18天**|**<https://github.com/arukione/2020NewYear>**|\n\n## [**2018年**](#2018年)\n\n**加强自己对计算机的认识, 更深层地去理解计算机的工作原理**\n**从C语言开始认识程序**\n**接下来是自己买了服务器搭建梯子, 第一次接触脚本**\n**慢慢的听到了许多自己没接触过的东西, 例如github、Node.js、还有前端啊, 但是自己都不知道是什么东西**\n\n### [*寒假:*](#寒假)\n\n**自己买了前端的书学习, 知道了如何构建网站**\n**参与了wiki的建设, 发现了更多自己不知道的知识**\n**和vultr的客服交流, 开启了服务器25号端口**\n**学习Java, 认识到了面向对象**\n\n## [**2019年**](#2019年)\n\n**访问了HackOne网站, 开始对网络安全产生兴趣**\n**接触Linux系统**\n**学习了github, 明白了github的作用和使用方法**\n**接触Python, 发现Python的优点**\n**购买了域名, 尝试搭建博客**\n**初次使用git和githubDesktop, 并搭建了自己的博客**\n**用githubDesktop给博客做备份**\n**学习Linux系统和Python、Java, 开始接触数据库**\n**学习MySQL数据库和Python**\n**使用Python写一个爬虫, 借了数据库的书进行进一步学习和练习**\n**学习AI, 入门机器学习**\n**第一次写了一个可以识别数字的神经网络**\n**学习Python数据结构**\n**接触网络和使用刷入固件的路由器**\n\n### [*七月:*](#七月)\n\n**暑假开始使用Ubuntu系统**\n**进一步学习机器学习算法, 入门TensorFlow深度学习框架**\n**学习卷积神经网络结构(CNN)**\n**学习对抗神经网络（DCGAN）**\n**使用Tesra平台, 尝试在系统用GPU训练网络, 结果安装驱动的时候把Ubuntu系统搞坏了（呜呜呜）**\n**开始使用Debian系统**\n\n### [*十月:*](#十月)\n\n**接触Python的web框架Django和Flask**\n**学习小程序开发**\n**参加蓝桥杯, 选择Python语言比赛, 参加学校培训**\n**进行部门小程序开发, 使用Flask作为后端**\n**买了Nginx、Flask、操作系统概念、分布式系统概念与设计、Docker技术的书**\n**学习Nginx, 用Nginx和uWSGI给Flask搭建web服务**\n**学习ssl, 为后端网站开启https给小程序做接口用**\n**继续学习Flask、Nginx, 终于搞懂了KMP算法**\n**为了给部门小朋友讲课, 制作PPT, 了解到了许多包括Android开发、Node.js和前端框架等相关的知识**\n\n## [**2020年**](#2020年)\n\n### [*一月:*](#一月)\n\n**学习Ajax, 开始了解前后端分离**\n**第一次一个人完成了可以发文章, 带评论和点赞的网站, 学到了很多东西**\n**重新弄博客, 换了3-hexo的主题, 自己修改styl文件配样式, 感觉和css差不多**\n**上传了两个简单封装的pip软件包Web-MySQL和Nested-List**\n**了解了一些开源协议, 编写了两个pip软件包在GitHub上的README说明文件**\n**回归Java, 学习Maven**\n**了解了SSM(SpringMVC+Spring+MyBatis)**\n**了解一下Spring Boot和Spring Cloud**\n**为了赶时间没有看完SSM就直接看SpringBoot了，幸好以前有用Py做Web开发的经验，学起来还算顺利**\n**学习Docker和Redis的使用**\n**不想使用Thymeleaf模板引擎, 学习Vue.js采用前后端分离的方式开发**\n","date":"2020-02-29T15:57:38.220Z","updated":"2020-02-29T15:57:38.220Z","path":"journey/index.html","_id":"ck6ywriwt002254v5cztjac27","comments":1,"layout":"page","content":"<h2 id=\"实际项目\"><a href=\"#实际项目\" class=\"headerlink\" title=\"实际项目\"></a><a href=\"#实际项目\"><strong>实际项目</strong></a></h2><table>\n<thead>\n<tr>\n<th align=\"left\"><strong>所属</strong></th>\n<th align=\"center\"><strong>项目名称</strong></th>\n<th align=\"center\"><strong>开始时间</strong></th>\n<th align=\"center\"><strong>开发周期</strong></th>\n<th align=\"center\"><strong>源码地址</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>城院校易班学生工作站</strong></td>\n<td align=\"center\"><strong>城院易班微信小程序</strong></td>\n<td align=\"center\"><strong>2019-11</strong></td>\n<td align=\"center\"><strong>2个星期</strong></td>\n<td align=\"center\"><strong>无</strong></td>\n</tr>\n<tr>\n<td align=\"left\"><strong>城院校易班学生工作站</strong></td>\n<td align=\"center\"><strong>2020新年祝福专栏网站</strong></td>\n<td align=\"center\"><strong>2020-1</strong></td>\n<td align=\"center\"><strong>18天</strong></td>\n<td align=\"center\"><strong><a href=\"https://github.com/arukione/2020NewYear\" target=\"_blank\" rel=\"noopener\">https://github.com/arukione/2020NewYear</a></strong></td>\n</tr>\n</tbody></table>\n<h2 id=\"2018年\"><a href=\"#2018年\" class=\"headerlink\" title=\"2018年\"></a><a href=\"#2018年\"><strong>2018年</strong></a></h2><p><strong>加强自己对计算机的认识, 更深层地去理解计算机的工作原理</strong><br><strong>从C语言开始认识程序</strong><br><strong>接下来是自己买了服务器搭建梯子, 第一次接触脚本</strong><br><strong>慢慢的听到了许多自己没接触过的东西, 例如github、Node.js、还有前端啊, 但是自己都不知道是什么东西</strong></p>\n<h3 id=\"寒假\"><a href=\"#寒假\" class=\"headerlink\" title=\"寒假:\"></a><a href=\"#寒假\"><em>寒假:</em></a></h3><p><strong>自己买了前端的书学习, 知道了如何构建网站</strong><br><strong>参与了wiki的建设, 发现了更多自己不知道的知识</strong><br><strong>和vultr的客服交流, 开启了服务器25号端口</strong><br><strong>学习Java, 认识到了面向对象</strong></p>\n<h2 id=\"2019年\"><a href=\"#2019年\" class=\"headerlink\" title=\"2019年\"></a><a href=\"#2019年\"><strong>2019年</strong></a></h2><p><strong>访问了HackOne网站, 开始对网络安全产生兴趣</strong><br><strong>接触Linux系统</strong><br><strong>学习了github, 明白了github的作用和使用方法</strong><br><strong>接触Python, 发现Python的优点</strong><br><strong>购买了域名, 尝试搭建博客</strong><br><strong>初次使用git和githubDesktop, 并搭建了自己的博客</strong><br><strong>用githubDesktop给博客做备份</strong><br><strong>学习Linux系统和Python、Java, 开始接触数据库</strong><br><strong>学习MySQL数据库和Python</strong><br><strong>使用Python写一个爬虫, 借了数据库的书进行进一步学习和练习</strong><br><strong>学习AI, 入门机器学习</strong><br><strong>第一次写了一个可以识别数字的神经网络</strong><br><strong>学习Python数据结构</strong><br><strong>接触网络和使用刷入固件的路由器</strong></p>\n<h3 id=\"七月\"><a href=\"#七月\" class=\"headerlink\" title=\"七月:\"></a><a href=\"#七月\"><em>七月:</em></a></h3><p><strong>暑假开始使用Ubuntu系统</strong><br><strong>进一步学习机器学习算法, 入门TensorFlow深度学习框架</strong><br><strong>学习卷积神经网络结构(CNN)</strong><br><strong>学习对抗神经网络（DCGAN）</strong><br><strong>使用Tesra平台, 尝试在系统用GPU训练网络, 结果安装驱动的时候把Ubuntu系统搞坏了（呜呜呜）</strong><br><strong>开始使用Debian系统</strong></p>\n<h3 id=\"十月\"><a href=\"#十月\" class=\"headerlink\" title=\"十月:\"></a><a href=\"#十月\"><em>十月:</em></a></h3><p><strong>接触Python的web框架Django和Flask</strong><br><strong>学习小程序开发</strong><br><strong>参加蓝桥杯, 选择Python语言比赛, 参加学校培训</strong><br><strong>进行部门小程序开发, 使用Flask作为后端</strong><br><strong>买了Nginx、Flask、操作系统概念、分布式系统概念与设计、Docker技术的书</strong><br><strong>学习Nginx, 用Nginx和uWSGI给Flask搭建web服务</strong><br><strong>学习ssl, 为后端网站开启https给小程序做接口用</strong><br><strong>继续学习Flask、Nginx, 终于搞懂了KMP算法</strong><br><strong>为了给部门小朋友讲课, 制作PPT, 了解到了许多包括Android开发、Node.js和前端框架等相关的知识</strong></p>\n<h2 id=\"2020年\"><a href=\"#2020年\" class=\"headerlink\" title=\"2020年\"></a><a href=\"#2020年\"><strong>2020年</strong></a></h2><h3 id=\"一月\"><a href=\"#一月\" class=\"headerlink\" title=\"一月:\"></a><a href=\"#一月\"><em>一月:</em></a></h3><p><strong>学习Ajax, 开始了解前后端分离</strong><br><strong>第一次一个人完成了可以发文章, 带评论和点赞的网站, 学到了很多东西</strong><br><strong>重新弄博客, 换了3-hexo的主题, 自己修改styl文件配样式, 感觉和css差不多</strong><br><strong>上传了两个简单封装的pip软件包Web-MySQL和Nested-List</strong><br><strong>了解了一些开源协议, 编写了两个pip软件包在GitHub上的README说明文件</strong><br><strong>回归Java, 学习Maven</strong><br><strong>了解了SSM(SpringMVC+Spring+MyBatis)</strong><br><strong>了解一下Spring Boot和Spring Cloud</strong><br><strong>为了赶时间没有看完SSM就直接看SpringBoot了，幸好以前有用Py做Web开发的经验，学起来还算顺利</strong><br><strong>学习Docker和Redis的使用</strong><br><strong>不想使用Thymeleaf模板引擎, 学习Vue.js采用前后端分离的方式开发</strong></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"实际项目\"><a href=\"#实际项目\" class=\"headerlink\" title=\"实际项目\"></a><a href=\"#实际项目\"><strong>实际项目</strong></a></h2><table>\n<thead>\n<tr>\n<th align=\"left\"><strong>所属</strong></th>\n<th align=\"center\"><strong>项目名称</strong></th>\n<th align=\"center\"><strong>开始时间</strong></th>\n<th align=\"center\"><strong>开发周期</strong></th>\n<th align=\"center\"><strong>源码地址</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>城院校易班学生工作站</strong></td>\n<td align=\"center\"><strong>城院易班微信小程序</strong></td>\n<td align=\"center\"><strong>2019-11</strong></td>\n<td align=\"center\"><strong>2个星期</strong></td>\n<td align=\"center\"><strong>无</strong></td>\n</tr>\n<tr>\n<td align=\"left\"><strong>城院校易班学生工作站</strong></td>\n<td align=\"center\"><strong>2020新年祝福专栏网站</strong></td>\n<td align=\"center\"><strong>2020-1</strong></td>\n<td align=\"center\"><strong>18天</strong></td>\n<td align=\"center\"><strong><a href=\"https://github.com/arukione/2020NewYear\" target=\"_blank\" rel=\"noopener\">https://github.com/arukione/2020NewYear</a></strong></td>\n</tr>\n</tbody></table>\n<h2 id=\"2018年\"><a href=\"#2018年\" class=\"headerlink\" title=\"2018年\"></a><a href=\"#2018年\"><strong>2018年</strong></a></h2><p><strong>加强自己对计算机的认识, 更深层地去理解计算机的工作原理</strong><br><strong>从C语言开始认识程序</strong><br><strong>接下来是自己买了服务器搭建梯子, 第一次接触脚本</strong><br><strong>慢慢的听到了许多自己没接触过的东西, 例如github、Node.js、还有前端啊, 但是自己都不知道是什么东西</strong></p>\n<h3 id=\"寒假\"><a href=\"#寒假\" class=\"headerlink\" title=\"寒假:\"></a><a href=\"#寒假\"><em>寒假:</em></a></h3><p><strong>自己买了前端的书学习, 知道了如何构建网站</strong><br><strong>参与了wiki的建设, 发现了更多自己不知道的知识</strong><br><strong>和vultr的客服交流, 开启了服务器25号端口</strong><br><strong>学习Java, 认识到了面向对象</strong></p>\n<h2 id=\"2019年\"><a href=\"#2019年\" class=\"headerlink\" title=\"2019年\"></a><a href=\"#2019年\"><strong>2019年</strong></a></h2><p><strong>访问了HackOne网站, 开始对网络安全产生兴趣</strong><br><strong>接触Linux系统</strong><br><strong>学习了github, 明白了github的作用和使用方法</strong><br><strong>接触Python, 发现Python的优点</strong><br><strong>购买了域名, 尝试搭建博客</strong><br><strong>初次使用git和githubDesktop, 并搭建了自己的博客</strong><br><strong>用githubDesktop给博客做备份</strong><br><strong>学习Linux系统和Python、Java, 开始接触数据库</strong><br><strong>学习MySQL数据库和Python</strong><br><strong>使用Python写一个爬虫, 借了数据库的书进行进一步学习和练习</strong><br><strong>学习AI, 入门机器学习</strong><br><strong>第一次写了一个可以识别数字的神经网络</strong><br><strong>学习Python数据结构</strong><br><strong>接触网络和使用刷入固件的路由器</strong></p>\n<h3 id=\"七月\"><a href=\"#七月\" class=\"headerlink\" title=\"七月:\"></a><a href=\"#七月\"><em>七月:</em></a></h3><p><strong>暑假开始使用Ubuntu系统</strong><br><strong>进一步学习机器学习算法, 入门TensorFlow深度学习框架</strong><br><strong>学习卷积神经网络结构(CNN)</strong><br><strong>学习对抗神经网络（DCGAN）</strong><br><strong>使用Tesra平台, 尝试在系统用GPU训练网络, 结果安装驱动的时候把Ubuntu系统搞坏了（呜呜呜）</strong><br><strong>开始使用Debian系统</strong></p>\n<h3 id=\"十月\"><a href=\"#十月\" class=\"headerlink\" title=\"十月:\"></a><a href=\"#十月\"><em>十月:</em></a></h3><p><strong>接触Python的web框架Django和Flask</strong><br><strong>学习小程序开发</strong><br><strong>参加蓝桥杯, 选择Python语言比赛, 参加学校培训</strong><br><strong>进行部门小程序开发, 使用Flask作为后端</strong><br><strong>买了Nginx、Flask、操作系统概念、分布式系统概念与设计、Docker技术的书</strong><br><strong>学习Nginx, 用Nginx和uWSGI给Flask搭建web服务</strong><br><strong>学习ssl, 为后端网站开启https给小程序做接口用</strong><br><strong>继续学习Flask、Nginx, 终于搞懂了KMP算法</strong><br><strong>为了给部门小朋友讲课, 制作PPT, 了解到了许多包括Android开发、Node.js和前端框架等相关的知识</strong></p>\n<h2 id=\"2020年\"><a href=\"#2020年\" class=\"headerlink\" title=\"2020年\"></a><a href=\"#2020年\"><strong>2020年</strong></a></h2><h3 id=\"一月\"><a href=\"#一月\" class=\"headerlink\" title=\"一月:\"></a><a href=\"#一月\"><em>一月:</em></a></h3><p><strong>学习Ajax, 开始了解前后端分离</strong><br><strong>第一次一个人完成了可以发文章, 带评论和点赞的网站, 学到了很多东西</strong><br><strong>重新弄博客, 换了3-hexo的主题, 自己修改styl文件配样式, 感觉和css差不多</strong><br><strong>上传了两个简单封装的pip软件包Web-MySQL和Nested-List</strong><br><strong>了解了一些开源协议, 编写了两个pip软件包在GitHub上的README说明文件</strong><br><strong>回归Java, 学习Maven</strong><br><strong>了解了SSM(SpringMVC+Spring+MyBatis)</strong><br><strong>了解一下Spring Boot和Spring Cloud</strong><br><strong>为了赶时间没有看完SSM就直接看SpringBoot了，幸好以前有用Py做Web开发的经验，学起来还算顺利</strong><br><strong>学习Docker和Redis的使用</strong><br><strong>不想使用Thymeleaf模板引擎, 学习Vue.js采用前后端分离的方式开发</strong></p>\n"},{"title":"tags","date":"2020-01-23T07:15:26.000Z","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2020-01-23 15:15:26\n---\n","updated":"2020-01-23T07:15:26.790Z","path":"tags/index.html","comments":1,"layout":"page","_id":"ck6ywriwv002454v5fkadgw5j","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"2020.2.6 Java学习笔记","date":"2020-02-06T07:30:00.000Z","_content":"\n函数参数传的数组是引用\n---\n\n和Python一样, 如果把一个数组或者列表当做函数的参数传入, 是传了一个地址的引用, 如果在调用的函数里直接修改了数组的值, 那么原本数组的值也会跟着改变\n\n```Java\n\npublic class Hello{\n    public static void(String[] args){\n        int[] a = {1,2,3};\n        change(a);\n    }\n\n    public static void change(int[] b){\n        b[0] = 0;\n        b[1] = 0;\n    }\n}\n\n```\n\n按照上面的代码执行完, 数组a的值将会变成{0,0,3}, 可以通过克隆的方法避免这种情况, 通过调用clone()方法来获得一个复制的数组, 再传入, 此时传入的数组是另一个对象的引用了。\n\n```Java\n\npublic class Hello{\n    public static void(String[] args){\n        int[] a = {1,2,3};\n        change(a.clone());\n    }\n\n    public static void change(int[] b){\n        b[0] = 0;\n        b[1] = 0;\n    }\n}\n\n```\n\nfor-each遍历\n---\n\n大部分Collection对象都可以使用for-each遍历, 之前学过但是又给忘记了, 在这记录一下。\n\nfor-each循环的使用方法是 for(元素类型 变量名:对象), 这样就可以把Collection对象依次赋值给冒号前面的变量。\n\n例子:\n\n```Java\n\nLinkList<String> slist = new LinkList();\n\nfor(String s:slist){\n    System.out.println(s);\n}\n\nArrayList<Integer> ilist = new ArrayList();\n\nfor(int i:ilist){\n    System.out.println(i);\n}\n\n```\n\n这种遍历方式效率非常高, 但是在多线程的时候要考虑并发操作问题\n\n可参考：[JAVAschool](http://www.51gjie.com/java/639.html)\n\nList类的contains方法\n---\n\nList类和子类都有一个contains()来判断元素是否存在列表对象中, 但是这个方法的底层比较的是对象, 而不是变量和元素的值。\n\n如果列表的元素类型是String或者int等这类基本类型的话, 倒是不会有影响, 因为这类元素拿出来的数据都是常量, 所以值相同的话, 地址也是相同的。\n\n但是如果比较的是数组或者其他对象, 那就会出现匹配不到的问题, 因为两个对象的值虽然是相同的, 但是他们引用的地址却不一样, 所以无法正常判断。\n\n下面是contains的源码：\n\n```Java\n/**\n* Returns <tt>true</tt> if this list contains the specified element.\n* More formally, returns <tt>true</tt> if and only if this list contains\n* at least one element <tt>e</tt> such that\n* <tt>(o==null&nbsp;?&nbsp;e==null&nbsp;:&nbsp;o.equals(e))</tt>.\n*\n* @param o element whose presence in this list is to be tested\n* @return <tt>true</tt> if this list contains the specified element\n*/\npublic boolean contains(Object o) {\n    return indexOf(o) >= 0;\n}\n```\n\n我觉得这种设计是正确的, 符合面对对象的思想, 假如把列表当做一个班级, 元素都是学生, 刚好有两个学生的名字和年龄一模一样, 但他们的的确确是不同的两个人, 就应该是返回false, 而不是true\n\n当然这种设计有时候并不能满足我们的开发, 所以我们可以通过重写contains的方法来满足需求。\n","source":"_posts/2020.2.6 Java学习笔记.md","raw":"---\ntitle: 2020.2.6 Java学习笔记\ndate: 2020-2-6 15:30\ncategories: 学习笔记\ntags:\n    - Java\n---\n\n函数参数传的数组是引用\n---\n\n和Python一样, 如果把一个数组或者列表当做函数的参数传入, 是传了一个地址的引用, 如果在调用的函数里直接修改了数组的值, 那么原本数组的值也会跟着改变\n\n```Java\n\npublic class Hello{\n    public static void(String[] args){\n        int[] a = {1,2,3};\n        change(a);\n    }\n\n    public static void change(int[] b){\n        b[0] = 0;\n        b[1] = 0;\n    }\n}\n\n```\n\n按照上面的代码执行完, 数组a的值将会变成{0,0,3}, 可以通过克隆的方法避免这种情况, 通过调用clone()方法来获得一个复制的数组, 再传入, 此时传入的数组是另一个对象的引用了。\n\n```Java\n\npublic class Hello{\n    public static void(String[] args){\n        int[] a = {1,2,3};\n        change(a.clone());\n    }\n\n    public static void change(int[] b){\n        b[0] = 0;\n        b[1] = 0;\n    }\n}\n\n```\n\nfor-each遍历\n---\n\n大部分Collection对象都可以使用for-each遍历, 之前学过但是又给忘记了, 在这记录一下。\n\nfor-each循环的使用方法是 for(元素类型 变量名:对象), 这样就可以把Collection对象依次赋值给冒号前面的变量。\n\n例子:\n\n```Java\n\nLinkList<String> slist = new LinkList();\n\nfor(String s:slist){\n    System.out.println(s);\n}\n\nArrayList<Integer> ilist = new ArrayList();\n\nfor(int i:ilist){\n    System.out.println(i);\n}\n\n```\n\n这种遍历方式效率非常高, 但是在多线程的时候要考虑并发操作问题\n\n可参考：[JAVAschool](http://www.51gjie.com/java/639.html)\n\nList类的contains方法\n---\n\nList类和子类都有一个contains()来判断元素是否存在列表对象中, 但是这个方法的底层比较的是对象, 而不是变量和元素的值。\n\n如果列表的元素类型是String或者int等这类基本类型的话, 倒是不会有影响, 因为这类元素拿出来的数据都是常量, 所以值相同的话, 地址也是相同的。\n\n但是如果比较的是数组或者其他对象, 那就会出现匹配不到的问题, 因为两个对象的值虽然是相同的, 但是他们引用的地址却不一样, 所以无法正常判断。\n\n下面是contains的源码：\n\n```Java\n/**\n* Returns <tt>true</tt> if this list contains the specified element.\n* More formally, returns <tt>true</tt> if and only if this list contains\n* at least one element <tt>e</tt> such that\n* <tt>(o==null&nbsp;?&nbsp;e==null&nbsp;:&nbsp;o.equals(e))</tt>.\n*\n* @param o element whose presence in this list is to be tested\n* @return <tt>true</tt> if this list contains the specified element\n*/\npublic boolean contains(Object o) {\n    return indexOf(o) >= 0;\n}\n```\n\n我觉得这种设计是正确的, 符合面对对象的思想, 假如把列表当做一个班级, 元素都是学生, 刚好有两个学生的名字和年龄一模一样, 但他们的的确确是不同的两个人, 就应该是返回false, 而不是true\n\n当然这种设计有时候并不能满足我们的开发, 所以我们可以通过重写contains的方法来满足需求。\n","slug":"2020.2.6 Java学习笔记","published":1,"updated":"2020-02-06T07:18:52.439Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6ywrivg000154v5hego4oeq","content":"<h2 id=\"函数参数传的数组是引用\"><a href=\"#函数参数传的数组是引用\" class=\"headerlink\" title=\"函数参数传的数组是引用\"></a>函数参数传的数组是引用</h2><p>和Python一样, 如果把一个数组或者列表当做函数的参数传入, 是传了一个地址的引用, 如果在调用的函数里直接修改了数组的值, 那么原本数组的值也会跟着改变</p>\n<pre><code class=\"Java\">\npublic class Hello{\n    public static void(String[] args){\n        int[] a = {1,2,3};\n        change(a);\n    }\n\n    public static void change(int[] b){\n        b[0] = 0;\n        b[1] = 0;\n    }\n}\n</code></pre>\n<p>按照上面的代码执行完, 数组a的值将会变成{0,0,3}, 可以通过克隆的方法避免这种情况, 通过调用clone()方法来获得一个复制的数组, 再传入, 此时传入的数组是另一个对象的引用了。</p>\n<pre><code class=\"Java\">\npublic class Hello{\n    public static void(String[] args){\n        int[] a = {1,2,3};\n        change(a.clone());\n    }\n\n    public static void change(int[] b){\n        b[0] = 0;\n        b[1] = 0;\n    }\n}\n</code></pre>\n<h2 id=\"for-each遍历\"><a href=\"#for-each遍历\" class=\"headerlink\" title=\"for-each遍历\"></a>for-each遍历</h2><p>大部分Collection对象都可以使用for-each遍历, 之前学过但是又给忘记了, 在这记录一下。</p>\n<p>for-each循环的使用方法是 for(元素类型 变量名:对象), 这样就可以把Collection对象依次赋值给冒号前面的变量。</p>\n<p>例子:</p>\n<pre><code class=\"Java\">\nLinkList&lt;String&gt; slist = new LinkList();\n\nfor(String s:slist){\n    System.out.println(s);\n}\n\nArrayList&lt;Integer&gt; ilist = new ArrayList();\n\nfor(int i:ilist){\n    System.out.println(i);\n}\n</code></pre>\n<p>这种遍历方式效率非常高, 但是在多线程的时候要考虑并发操作问题</p>\n<p>可参考：<a href=\"http://www.51gjie.com/java/639.html\" target=\"_blank\" rel=\"noopener\">JAVAschool</a></p>\n<h2 id=\"List类的contains方法\"><a href=\"#List类的contains方法\" class=\"headerlink\" title=\"List类的contains方法\"></a>List类的contains方法</h2><p>List类和子类都有一个contains()来判断元素是否存在列表对象中, 但是这个方法的底层比较的是对象, 而不是变量和元素的值。</p>\n<p>如果列表的元素类型是String或者int等这类基本类型的话, 倒是不会有影响, 因为这类元素拿出来的数据都是常量, 所以值相同的话, 地址也是相同的。</p>\n<p>但是如果比较的是数组或者其他对象, 那就会出现匹配不到的问题, 因为两个对象的值虽然是相同的, 但是他们引用的地址却不一样, 所以无法正常判断。</p>\n<p>下面是contains的源码：</p>\n<pre><code class=\"Java\">/**\n* Returns &lt;tt&gt;true&lt;/tt&gt; if this list contains the specified element.\n* More formally, returns &lt;tt&gt;true&lt;/tt&gt; if and only if this list contains\n* at least one element &lt;tt&gt;e&lt;/tt&gt; such that\n* &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;e==null&amp;nbsp;:&amp;nbsp;o.equals(e))&lt;/tt&gt;.\n*\n* @param o element whose presence in this list is to be tested\n* @return &lt;tt&gt;true&lt;/tt&gt; if this list contains the specified element\n*/\npublic boolean contains(Object o) {\n    return indexOf(o) &gt;= 0;\n}</code></pre>\n<p>我觉得这种设计是正确的, 符合面对对象的思想, 假如把列表当做一个班级, 元素都是学生, 刚好有两个学生的名字和年龄一模一样, 但他们的的确确是不同的两个人, 就应该是返回false, 而不是true</p>\n<p>当然这种设计有时候并不能满足我们的开发, 所以我们可以通过重写contains的方法来满足需求。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"函数参数传的数组是引用\"><a href=\"#函数参数传的数组是引用\" class=\"headerlink\" title=\"函数参数传的数组是引用\"></a>函数参数传的数组是引用</h2><p>和Python一样, 如果把一个数组或者列表当做函数的参数传入, 是传了一个地址的引用, 如果在调用的函数里直接修改了数组的值, 那么原本数组的值也会跟着改变</p>\n<pre><code class=\"Java\">\npublic class Hello{\n    public static void(String[] args){\n        int[] a = {1,2,3};\n        change(a);\n    }\n\n    public static void change(int[] b){\n        b[0] = 0;\n        b[1] = 0;\n    }\n}\n</code></pre>\n<p>按照上面的代码执行完, 数组a的值将会变成{0,0,3}, 可以通过克隆的方法避免这种情况, 通过调用clone()方法来获得一个复制的数组, 再传入, 此时传入的数组是另一个对象的引用了。</p>\n<pre><code class=\"Java\">\npublic class Hello{\n    public static void(String[] args){\n        int[] a = {1,2,3};\n        change(a.clone());\n    }\n\n    public static void change(int[] b){\n        b[0] = 0;\n        b[1] = 0;\n    }\n}\n</code></pre>\n<h2 id=\"for-each遍历\"><a href=\"#for-each遍历\" class=\"headerlink\" title=\"for-each遍历\"></a>for-each遍历</h2><p>大部分Collection对象都可以使用for-each遍历, 之前学过但是又给忘记了, 在这记录一下。</p>\n<p>for-each循环的使用方法是 for(元素类型 变量名:对象), 这样就可以把Collection对象依次赋值给冒号前面的变量。</p>\n<p>例子:</p>\n<pre><code class=\"Java\">\nLinkList&lt;String&gt; slist = new LinkList();\n\nfor(String s:slist){\n    System.out.println(s);\n}\n\nArrayList&lt;Integer&gt; ilist = new ArrayList();\n\nfor(int i:ilist){\n    System.out.println(i);\n}\n</code></pre>\n<p>这种遍历方式效率非常高, 但是在多线程的时候要考虑并发操作问题</p>\n<p>可参考：<a href=\"http://www.51gjie.com/java/639.html\" target=\"_blank\" rel=\"noopener\">JAVAschool</a></p>\n<h2 id=\"List类的contains方法\"><a href=\"#List类的contains方法\" class=\"headerlink\" title=\"List类的contains方法\"></a>List类的contains方法</h2><p>List类和子类都有一个contains()来判断元素是否存在列表对象中, 但是这个方法的底层比较的是对象, 而不是变量和元素的值。</p>\n<p>如果列表的元素类型是String或者int等这类基本类型的话, 倒是不会有影响, 因为这类元素拿出来的数据都是常量, 所以值相同的话, 地址也是相同的。</p>\n<p>但是如果比较的是数组或者其他对象, 那就会出现匹配不到的问题, 因为两个对象的值虽然是相同的, 但是他们引用的地址却不一样, 所以无法正常判断。</p>\n<p>下面是contains的源码：</p>\n<pre><code class=\"Java\">/**\n* Returns &lt;tt&gt;true&lt;/tt&gt; if this list contains the specified element.\n* More formally, returns &lt;tt&gt;true&lt;/tt&gt; if and only if this list contains\n* at least one element &lt;tt&gt;e&lt;/tt&gt; such that\n* &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;e==null&amp;nbsp;:&amp;nbsp;o.equals(e))&lt;/tt&gt;.\n*\n* @param o element whose presence in this list is to be tested\n* @return &lt;tt&gt;true&lt;/tt&gt; if this list contains the specified element\n*/\npublic boolean contains(Object o) {\n    return indexOf(o) &gt;= 0;\n}</code></pre>\n<p>我觉得这种设计是正确的, 符合面对对象的思想, 假如把列表当做一个班级, 元素都是学生, 刚好有两个学生的名字和年龄一模一样, 但他们的的确确是不同的两个人, 就应该是返回false, 而不是true</p>\n<p>当然这种设计有时候并不能满足我们的开发, 所以我们可以通过重写contains的方法来满足需求。</p>\n"},{"title":"Nginx性能优化配置","date":"2020-02-07T19:30:00.000Z","_content":"\n在Nginx中，是由master进程来管理worker进程的工作，由worker进程来处理http请求。\n一个worker进程可以同时处理多个请求，其处理的请求数只受限于内存大小，并且不同的worker进程之间处理并发请求几乎没有同步锁的限制，worker进程通常不会进入睡眠状态。\n\n多个worker进程处理互联网请求既可以实现多核并发处理，也可以提高服务的健壮性，所以worker进程的数量将会直接影响性能。\n在master/worker运行方式下，我们可以通过修改worker_processes配置项的值来配置worker的进程数\n\n```Nginx\n语法: worker_processes number;\n默认: worker_processes 1;\n```\n\n**进程数量的设置和业务以及CPU内核数有关:**\n\nworker进程都是单线程进程，会调用各个模块来实现功能。\n如果这些模块不会出现阻塞式的调用，通常有多少个CPU内核就配置多少个进程数量。\n如果可能出现阻塞式调用，则需要配置稍多一些的worker进程。\n\n**什么是阻塞式调用？**例如用户请求会读取本地磁盘的静态资源文件，且服务器内存小，大部分的请求访问静态资源文件时都必须读取磁盘，而不是内存中的磁盘缓存，那么磁盘I/O的调用可能会阻塞住worker进程少量时间，导致服务整体性能下降。\n\n多worker进程可以充分利用多核系统架构，但worker进程的数量多于CPU内核数，将会增大进程间切换带来的消耗(Linux是抢占式内核)，这也是为什么要配置和CPU内核数量一致的进程数的原因。\n\n**配置与内核数量相等的worker进程时，要绑定CPU内核:**\n\n假如每一个worker进程都非常繁忙，多个worker进程都在抢同一个CUP的话，会出现同步问题。反之，如果每一个worker进程都独享一个CPU，就在内核的调度策略上实现了完全的并发。\n\n我们可以通过worker_cpu_affinity绑定Nginx worker进程到指定的CPU内存:\n\n```Nginx\n语法: worker_cpu_affinity cpumask [cpumask...]\n默认: -\n```\n\n例如你有4个CPU内核，可在配置文件中进行如下配置，将进程数配置为4，绑定每个工作进程到单个CPU里:\n\n```Nginx\nworker_processes 4;\nworker_cpu_affinity 1000 0100 0010 0001;\n```\n\n如果使用下面的配置的话，将会把第一个worker进程绑定到CPU0/CPU2，第二个进程绑定到CPU1/CPU3:\n\n```Nginx\nworker_processes 2;\nworker_cpu_affinity 0101 1010;\n```\n\n使用auto值可自动将worker进程绑定到可用CPU:\n\n```Nginx\nworker_cpu_affinity auto;\n```\n\nworker_cpu_affinity配置仅对Linux操作系统有效。\nLinux操作系统使用sched_setaffinity()系统调用实现这个功能。\n\n**优先级设置:**\n\n在Linux或者其它类UNIX操作系统中，当许多进程都处于可执行状态时，会按照所有进程的优先级来决定本次内核执行哪个进程，进程分配的CPU时间片大小也与进程优先级相关，优先级越高进程分配到的时间片越大。\n\n我们可以通过worker_priority配置项来设置worker进程的nice优先级\n\n```Nginx\n语法: worker_priority nice;\n默认: worker_priority 0;\n```\n\nnice值是进程的静态优先级，他的取值范围是-20 ~ +19，-20是最高优先级，+19是最低优先级；\n优先级由静态优先级和内核根据进程执行情况所做的动态调整(目前只有±5的调整)共同决定。\n优先级高的进程会会占用更多的系统资源，如果希望Nginx占用更多的系统资源，可以把nice的值配置得小一点；\n一般分配时不建议nice的值比内核进程的nice值(通常为-5)还要小。\n\n**SSL硬件加速:**\n\n如果服务器上有SSL硬件加速设备，可以进行配置加快SSL协议的处理速度。\n\n通过OpenSSL的命令查看是否有SSL硬件加速设备: `openssl engine -t`\n\nNginx配置加速:\n\n```Nginx\nssl_engine device;\n```\n\n>参考书籍《深入理解Nginx 模块开发与架构解析 第2版》 陶辉 著 机械工业出版社\n","source":"_posts/Nginx性能优化-worke进程.md","raw":"---\ntitle: Nginx性能优化配置\ndate: 2020-2-8 3:30\ncategories: 学习笔记\ntags:\n    - Nginx\n---\n\n在Nginx中，是由master进程来管理worker进程的工作，由worker进程来处理http请求。\n一个worker进程可以同时处理多个请求，其处理的请求数只受限于内存大小，并且不同的worker进程之间处理并发请求几乎没有同步锁的限制，worker进程通常不会进入睡眠状态。\n\n多个worker进程处理互联网请求既可以实现多核并发处理，也可以提高服务的健壮性，所以worker进程的数量将会直接影响性能。\n在master/worker运行方式下，我们可以通过修改worker_processes配置项的值来配置worker的进程数\n\n```Nginx\n语法: worker_processes number;\n默认: worker_processes 1;\n```\n\n**进程数量的设置和业务以及CPU内核数有关:**\n\nworker进程都是单线程进程，会调用各个模块来实现功能。\n如果这些模块不会出现阻塞式的调用，通常有多少个CPU内核就配置多少个进程数量。\n如果可能出现阻塞式调用，则需要配置稍多一些的worker进程。\n\n**什么是阻塞式调用？**例如用户请求会读取本地磁盘的静态资源文件，且服务器内存小，大部分的请求访问静态资源文件时都必须读取磁盘，而不是内存中的磁盘缓存，那么磁盘I/O的调用可能会阻塞住worker进程少量时间，导致服务整体性能下降。\n\n多worker进程可以充分利用多核系统架构，但worker进程的数量多于CPU内核数，将会增大进程间切换带来的消耗(Linux是抢占式内核)，这也是为什么要配置和CPU内核数量一致的进程数的原因。\n\n**配置与内核数量相等的worker进程时，要绑定CPU内核:**\n\n假如每一个worker进程都非常繁忙，多个worker进程都在抢同一个CUP的话，会出现同步问题。反之，如果每一个worker进程都独享一个CPU，就在内核的调度策略上实现了完全的并发。\n\n我们可以通过worker_cpu_affinity绑定Nginx worker进程到指定的CPU内存:\n\n```Nginx\n语法: worker_cpu_affinity cpumask [cpumask...]\n默认: -\n```\n\n例如你有4个CPU内核，可在配置文件中进行如下配置，将进程数配置为4，绑定每个工作进程到单个CPU里:\n\n```Nginx\nworker_processes 4;\nworker_cpu_affinity 1000 0100 0010 0001;\n```\n\n如果使用下面的配置的话，将会把第一个worker进程绑定到CPU0/CPU2，第二个进程绑定到CPU1/CPU3:\n\n```Nginx\nworker_processes 2;\nworker_cpu_affinity 0101 1010;\n```\n\n使用auto值可自动将worker进程绑定到可用CPU:\n\n```Nginx\nworker_cpu_affinity auto;\n```\n\nworker_cpu_affinity配置仅对Linux操作系统有效。\nLinux操作系统使用sched_setaffinity()系统调用实现这个功能。\n\n**优先级设置:**\n\n在Linux或者其它类UNIX操作系统中，当许多进程都处于可执行状态时，会按照所有进程的优先级来决定本次内核执行哪个进程，进程分配的CPU时间片大小也与进程优先级相关，优先级越高进程分配到的时间片越大。\n\n我们可以通过worker_priority配置项来设置worker进程的nice优先级\n\n```Nginx\n语法: worker_priority nice;\n默认: worker_priority 0;\n```\n\nnice值是进程的静态优先级，他的取值范围是-20 ~ +19，-20是最高优先级，+19是最低优先级；\n优先级由静态优先级和内核根据进程执行情况所做的动态调整(目前只有±5的调整)共同决定。\n优先级高的进程会会占用更多的系统资源，如果希望Nginx占用更多的系统资源，可以把nice的值配置得小一点；\n一般分配时不建议nice的值比内核进程的nice值(通常为-5)还要小。\n\n**SSL硬件加速:**\n\n如果服务器上有SSL硬件加速设备，可以进行配置加快SSL协议的处理速度。\n\n通过OpenSSL的命令查看是否有SSL硬件加速设备: `openssl engine -t`\n\nNginx配置加速:\n\n```Nginx\nssl_engine device;\n```\n\n>参考书籍《深入理解Nginx 模块开发与架构解析 第2版》 陶辉 著 机械工业出版社\n","slug":"Nginx性能优化-worke进程","published":1,"updated":"2020-02-08T12:28:24.832Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6ywrivj000254v55naf1bqj","content":"<p>在Nginx中，是由master进程来管理worker进程的工作，由worker进程来处理http请求。<br>一个worker进程可以同时处理多个请求，其处理的请求数只受限于内存大小，并且不同的worker进程之间处理并发请求几乎没有同步锁的限制，worker进程通常不会进入睡眠状态。</p>\n<p>多个worker进程处理互联网请求既可以实现多核并发处理，也可以提高服务的健壮性，所以worker进程的数量将会直接影响性能。<br>在master/worker运行方式下，我们可以通过修改worker_processes配置项的值来配置worker的进程数</p>\n<pre><code class=\"Nginx\">语法: worker_processes number;\n默认: worker_processes 1;</code></pre>\n<p><strong>进程数量的设置和业务以及CPU内核数有关:</strong></p>\n<p>worker进程都是单线程进程，会调用各个模块来实现功能。<br>如果这些模块不会出现阻塞式的调用，通常有多少个CPU内核就配置多少个进程数量。<br>如果可能出现阻塞式调用，则需要配置稍多一些的worker进程。</p>\n<p><strong>什么是阻塞式调用？</strong>例如用户请求会读取本地磁盘的静态资源文件，且服务器内存小，大部分的请求访问静态资源文件时都必须读取磁盘，而不是内存中的磁盘缓存，那么磁盘I/O的调用可能会阻塞住worker进程少量时间，导致服务整体性能下降。</p>\n<p>多worker进程可以充分利用多核系统架构，但worker进程的数量多于CPU内核数，将会增大进程间切换带来的消耗(Linux是抢占式内核)，这也是为什么要配置和CPU内核数量一致的进程数的原因。</p>\n<p><strong>配置与内核数量相等的worker进程时，要绑定CPU内核:</strong></p>\n<p>假如每一个worker进程都非常繁忙，多个worker进程都在抢同一个CUP的话，会出现同步问题。反之，如果每一个worker进程都独享一个CPU，就在内核的调度策略上实现了完全的并发。</p>\n<p>我们可以通过worker_cpu_affinity绑定Nginx worker进程到指定的CPU内存:</p>\n<pre><code class=\"Nginx\">语法: worker_cpu_affinity cpumask [cpumask...]\n默认: -</code></pre>\n<p>例如你有4个CPU内核，可在配置文件中进行如下配置，将进程数配置为4，绑定每个工作进程到单个CPU里:</p>\n<pre><code class=\"Nginx\">worker_processes 4;\nworker_cpu_affinity 1000 0100 0010 0001;</code></pre>\n<p>如果使用下面的配置的话，将会把第一个worker进程绑定到CPU0/CPU2，第二个进程绑定到CPU1/CPU3:</p>\n<pre><code class=\"Nginx\">worker_processes 2;\nworker_cpu_affinity 0101 1010;</code></pre>\n<p>使用auto值可自动将worker进程绑定到可用CPU:</p>\n<pre><code class=\"Nginx\">worker_cpu_affinity auto;</code></pre>\n<p>worker_cpu_affinity配置仅对Linux操作系统有效。<br>Linux操作系统使用sched_setaffinity()系统调用实现这个功能。</p>\n<p><strong>优先级设置:</strong></p>\n<p>在Linux或者其它类UNIX操作系统中，当许多进程都处于可执行状态时，会按照所有进程的优先级来决定本次内核执行哪个进程，进程分配的CPU时间片大小也与进程优先级相关，优先级越高进程分配到的时间片越大。</p>\n<p>我们可以通过worker_priority配置项来设置worker进程的nice优先级</p>\n<pre><code class=\"Nginx\">语法: worker_priority nice;\n默认: worker_priority 0;</code></pre>\n<p>nice值是进程的静态优先级，他的取值范围是-20 ~ +19，-20是最高优先级，+19是最低优先级；<br>优先级由静态优先级和内核根据进程执行情况所做的动态调整(目前只有±5的调整)共同决定。<br>优先级高的进程会会占用更多的系统资源，如果希望Nginx占用更多的系统资源，可以把nice的值配置得小一点；<br>一般分配时不建议nice的值比内核进程的nice值(通常为-5)还要小。</p>\n<p><strong>SSL硬件加速:</strong></p>\n<p>如果服务器上有SSL硬件加速设备，可以进行配置加快SSL协议的处理速度。</p>\n<p>通过OpenSSL的命令查看是否有SSL硬件加速设备: <code>openssl engine -t</code></p>\n<p>Nginx配置加速:</p>\n<pre><code class=\"Nginx\">ssl_engine device;</code></pre>\n<blockquote>\n<p>参考书籍《深入理解Nginx 模块开发与架构解析 第2版》 陶辉 著 机械工业出版社</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<p>在Nginx中，是由master进程来管理worker进程的工作，由worker进程来处理http请求。<br>一个worker进程可以同时处理多个请求，其处理的请求数只受限于内存大小，并且不同的worker进程之间处理并发请求几乎没有同步锁的限制，worker进程通常不会进入睡眠状态。</p>\n<p>多个worker进程处理互联网请求既可以实现多核并发处理，也可以提高服务的健壮性，所以worker进程的数量将会直接影响性能。<br>在master/worker运行方式下，我们可以通过修改worker_processes配置项的值来配置worker的进程数</p>\n<pre><code class=\"Nginx\">语法: worker_processes number;\n默认: worker_processes 1;</code></pre>\n<p><strong>进程数量的设置和业务以及CPU内核数有关:</strong></p>\n<p>worker进程都是单线程进程，会调用各个模块来实现功能。<br>如果这些模块不会出现阻塞式的调用，通常有多少个CPU内核就配置多少个进程数量。<br>如果可能出现阻塞式调用，则需要配置稍多一些的worker进程。</p>\n<p><strong>什么是阻塞式调用？</strong>例如用户请求会读取本地磁盘的静态资源文件，且服务器内存小，大部分的请求访问静态资源文件时都必须读取磁盘，而不是内存中的磁盘缓存，那么磁盘I/O的调用可能会阻塞住worker进程少量时间，导致服务整体性能下降。</p>\n<p>多worker进程可以充分利用多核系统架构，但worker进程的数量多于CPU内核数，将会增大进程间切换带来的消耗(Linux是抢占式内核)，这也是为什么要配置和CPU内核数量一致的进程数的原因。</p>\n<p><strong>配置与内核数量相等的worker进程时，要绑定CPU内核:</strong></p>\n<p>假如每一个worker进程都非常繁忙，多个worker进程都在抢同一个CUP的话，会出现同步问题。反之，如果每一个worker进程都独享一个CPU，就在内核的调度策略上实现了完全的并发。</p>\n<p>我们可以通过worker_cpu_affinity绑定Nginx worker进程到指定的CPU内存:</p>\n<pre><code class=\"Nginx\">语法: worker_cpu_affinity cpumask [cpumask...]\n默认: -</code></pre>\n<p>例如你有4个CPU内核，可在配置文件中进行如下配置，将进程数配置为4，绑定每个工作进程到单个CPU里:</p>\n<pre><code class=\"Nginx\">worker_processes 4;\nworker_cpu_affinity 1000 0100 0010 0001;</code></pre>\n<p>如果使用下面的配置的话，将会把第一个worker进程绑定到CPU0/CPU2，第二个进程绑定到CPU1/CPU3:</p>\n<pre><code class=\"Nginx\">worker_processes 2;\nworker_cpu_affinity 0101 1010;</code></pre>\n<p>使用auto值可自动将worker进程绑定到可用CPU:</p>\n<pre><code class=\"Nginx\">worker_cpu_affinity auto;</code></pre>\n<p>worker_cpu_affinity配置仅对Linux操作系统有效。<br>Linux操作系统使用sched_setaffinity()系统调用实现这个功能。</p>\n<p><strong>优先级设置:</strong></p>\n<p>在Linux或者其它类UNIX操作系统中，当许多进程都处于可执行状态时，会按照所有进程的优先级来决定本次内核执行哪个进程，进程分配的CPU时间片大小也与进程优先级相关，优先级越高进程分配到的时间片越大。</p>\n<p>我们可以通过worker_priority配置项来设置worker进程的nice优先级</p>\n<pre><code class=\"Nginx\">语法: worker_priority nice;\n默认: worker_priority 0;</code></pre>\n<p>nice值是进程的静态优先级，他的取值范围是-20 ~ +19，-20是最高优先级，+19是最低优先级；<br>优先级由静态优先级和内核根据进程执行情况所做的动态调整(目前只有±5的调整)共同决定。<br>优先级高的进程会会占用更多的系统资源，如果希望Nginx占用更多的系统资源，可以把nice的值配置得小一点；<br>一般分配时不建议nice的值比内核进程的nice值(通常为-5)还要小。</p>\n<p><strong>SSL硬件加速:</strong></p>\n<p>如果服务器上有SSL硬件加速设备，可以进行配置加快SSL协议的处理速度。</p>\n<p>通过OpenSSL的命令查看是否有SSL硬件加速设备: <code>openssl engine -t</code></p>\n<p>Nginx配置加速:</p>\n<pre><code class=\"Nginx\">ssl_engine device;</code></pre>\n<blockquote>\n<p>参考书籍《深入理解Nginx 模块开发与架构解析 第2版》 陶辉 著 机械工业出版社</p>\n</blockquote>\n"},{"title":"MySQL安装到登陆的问题","date":"2019-04-07T16:00:00.000Z","_content":"\n**经过一晚上的折腾，我终于登陆进数据库了！！这期间遇到了不少问题，虽然网上有很多解决方案，但要找到适用的真的不容易，每个问题都花了很长时间去尝试那些指令，绕了很多弯路才解决。**\n\n### 端口冲突\n\n**安装完遇到的第一个问题就是，没办法打开mysql服务，删了安装目录下的date文件夹重新用`mysqld --initialize`初始化，重新配置my.ini文件都没用。**\n**之后用`mysqld --console`查了错误信息发现了端口被占用了：**\n>**[ERROR] Can't start server: Bind on TCP/IP port: Address already in use**\n>**[ERROR] Do you already have another mysqld server running on port: 3306 ?**\n\n**因为我这边的命令行无法识别`netstat -nltp|grep mysql`，到后面才用`netstat  -aon|findstr 3306`查到了占用3306端口的进程，记住了进程后面的PID号，用`taskkil /f /pid 对应的PID号`把进程给杀了才解决问题**\n\n### 无法登陆\n\n**耗了一些时间后，我用`net start mysql`开启了数据库后，用`mysql -uroot -密码`尝试登陆，结果又报了一个这样的错误**\n>**mysql: [ERROR] mysql: unknown option '-R'.**\n\n**于是用`mysql -uroot -p`后再输入密码,才知道原先输入密码前也要加个p，也就是`mysql -uroot -p密码`。**\n**但是接下来又报了一个错误**\n>**mysql: [Warning] Using a password on the command line interface can be insecure.**\n>**ERROR 1045 (28000): Access denied for user 'root'@'localhost' (using password: YES)**\n**查了一下发现是密码错误，因为我输入的是安装时的密码，但是初始化的时候密码重置了，所以密码错了，所以我又绕了一次弯路，把date删了重新初始化了一遍，把初始化输出的临时密码记了下来**\n>**[Note] A temporary password is generated for root@localhost: TKk51x#bOi0S**\n**之后就可以成功登陆了**\n\n### 修改密码\n\n**登陆后没办法使用其他语句，说是必须修改一下密码，而且自动生成的密码太难记了，我想改回自己的密码，但是在网上查了很多指令都用不成功，错误提示的ALTER USER语句也不知道怎么用，所以又上网馊了一下，还看了一下官方文档，总结就是看不懂~~**\n**查到最后终于发现了一个可以用的语句**\n>`alter user 'root'@'localhost' identified by 'password';`\n\n**这下问题终于解决了，可以开始进一步学习了。**\n\n**虽然遇到了很多问题，但是也知道了很多MySQL和命令行的语句，有些没派上用场就是了，至少折腾了一夜一些有用的语句都变熟悉了。**\n","source":"_posts/MySQL安装到登陆的问题.md","raw":"---\ntitle: MySQL安装到登陆的问题\ndate: 2019-4-8\ncategories: 学习笔记\ntags:\n    - MySQL\n---\n\n**经过一晚上的折腾，我终于登陆进数据库了！！这期间遇到了不少问题，虽然网上有很多解决方案，但要找到适用的真的不容易，每个问题都花了很长时间去尝试那些指令，绕了很多弯路才解决。**\n\n### 端口冲突\n\n**安装完遇到的第一个问题就是，没办法打开mysql服务，删了安装目录下的date文件夹重新用`mysqld --initialize`初始化，重新配置my.ini文件都没用。**\n**之后用`mysqld --console`查了错误信息发现了端口被占用了：**\n>**[ERROR] Can't start server: Bind on TCP/IP port: Address already in use**\n>**[ERROR] Do you already have another mysqld server running on port: 3306 ?**\n\n**因为我这边的命令行无法识别`netstat -nltp|grep mysql`，到后面才用`netstat  -aon|findstr 3306`查到了占用3306端口的进程，记住了进程后面的PID号，用`taskkil /f /pid 对应的PID号`把进程给杀了才解决问题**\n\n### 无法登陆\n\n**耗了一些时间后，我用`net start mysql`开启了数据库后，用`mysql -uroot -密码`尝试登陆，结果又报了一个这样的错误**\n>**mysql: [ERROR] mysql: unknown option '-R'.**\n\n**于是用`mysql -uroot -p`后再输入密码,才知道原先输入密码前也要加个p，也就是`mysql -uroot -p密码`。**\n**但是接下来又报了一个错误**\n>**mysql: [Warning] Using a password on the command line interface can be insecure.**\n>**ERROR 1045 (28000): Access denied for user 'root'@'localhost' (using password: YES)**\n**查了一下发现是密码错误，因为我输入的是安装时的密码，但是初始化的时候密码重置了，所以密码错了，所以我又绕了一次弯路，把date删了重新初始化了一遍，把初始化输出的临时密码记了下来**\n>**[Note] A temporary password is generated for root@localhost: TKk51x#bOi0S**\n**之后就可以成功登陆了**\n\n### 修改密码\n\n**登陆后没办法使用其他语句，说是必须修改一下密码，而且自动生成的密码太难记了，我想改回自己的密码，但是在网上查了很多指令都用不成功，错误提示的ALTER USER语句也不知道怎么用，所以又上网馊了一下，还看了一下官方文档，总结就是看不懂~~**\n**查到最后终于发现了一个可以用的语句**\n>`alter user 'root'@'localhost' identified by 'password';`\n\n**这下问题终于解决了，可以开始进一步学习了。**\n\n**虽然遇到了很多问题，但是也知道了很多MySQL和命令行的语句，有些没派上用场就是了，至少折腾了一夜一些有用的语句都变熟悉了。**\n","slug":"MySQL安装到登陆的问题","published":1,"updated":"2020-02-06T05:38:03.441Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6ywrivn000554v5h3se6cwf","content":"<p><strong>经过一晚上的折腾，我终于登陆进数据库了！！这期间遇到了不少问题，虽然网上有很多解决方案，但要找到适用的真的不容易，每个问题都花了很长时间去尝试那些指令，绕了很多弯路才解决。</strong></p>\n<h3 id=\"端口冲突\"><a href=\"#端口冲突\" class=\"headerlink\" title=\"端口冲突\"></a>端口冲突</h3><p><strong>安装完遇到的第一个问题就是，没办法打开mysql服务，删了安装目录下的date文件夹重新用<code>mysqld --initialize</code>初始化，重新配置my.ini文件都没用。</strong><br><strong>之后用<code>mysqld --console</code>查了错误信息发现了端口被占用了：</strong></p>\n<blockquote>\n<p><strong>[ERROR] Can’t start server: Bind on TCP/IP port: Address already in use</strong><br><strong>[ERROR] Do you already have another mysqld server running on port: 3306 ?</strong></p>\n</blockquote>\n<p><strong>因为我这边的命令行无法识别<code>netstat -nltp|grep mysql</code>，到后面才用<code>netstat  -aon|findstr 3306</code>查到了占用3306端口的进程，记住了进程后面的PID号，用<code>taskkil /f /pid 对应的PID号</code>把进程给杀了才解决问题</strong></p>\n<h3 id=\"无法登陆\"><a href=\"#无法登陆\" class=\"headerlink\" title=\"无法登陆\"></a>无法登陆</h3><p><strong>耗了一些时间后，我用<code>net start mysql</code>开启了数据库后，用<code>mysql -uroot -密码</code>尝试登陆，结果又报了一个这样的错误</strong></p>\n<blockquote>\n<p><strong>mysql: [ERROR] mysql: unknown option ‘-R’.</strong></p>\n</blockquote>\n<p><strong>于是用<code>mysql -uroot -p</code>后再输入密码,才知道原先输入密码前也要加个p，也就是<code>mysql -uroot -p密码</code>。</strong><br><strong>但是接下来又报了一个错误</strong></p>\n<blockquote>\n<p><strong>mysql: [Warning] Using a password on the command line interface can be insecure.</strong><br><strong>ERROR 1045 (28000): Access denied for user ‘root’@’localhost’ (using password: YES)</strong><br><strong>查了一下发现是密码错误，因为我输入的是安装时的密码，但是初始化的时候密码重置了，所以密码错了，所以我又绕了一次弯路，把date删了重新初始化了一遍，把初始化输出的临时密码记了下来</strong><br><strong>[Note] A temporary password is generated for root@localhost: TKk51x#bOi0S</strong><br><strong>之后就可以成功登陆了</strong></p>\n</blockquote>\n<h3 id=\"修改密码\"><a href=\"#修改密码\" class=\"headerlink\" title=\"修改密码\"></a>修改密码</h3><p><strong>登陆后没办法使用其他语句，说是必须修改一下密码，而且自动生成的密码太难记了，我想改回自己的密码，但是在网上查了很多指令都用不成功，错误提示的ALTER USER语句也不知道怎么用，所以又上网馊了一下，还看了一下官方文档，总结就是看不懂~~</strong><br><strong>查到最后终于发现了一个可以用的语句</strong></p>\n<blockquote>\n<p><code>alter user &#39;root&#39;@&#39;localhost&#39; identified by &#39;password&#39;;</code></p>\n</blockquote>\n<p><strong>这下问题终于解决了，可以开始进一步学习了。</strong></p>\n<p><strong>虽然遇到了很多问题，但是也知道了很多MySQL和命令行的语句，有些没派上用场就是了，至少折腾了一夜一些有用的语句都变熟悉了。</strong></p>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>经过一晚上的折腾，我终于登陆进数据库了！！这期间遇到了不少问题，虽然网上有很多解决方案，但要找到适用的真的不容易，每个问题都花了很长时间去尝试那些指令，绕了很多弯路才解决。</strong></p>\n<h3 id=\"端口冲突\"><a href=\"#端口冲突\" class=\"headerlink\" title=\"端口冲突\"></a>端口冲突</h3><p><strong>安装完遇到的第一个问题就是，没办法打开mysql服务，删了安装目录下的date文件夹重新用<code>mysqld --initialize</code>初始化，重新配置my.ini文件都没用。</strong><br><strong>之后用<code>mysqld --console</code>查了错误信息发现了端口被占用了：</strong></p>\n<blockquote>\n<p><strong>[ERROR] Can’t start server: Bind on TCP/IP port: Address already in use</strong><br><strong>[ERROR] Do you already have another mysqld server running on port: 3306 ?</strong></p>\n</blockquote>\n<p><strong>因为我这边的命令行无法识别<code>netstat -nltp|grep mysql</code>，到后面才用<code>netstat  -aon|findstr 3306</code>查到了占用3306端口的进程，记住了进程后面的PID号，用<code>taskkil /f /pid 对应的PID号</code>把进程给杀了才解决问题</strong></p>\n<h3 id=\"无法登陆\"><a href=\"#无法登陆\" class=\"headerlink\" title=\"无法登陆\"></a>无法登陆</h3><p><strong>耗了一些时间后，我用<code>net start mysql</code>开启了数据库后，用<code>mysql -uroot -密码</code>尝试登陆，结果又报了一个这样的错误</strong></p>\n<blockquote>\n<p><strong>mysql: [ERROR] mysql: unknown option ‘-R’.</strong></p>\n</blockquote>\n<p><strong>于是用<code>mysql -uroot -p</code>后再输入密码,才知道原先输入密码前也要加个p，也就是<code>mysql -uroot -p密码</code>。</strong><br><strong>但是接下来又报了一个错误</strong></p>\n<blockquote>\n<p><strong>mysql: [Warning] Using a password on the command line interface can be insecure.</strong><br><strong>ERROR 1045 (28000): Access denied for user ‘root’@’localhost’ (using password: YES)</strong><br><strong>查了一下发现是密码错误，因为我输入的是安装时的密码，但是初始化的时候密码重置了，所以密码错了，所以我又绕了一次弯路，把date删了重新初始化了一遍，把初始化输出的临时密码记了下来</strong><br><strong>[Note] A temporary password is generated for root@localhost: TKk51x#bOi0S</strong><br><strong>之后就可以成功登陆了</strong></p>\n</blockquote>\n<h3 id=\"修改密码\"><a href=\"#修改密码\" class=\"headerlink\" title=\"修改密码\"></a>修改密码</h3><p><strong>登陆后没办法使用其他语句，说是必须修改一下密码，而且自动生成的密码太难记了，我想改回自己的密码，但是在网上查了很多指令都用不成功，错误提示的ALTER USER语句也不知道怎么用，所以又上网馊了一下，还看了一下官方文档，总结就是看不懂~~</strong><br><strong>查到最后终于发现了一个可以用的语句</strong></p>\n<blockquote>\n<p><code>alter user &#39;root&#39;@&#39;localhost&#39; identified by &#39;password&#39;;</code></p>\n</blockquote>\n<p><strong>这下问题终于解决了，可以开始进一步学习了。</strong></p>\n<p><strong>虽然遇到了很多问题，但是也知道了很多MySQL和命令行的语句，有些没派上用场就是了，至少折腾了一夜一些有用的语句都变熟悉了。</strong></p>\n"},{"title":"Python程序打包成exe可执行文件","date":"2019-06-01T16:00:00.000Z","_content":"\n### 本教程是使用Pyinstaller来将Python程序打包成exe可执行文件\n\n### **实现步骤：**\n\n**首先要安装Pyinstaller包，在命令行窗口使用pip指令就可以完成：**\n`pip install pyinstaller`\n**安装成功后就可以进行打包了**\n**首先在命令行进入要打包的python程序的目录下面**\n**接着使用**   `pyinstaller file.py`   **就可以打包了(file.py是指你要打包的python文件)**\n**这个指令也可以附带其他属性：**\n\n```text\n-F  表示生成单个可执行文件\n-D  创建一个目录，包含exe文件和依赖很多文件（默认选项）\n-w  表示去掉控制台窗口，这样执行exe文件的时候不会出现窗口，但会在后台运行，用命令行还是可以看见执行情况的\n-c  使用控制台，无界面(默认)；\n-p  表示你自己自定义需要加载的类路径\n-i  表示可执行文件的图标。\n```\n\n**例如我要生成一个带图标的exe文件，没有其他依赖文件的，那么就是使用指令：**\n`pyinstaller -F -i image.ico file.py`   **（image.ico表示图标的路径，file.py表示要打包的python文件）**\n**打包后会生成dict文件夹和buid文件夹还有一个.spec文件，其中dict就是放置我们要的exe文件的文件夹，其他两个是生成exe文件的过程中的中间产物，可以删掉。**\n**pyinstaller打包的时候会自动把其他依赖的包和其他python文件引入，所以不用担心调用的问题。**\n**但是其他要使用到的文件并不会被添加进去，例如要使用的图片或者文档，所以要自己把文件添加到打包完的exe文件的目录下面相应的路径，否则会出现闪退或者文件执行失败。**\n**另外就是，如果py文件的编码是utf8，但是文件里面又有中文的话，那么使用windows的命令行打包会出现编码错误。**\n**解决的方法就是先使用chcp指令进入其他编码的命令行**\n\n**以下是几种常用的编码:**\n\n```text\nGBK(一般情况下为默认编码) 936\n美国英语 437\nutf-8 65001\n```\n\n**在这里我们要使用utf-8的编码，所以使用命令:**\n`chcp 65001`\n**设置编码后再进行打包就不会出现编码错误的情况了**\n\n**最后就是，第一次打包出来的程序经常会出现各种问题，建议在命令行执行exe文件，这样可以看到报错的内容，以便结合情况解决问题。**\n","source":"_posts/python程序打包成exe文件.md","raw":"---\ntitle: Python程序打包成exe可执行文件\ndate: 2019-6-2\ncategories: 技术文章\ntags:\n    - Python\n---\n\n### 本教程是使用Pyinstaller来将Python程序打包成exe可执行文件\n\n### **实现步骤：**\n\n**首先要安装Pyinstaller包，在命令行窗口使用pip指令就可以完成：**\n`pip install pyinstaller`\n**安装成功后就可以进行打包了**\n**首先在命令行进入要打包的python程序的目录下面**\n**接着使用**   `pyinstaller file.py`   **就可以打包了(file.py是指你要打包的python文件)**\n**这个指令也可以附带其他属性：**\n\n```text\n-F  表示生成单个可执行文件\n-D  创建一个目录，包含exe文件和依赖很多文件（默认选项）\n-w  表示去掉控制台窗口，这样执行exe文件的时候不会出现窗口，但会在后台运行，用命令行还是可以看见执行情况的\n-c  使用控制台，无界面(默认)；\n-p  表示你自己自定义需要加载的类路径\n-i  表示可执行文件的图标。\n```\n\n**例如我要生成一个带图标的exe文件，没有其他依赖文件的，那么就是使用指令：**\n`pyinstaller -F -i image.ico file.py`   **（image.ico表示图标的路径，file.py表示要打包的python文件）**\n**打包后会生成dict文件夹和buid文件夹还有一个.spec文件，其中dict就是放置我们要的exe文件的文件夹，其他两个是生成exe文件的过程中的中间产物，可以删掉。**\n**pyinstaller打包的时候会自动把其他依赖的包和其他python文件引入，所以不用担心调用的问题。**\n**但是其他要使用到的文件并不会被添加进去，例如要使用的图片或者文档，所以要自己把文件添加到打包完的exe文件的目录下面相应的路径，否则会出现闪退或者文件执行失败。**\n**另外就是，如果py文件的编码是utf8，但是文件里面又有中文的话，那么使用windows的命令行打包会出现编码错误。**\n**解决的方法就是先使用chcp指令进入其他编码的命令行**\n\n**以下是几种常用的编码:**\n\n```text\nGBK(一般情况下为默认编码) 936\n美国英语 437\nutf-8 65001\n```\n\n**在这里我们要使用utf-8的编码，所以使用命令:**\n`chcp 65001`\n**设置编码后再进行打包就不会出现编码错误的情况了**\n\n**最后就是，第一次打包出来的程序经常会出现各种问题，建议在命令行执行exe文件，这样可以看到报错的内容，以便结合情况解决问题。**\n","slug":"python程序打包成exe文件","published":1,"updated":"2020-02-06T09:03:20.627Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6ywrivo000654v5ct5fge4x","content":"<h3 id=\"本教程是使用Pyinstaller来将Python程序打包成exe可执行文件\"><a href=\"#本教程是使用Pyinstaller来将Python程序打包成exe可执行文件\" class=\"headerlink\" title=\"本教程是使用Pyinstaller来将Python程序打包成exe可执行文件\"></a>本教程是使用Pyinstaller来将Python程序打包成exe可执行文件</h3><h3 id=\"实现步骤：\"><a href=\"#实现步骤：\" class=\"headerlink\" title=\"实现步骤：\"></a><strong>实现步骤：</strong></h3><p><strong>首先要安装Pyinstaller包，在命令行窗口使用pip指令就可以完成：</strong><br><code>pip install pyinstaller</code><br><strong>安装成功后就可以进行打包了</strong><br><strong>首先在命令行进入要打包的python程序的目录下面</strong><br><strong>接着使用</strong>   <code>pyinstaller file.py</code>   <strong>就可以打包了(file.py是指你要打包的python文件)</strong><br><strong>这个指令也可以附带其他属性：</strong></p>\n<pre><code class=\"text\">-F  表示生成单个可执行文件\n-D  创建一个目录，包含exe文件和依赖很多文件（默认选项）\n-w  表示去掉控制台窗口，这样执行exe文件的时候不会出现窗口，但会在后台运行，用命令行还是可以看见执行情况的\n-c  使用控制台，无界面(默认)；\n-p  表示你自己自定义需要加载的类路径\n-i  表示可执行文件的图标。</code></pre>\n<p><strong>例如我要生成一个带图标的exe文件，没有其他依赖文件的，那么就是使用指令：</strong><br><code>pyinstaller -F -i image.ico file.py</code>   <strong>（image.ico表示图标的路径，file.py表示要打包的python文件）</strong><br><strong>打包后会生成dict文件夹和buid文件夹还有一个.spec文件，其中dict就是放置我们要的exe文件的文件夹，其他两个是生成exe文件的过程中的中间产物，可以删掉。</strong><br><strong>pyinstaller打包的时候会自动把其他依赖的包和其他python文件引入，所以不用担心调用的问题。</strong><br><strong>但是其他要使用到的文件并不会被添加进去，例如要使用的图片或者文档，所以要自己把文件添加到打包完的exe文件的目录下面相应的路径，否则会出现闪退或者文件执行失败。</strong><br><strong>另外就是，如果py文件的编码是utf8，但是文件里面又有中文的话，那么使用windows的命令行打包会出现编码错误。</strong><br><strong>解决的方法就是先使用chcp指令进入其他编码的命令行</strong></p>\n<p><strong>以下是几种常用的编码:</strong></p>\n<pre><code class=\"text\">GBK(一般情况下为默认编码) 936\n美国英语 437\nutf-8 65001</code></pre>\n<p><strong>在这里我们要使用utf-8的编码，所以使用命令:</strong><br><code>chcp 65001</code><br><strong>设置编码后再进行打包就不会出现编码错误的情况了</strong></p>\n<p><strong>最后就是，第一次打包出来的程序经常会出现各种问题，建议在命令行执行exe文件，这样可以看到报错的内容，以便结合情况解决问题。</strong></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"本教程是使用Pyinstaller来将Python程序打包成exe可执行文件\"><a href=\"#本教程是使用Pyinstaller来将Python程序打包成exe可执行文件\" class=\"headerlink\" title=\"本教程是使用Pyinstaller来将Python程序打包成exe可执行文件\"></a>本教程是使用Pyinstaller来将Python程序打包成exe可执行文件</h3><h3 id=\"实现步骤：\"><a href=\"#实现步骤：\" class=\"headerlink\" title=\"实现步骤：\"></a><strong>实现步骤：</strong></h3><p><strong>首先要安装Pyinstaller包，在命令行窗口使用pip指令就可以完成：</strong><br><code>pip install pyinstaller</code><br><strong>安装成功后就可以进行打包了</strong><br><strong>首先在命令行进入要打包的python程序的目录下面</strong><br><strong>接着使用</strong>   <code>pyinstaller file.py</code>   <strong>就可以打包了(file.py是指你要打包的python文件)</strong><br><strong>这个指令也可以附带其他属性：</strong></p>\n<pre><code class=\"text\">-F  表示生成单个可执行文件\n-D  创建一个目录，包含exe文件和依赖很多文件（默认选项）\n-w  表示去掉控制台窗口，这样执行exe文件的时候不会出现窗口，但会在后台运行，用命令行还是可以看见执行情况的\n-c  使用控制台，无界面(默认)；\n-p  表示你自己自定义需要加载的类路径\n-i  表示可执行文件的图标。</code></pre>\n<p><strong>例如我要生成一个带图标的exe文件，没有其他依赖文件的，那么就是使用指令：</strong><br><code>pyinstaller -F -i image.ico file.py</code>   <strong>（image.ico表示图标的路径，file.py表示要打包的python文件）</strong><br><strong>打包后会生成dict文件夹和buid文件夹还有一个.spec文件，其中dict就是放置我们要的exe文件的文件夹，其他两个是生成exe文件的过程中的中间产物，可以删掉。</strong><br><strong>pyinstaller打包的时候会自动把其他依赖的包和其他python文件引入，所以不用担心调用的问题。</strong><br><strong>但是其他要使用到的文件并不会被添加进去，例如要使用的图片或者文档，所以要自己把文件添加到打包完的exe文件的目录下面相应的路径，否则会出现闪退或者文件执行失败。</strong><br><strong>另外就是，如果py文件的编码是utf8，但是文件里面又有中文的话，那么使用windows的命令行打包会出现编码错误。</strong><br><strong>解决的方法就是先使用chcp指令进入其他编码的命令行</strong></p>\n<p><strong>以下是几种常用的编码:</strong></p>\n<pre><code class=\"text\">GBK(一般情况下为默认编码) 936\n美国英语 437\nutf-8 65001</code></pre>\n<p><strong>在这里我们要使用utf-8的编码，所以使用命令:</strong><br><code>chcp 65001</code><br><strong>设置编码后再进行打包就不会出现编码错误的情况了</strong></p>\n<p><strong>最后就是，第一次打包出来的程序经常会出现各种问题，建议在命令行执行exe文件，这样可以看到报错的内容，以便结合情况解决问题。</strong></p>\n"},{"title":"使用setuptools和twine把项目打成pip包","date":"2020-01-25T08:25:00.000Z","_content":"\n本文章是在打包web-mysql和nested-list时根据官方教程在实践后后写下的，可以边参考官方教程边阅读本文章，这样可能有助于您理解如何去把项目打包成一个pip软件包\n\n本人使用的是Python3，操作可能会和Python2有点不同，同时使用的命令是参考了其他的教程，和官方命令也不太一样，免去了许多参数的选择，更加简单。\n\n如果希望更加全面地理解和打包pip软件包请参考\n\n官方教程：<https://packaging.python.org/tutorials/packaging-projects/>\n\n需要使用到的东西\n---\n\n两个Python包：setuptools、twine\n\n一个PyPI账号：<https://pypi.org/>\n\n打一个pip软件包一定要有这两个工具，setuptools用于创建构建脚本，twine用于上传项目，上传的pip包都会放在这里PyPI\n\n打包一个项目的文件结构\n---\n\n```Text\n软件包根目录/\n    打包的项目/\n        __init__.py\n        ...\n    setup.py\n    LICENSE\n    README.md\n```\n\n根目录的名字不知道对项目名有没有影响，我都是直接取发行名称\n\n在这个目录下，最简单的配置包括4个部分：\n\n```Text\n要打包的项目：你准备打包成pip包的项目\nsetup.py：构建脚本，里面写的是软件包的相关信息和代码配置信息\nLICENSE：软件包使用的许可证\nREADME.md：说明文件\n```\n\n打包配置\n---\n\n打包的项目就不说了，可能你是直接打包已有项目，也可能是打算打包从头写的项目，打包的关键步骤主要是setup.py的配置和上传命令的使用，上传项目时软件包的信息都是根据setup里面的配置来上传的\n\n**把官方setup.py的配置简化一下就是以下的样子,三个点代表省略:**\n\n```Python\nimport setuptools\n\n# 这里从README导入详细说明\nwith open(\"README.md\", \"r\") as fh:\n    long_description = fh.read()\n\nsetuptools.setup(\n    name=\"example-pkg-YOUR-USERNAME-HERE\", # pip软件包发行的名称\n    version=\"0.0.1\", # 本次上传的版本\n    author=\"Example Author\", # 作者名称\n    author_email=\"author@example.com\", # 作者邮箱\n    description=\"A small example package\", # 软件包摘要\n    long_description=long_description, # 软件包详细说明\n    long_description_content_type=\"text/markdown\", # 引用详细说明的文件格式\n    url=\"https://github.com/pypa/sampleproject\", # 项目的主页地址，大部分是使用该项目在自己代码储存库的地址\n    license=\"MIT\" # 许可证类型\n    packages=setuptools.find_packages(), # 要打包的所有Python包列表\n    # 是列出了你的包的额外元数据，给你的包进行分类，下面的意思是“该软件包仅与Python 3兼容，已获得MIT许可，与操作系统无关”\n    classifiers=[\n        \"Programming Language :: Python :: 3\",\n        \"License :: OSI Approved :: MIT License\",\n        \"Operating System :: OS Independent\",\n    ],\n    # 能够使用你的项目的Python版本\n    python_requires='>=3.6',\n    # 你的项目的依赖项，安装你的软件包时，pip也会自动安装以下依赖项，举个例子--pymysql\n    install_requires = [\n        'pymysql',\n        ...\n    ]\n    ...\n)\n```\n\n**官方全部字段的配置说明：<https://packaging.python.org/guides/distributing-packages-using-setuptools/>**\n\n**配置文件的时候有几个注意点：**\n**1、上传不同版本的软件包，version要修改，因为生成的压缩包版本后缀是根据这一行配置的**\n**2、packages可以手动列出需要打包的Python包列表，如果使用`find_package()`的话则是脚本自动发现所有软件包和子软件包**\n**3、关于classifiers的配置根据不同项目配置都不一样，参考官方分类器列表：<https://pypi.org/classifiers/>**\n**4、如果设置了python_requires，那么所有不符合要求的Python版本都会被pip阻止安装这个软件包**\n\n**配置完setup.py，接下来就是根据你的需要选择许可证：<https://choosealicense.com/>**\n**选择完许可证要把许可证文本写入LICENSE文件，或者也可以在使用GitHub Desktop创建仓库时创建许可证，如果setup.py里有配置license这一项记得修改成对应的类型**\n\n打包\n---\n\n打包前，要先check一下，看看setup的配置是否有效\n\n在软件包根目录使用命令：`setup.py check`\n\n如果只显示了running check就是正常的\n\n如果没问题使用sdist进行打包\n\n`setup.py sdist`\n\n生成的压缩包会放在dist/下面，把这些包上传就完成了，但是上传前还要进行一次检查，看看压缩包是否符合要求\n\n检查命令：`twine check dist/*`\n\n上传命令：`twine upload dist/*`\n\n输入用户名和密码就可以了\n\n**这里也有几个注意点：**\n**1、有些教程会使用`setup.py register`来进行注册上传，但是这个方法其实已经弃用了，官方推荐是直接使用`twine upload`**\n**2、dist/*是指dist下的全部文件，如果上传的压缩包含有以前的版本，因为该版本已经上传过了，会有错误提示，可以把以前版本的压缩包删掉，也可以自己选择上传的包，而不是全部上传**\n**3、我这里没有配置用户文件，配置文件可以免去验证用户的流程**\n**4、官方推荐是注册令牌来代替用户名和密码上传，注册令牌是一种更安全可靠的方式**\n\n如果以上步骤都没问题，你就可以在自己的账号上面看到上传的pip软件包了\n\n——更多内容待更新——\n","source":"_posts/使用twine把项目打成pip包.md","raw":"---\ntitle: 使用setuptools和twine把项目打成pip包\ndate: 2020-1-25 16:25\ncategories: 技术文章\ntags:\n    - Python\n---\n\n本文章是在打包web-mysql和nested-list时根据官方教程在实践后后写下的，可以边参考官方教程边阅读本文章，这样可能有助于您理解如何去把项目打包成一个pip软件包\n\n本人使用的是Python3，操作可能会和Python2有点不同，同时使用的命令是参考了其他的教程，和官方命令也不太一样，免去了许多参数的选择，更加简单。\n\n如果希望更加全面地理解和打包pip软件包请参考\n\n官方教程：<https://packaging.python.org/tutorials/packaging-projects/>\n\n需要使用到的东西\n---\n\n两个Python包：setuptools、twine\n\n一个PyPI账号：<https://pypi.org/>\n\n打一个pip软件包一定要有这两个工具，setuptools用于创建构建脚本，twine用于上传项目，上传的pip包都会放在这里PyPI\n\n打包一个项目的文件结构\n---\n\n```Text\n软件包根目录/\n    打包的项目/\n        __init__.py\n        ...\n    setup.py\n    LICENSE\n    README.md\n```\n\n根目录的名字不知道对项目名有没有影响，我都是直接取发行名称\n\n在这个目录下，最简单的配置包括4个部分：\n\n```Text\n要打包的项目：你准备打包成pip包的项目\nsetup.py：构建脚本，里面写的是软件包的相关信息和代码配置信息\nLICENSE：软件包使用的许可证\nREADME.md：说明文件\n```\n\n打包配置\n---\n\n打包的项目就不说了，可能你是直接打包已有项目，也可能是打算打包从头写的项目，打包的关键步骤主要是setup.py的配置和上传命令的使用，上传项目时软件包的信息都是根据setup里面的配置来上传的\n\n**把官方setup.py的配置简化一下就是以下的样子,三个点代表省略:**\n\n```Python\nimport setuptools\n\n# 这里从README导入详细说明\nwith open(\"README.md\", \"r\") as fh:\n    long_description = fh.read()\n\nsetuptools.setup(\n    name=\"example-pkg-YOUR-USERNAME-HERE\", # pip软件包发行的名称\n    version=\"0.0.1\", # 本次上传的版本\n    author=\"Example Author\", # 作者名称\n    author_email=\"author@example.com\", # 作者邮箱\n    description=\"A small example package\", # 软件包摘要\n    long_description=long_description, # 软件包详细说明\n    long_description_content_type=\"text/markdown\", # 引用详细说明的文件格式\n    url=\"https://github.com/pypa/sampleproject\", # 项目的主页地址，大部分是使用该项目在自己代码储存库的地址\n    license=\"MIT\" # 许可证类型\n    packages=setuptools.find_packages(), # 要打包的所有Python包列表\n    # 是列出了你的包的额外元数据，给你的包进行分类，下面的意思是“该软件包仅与Python 3兼容，已获得MIT许可，与操作系统无关”\n    classifiers=[\n        \"Programming Language :: Python :: 3\",\n        \"License :: OSI Approved :: MIT License\",\n        \"Operating System :: OS Independent\",\n    ],\n    # 能够使用你的项目的Python版本\n    python_requires='>=3.6',\n    # 你的项目的依赖项，安装你的软件包时，pip也会自动安装以下依赖项，举个例子--pymysql\n    install_requires = [\n        'pymysql',\n        ...\n    ]\n    ...\n)\n```\n\n**官方全部字段的配置说明：<https://packaging.python.org/guides/distributing-packages-using-setuptools/>**\n\n**配置文件的时候有几个注意点：**\n**1、上传不同版本的软件包，version要修改，因为生成的压缩包版本后缀是根据这一行配置的**\n**2、packages可以手动列出需要打包的Python包列表，如果使用`find_package()`的话则是脚本自动发现所有软件包和子软件包**\n**3、关于classifiers的配置根据不同项目配置都不一样，参考官方分类器列表：<https://pypi.org/classifiers/>**\n**4、如果设置了python_requires，那么所有不符合要求的Python版本都会被pip阻止安装这个软件包**\n\n**配置完setup.py，接下来就是根据你的需要选择许可证：<https://choosealicense.com/>**\n**选择完许可证要把许可证文本写入LICENSE文件，或者也可以在使用GitHub Desktop创建仓库时创建许可证，如果setup.py里有配置license这一项记得修改成对应的类型**\n\n打包\n---\n\n打包前，要先check一下，看看setup的配置是否有效\n\n在软件包根目录使用命令：`setup.py check`\n\n如果只显示了running check就是正常的\n\n如果没问题使用sdist进行打包\n\n`setup.py sdist`\n\n生成的压缩包会放在dist/下面，把这些包上传就完成了，但是上传前还要进行一次检查，看看压缩包是否符合要求\n\n检查命令：`twine check dist/*`\n\n上传命令：`twine upload dist/*`\n\n输入用户名和密码就可以了\n\n**这里也有几个注意点：**\n**1、有些教程会使用`setup.py register`来进行注册上传，但是这个方法其实已经弃用了，官方推荐是直接使用`twine upload`**\n**2、dist/*是指dist下的全部文件，如果上传的压缩包含有以前的版本，因为该版本已经上传过了，会有错误提示，可以把以前版本的压缩包删掉，也可以自己选择上传的包，而不是全部上传**\n**3、我这里没有配置用户文件，配置文件可以免去验证用户的流程**\n**4、官方推荐是注册令牌来代替用户名和密码上传，注册令牌是一种更安全可靠的方式**\n\n如果以上步骤都没问题，你就可以在自己的账号上面看到上传的pip软件包了\n\n——更多内容待更新——\n","slug":"使用twine把项目打成pip包","published":1,"updated":"2020-02-06T09:17:32.281Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6ywrivs000b54v5gv6u6src","content":"<p>本文章是在打包web-mysql和nested-list时根据官方教程在实践后后写下的，可以边参考官方教程边阅读本文章，这样可能有助于您理解如何去把项目打包成一个pip软件包</p>\n<p>本人使用的是Python3，操作可能会和Python2有点不同，同时使用的命令是参考了其他的教程，和官方命令也不太一样，免去了许多参数的选择，更加简单。</p>\n<p>如果希望更加全面地理解和打包pip软件包请参考</p>\n<p>官方教程：<a href=\"https://packaging.python.org/tutorials/packaging-projects/\" target=\"_blank\" rel=\"noopener\">https://packaging.python.org/tutorials/packaging-projects/</a></p>\n<h2 id=\"需要使用到的东西\"><a href=\"#需要使用到的东西\" class=\"headerlink\" title=\"需要使用到的东西\"></a>需要使用到的东西</h2><p>两个Python包：setuptools、twine</p>\n<p>一个PyPI账号：<a href=\"https://pypi.org/\" target=\"_blank\" rel=\"noopener\">https://pypi.org/</a></p>\n<p>打一个pip软件包一定要有这两个工具，setuptools用于创建构建脚本，twine用于上传项目，上传的pip包都会放在这里PyPI</p>\n<h2 id=\"打包一个项目的文件结构\"><a href=\"#打包一个项目的文件结构\" class=\"headerlink\" title=\"打包一个项目的文件结构\"></a>打包一个项目的文件结构</h2><pre><code class=\"Text\">软件包根目录/\n    打包的项目/\n        __init__.py\n        ...\n    setup.py\n    LICENSE\n    README.md</code></pre>\n<p>根目录的名字不知道对项目名有没有影响，我都是直接取发行名称</p>\n<p>在这个目录下，最简单的配置包括4个部分：</p>\n<pre><code class=\"Text\">要打包的项目：你准备打包成pip包的项目\nsetup.py：构建脚本，里面写的是软件包的相关信息和代码配置信息\nLICENSE：软件包使用的许可证\nREADME.md：说明文件</code></pre>\n<h2 id=\"打包配置\"><a href=\"#打包配置\" class=\"headerlink\" title=\"打包配置\"></a>打包配置</h2><p>打包的项目就不说了，可能你是直接打包已有项目，也可能是打算打包从头写的项目，打包的关键步骤主要是setup.py的配置和上传命令的使用，上传项目时软件包的信息都是根据setup里面的配置来上传的</p>\n<p><strong>把官方setup.py的配置简化一下就是以下的样子,三个点代表省略:</strong></p>\n<pre><code class=\"Python\">import setuptools\n\n# 这里从README导入详细说明\nwith open(&quot;README.md&quot;, &quot;r&quot;) as fh:\n    long_description = fh.read()\n\nsetuptools.setup(\n    name=&quot;example-pkg-YOUR-USERNAME-HERE&quot;, # pip软件包发行的名称\n    version=&quot;0.0.1&quot;, # 本次上传的版本\n    author=&quot;Example Author&quot;, # 作者名称\n    author_email=&quot;author@example.com&quot;, # 作者邮箱\n    description=&quot;A small example package&quot;, # 软件包摘要\n    long_description=long_description, # 软件包详细说明\n    long_description_content_type=&quot;text/markdown&quot;, # 引用详细说明的文件格式\n    url=&quot;https://github.com/pypa/sampleproject&quot;, # 项目的主页地址，大部分是使用该项目在自己代码储存库的地址\n    license=&quot;MIT&quot; # 许可证类型\n    packages=setuptools.find_packages(), # 要打包的所有Python包列表\n    # 是列出了你的包的额外元数据，给你的包进行分类，下面的意思是“该软件包仅与Python 3兼容，已获得MIT许可，与操作系统无关”\n    classifiers=[\n        &quot;Programming Language :: Python :: 3&quot;,\n        &quot;License :: OSI Approved :: MIT License&quot;,\n        &quot;Operating System :: OS Independent&quot;,\n    ],\n    # 能够使用你的项目的Python版本\n    python_requires=&#39;&gt;=3.6&#39;,\n    # 你的项目的依赖项，安装你的软件包时，pip也会自动安装以下依赖项，举个例子--pymysql\n    install_requires = [\n        &#39;pymysql&#39;,\n        ...\n    ]\n    ...\n)</code></pre>\n<p><strong>官方全部字段的配置说明：<a href=\"https://packaging.python.org/guides/distributing-packages-using-setuptools/\" target=\"_blank\" rel=\"noopener\">https://packaging.python.org/guides/distributing-packages-using-setuptools/</a></strong></p>\n<p><strong>配置文件的时候有几个注意点：</strong><br><strong>1、上传不同版本的软件包，version要修改，因为生成的压缩包版本后缀是根据这一行配置的</strong><br><strong>2、packages可以手动列出需要打包的Python包列表，如果使用<code>find_package()</code>的话则是脚本自动发现所有软件包和子软件包</strong><br><strong>3、关于classifiers的配置根据不同项目配置都不一样，参考官方分类器列表：<a href=\"https://pypi.org/classifiers/\" target=\"_blank\" rel=\"noopener\">https://pypi.org/classifiers/</a></strong><br><strong>4、如果设置了python_requires，那么所有不符合要求的Python版本都会被pip阻止安装这个软件包</strong></p>\n<p><strong>配置完setup.py，接下来就是根据你的需要选择许可证：<a href=\"https://choosealicense.com/\" target=\"_blank\" rel=\"noopener\">https://choosealicense.com/</a></strong><br><strong>选择完许可证要把许可证文本写入LICENSE文件，或者也可以在使用GitHub Desktop创建仓库时创建许可证，如果setup.py里有配置license这一项记得修改成对应的类型</strong></p>\n<h2 id=\"打包\"><a href=\"#打包\" class=\"headerlink\" title=\"打包\"></a>打包</h2><p>打包前，要先check一下，看看setup的配置是否有效</p>\n<p>在软件包根目录使用命令：<code>setup.py check</code></p>\n<p>如果只显示了running check就是正常的</p>\n<p>如果没问题使用sdist进行打包</p>\n<p><code>setup.py sdist</code></p>\n<p>生成的压缩包会放在dist/下面，把这些包上传就完成了，但是上传前还要进行一次检查，看看压缩包是否符合要求</p>\n<p>检查命令：<code>twine check dist/*</code></p>\n<p>上传命令：<code>twine upload dist/*</code></p>\n<p>输入用户名和密码就可以了</p>\n<p><strong>这里也有几个注意点：</strong><br><strong>1、有些教程会使用<code>setup.py register</code>来进行注册上传，但是这个方法其实已经弃用了，官方推荐是直接使用<code>twine upload</code></strong><br><strong>2、dist/*是指dist下的全部文件，如果上传的压缩包含有以前的版本，因为该版本已经上传过了，会有错误提示，可以把以前版本的压缩包删掉，也可以自己选择上传的包，而不是全部上传</strong><br><strong>3、我这里没有配置用户文件，配置文件可以免去验证用户的流程</strong><br><strong>4、官方推荐是注册令牌来代替用户名和密码上传，注册令牌是一种更安全可靠的方式</strong></p>\n<p>如果以上步骤都没问题，你就可以在自己的账号上面看到上传的pip软件包了</p>\n<p>——更多内容待更新——</p>\n","site":{"data":{}},"excerpt":"","more":"<p>本文章是在打包web-mysql和nested-list时根据官方教程在实践后后写下的，可以边参考官方教程边阅读本文章，这样可能有助于您理解如何去把项目打包成一个pip软件包</p>\n<p>本人使用的是Python3，操作可能会和Python2有点不同，同时使用的命令是参考了其他的教程，和官方命令也不太一样，免去了许多参数的选择，更加简单。</p>\n<p>如果希望更加全面地理解和打包pip软件包请参考</p>\n<p>官方教程：<a href=\"https://packaging.python.org/tutorials/packaging-projects/\" target=\"_blank\" rel=\"noopener\">https://packaging.python.org/tutorials/packaging-projects/</a></p>\n<h2 id=\"需要使用到的东西\"><a href=\"#需要使用到的东西\" class=\"headerlink\" title=\"需要使用到的东西\"></a>需要使用到的东西</h2><p>两个Python包：setuptools、twine</p>\n<p>一个PyPI账号：<a href=\"https://pypi.org/\" target=\"_blank\" rel=\"noopener\">https://pypi.org/</a></p>\n<p>打一个pip软件包一定要有这两个工具，setuptools用于创建构建脚本，twine用于上传项目，上传的pip包都会放在这里PyPI</p>\n<h2 id=\"打包一个项目的文件结构\"><a href=\"#打包一个项目的文件结构\" class=\"headerlink\" title=\"打包一个项目的文件结构\"></a>打包一个项目的文件结构</h2><pre><code class=\"Text\">软件包根目录/\n    打包的项目/\n        __init__.py\n        ...\n    setup.py\n    LICENSE\n    README.md</code></pre>\n<p>根目录的名字不知道对项目名有没有影响，我都是直接取发行名称</p>\n<p>在这个目录下，最简单的配置包括4个部分：</p>\n<pre><code class=\"Text\">要打包的项目：你准备打包成pip包的项目\nsetup.py：构建脚本，里面写的是软件包的相关信息和代码配置信息\nLICENSE：软件包使用的许可证\nREADME.md：说明文件</code></pre>\n<h2 id=\"打包配置\"><a href=\"#打包配置\" class=\"headerlink\" title=\"打包配置\"></a>打包配置</h2><p>打包的项目就不说了，可能你是直接打包已有项目，也可能是打算打包从头写的项目，打包的关键步骤主要是setup.py的配置和上传命令的使用，上传项目时软件包的信息都是根据setup里面的配置来上传的</p>\n<p><strong>把官方setup.py的配置简化一下就是以下的样子,三个点代表省略:</strong></p>\n<pre><code class=\"Python\">import setuptools\n\n# 这里从README导入详细说明\nwith open(&quot;README.md&quot;, &quot;r&quot;) as fh:\n    long_description = fh.read()\n\nsetuptools.setup(\n    name=&quot;example-pkg-YOUR-USERNAME-HERE&quot;, # pip软件包发行的名称\n    version=&quot;0.0.1&quot;, # 本次上传的版本\n    author=&quot;Example Author&quot;, # 作者名称\n    author_email=&quot;author@example.com&quot;, # 作者邮箱\n    description=&quot;A small example package&quot;, # 软件包摘要\n    long_description=long_description, # 软件包详细说明\n    long_description_content_type=&quot;text/markdown&quot;, # 引用详细说明的文件格式\n    url=&quot;https://github.com/pypa/sampleproject&quot;, # 项目的主页地址，大部分是使用该项目在自己代码储存库的地址\n    license=&quot;MIT&quot; # 许可证类型\n    packages=setuptools.find_packages(), # 要打包的所有Python包列表\n    # 是列出了你的包的额外元数据，给你的包进行分类，下面的意思是“该软件包仅与Python 3兼容，已获得MIT许可，与操作系统无关”\n    classifiers=[\n        &quot;Programming Language :: Python :: 3&quot;,\n        &quot;License :: OSI Approved :: MIT License&quot;,\n        &quot;Operating System :: OS Independent&quot;,\n    ],\n    # 能够使用你的项目的Python版本\n    python_requires=&#39;&gt;=3.6&#39;,\n    # 你的项目的依赖项，安装你的软件包时，pip也会自动安装以下依赖项，举个例子--pymysql\n    install_requires = [\n        &#39;pymysql&#39;,\n        ...\n    ]\n    ...\n)</code></pre>\n<p><strong>官方全部字段的配置说明：<a href=\"https://packaging.python.org/guides/distributing-packages-using-setuptools/\" target=\"_blank\" rel=\"noopener\">https://packaging.python.org/guides/distributing-packages-using-setuptools/</a></strong></p>\n<p><strong>配置文件的时候有几个注意点：</strong><br><strong>1、上传不同版本的软件包，version要修改，因为生成的压缩包版本后缀是根据这一行配置的</strong><br><strong>2、packages可以手动列出需要打包的Python包列表，如果使用<code>find_package()</code>的话则是脚本自动发现所有软件包和子软件包</strong><br><strong>3、关于classifiers的配置根据不同项目配置都不一样，参考官方分类器列表：<a href=\"https://pypi.org/classifiers/\" target=\"_blank\" rel=\"noopener\">https://pypi.org/classifiers/</a></strong><br><strong>4、如果设置了python_requires，那么所有不符合要求的Python版本都会被pip阻止安装这个软件包</strong></p>\n<p><strong>配置完setup.py，接下来就是根据你的需要选择许可证：<a href=\"https://choosealicense.com/\" target=\"_blank\" rel=\"noopener\">https://choosealicense.com/</a></strong><br><strong>选择完许可证要把许可证文本写入LICENSE文件，或者也可以在使用GitHub Desktop创建仓库时创建许可证，如果setup.py里有配置license这一项记得修改成对应的类型</strong></p>\n<h2 id=\"打包\"><a href=\"#打包\" class=\"headerlink\" title=\"打包\"></a>打包</h2><p>打包前，要先check一下，看看setup的配置是否有效</p>\n<p>在软件包根目录使用命令：<code>setup.py check</code></p>\n<p>如果只显示了running check就是正常的</p>\n<p>如果没问题使用sdist进行打包</p>\n<p><code>setup.py sdist</code></p>\n<p>生成的压缩包会放在dist/下面，把这些包上传就完成了，但是上传前还要进行一次检查，看看压缩包是否符合要求</p>\n<p>检查命令：<code>twine check dist/*</code></p>\n<p>上传命令：<code>twine upload dist/*</code></p>\n<p>输入用户名和密码就可以了</p>\n<p><strong>这里也有几个注意点：</strong><br><strong>1、有些教程会使用<code>setup.py register</code>来进行注册上传，但是这个方法其实已经弃用了，官方推荐是直接使用<code>twine upload</code></strong><br><strong>2、dist/*是指dist下的全部文件，如果上传的压缩包含有以前的版本，因为该版本已经上传过了，会有错误提示，可以把以前版本的压缩包删掉，也可以自己选择上传的包，而不是全部上传</strong><br><strong>3、我这里没有配置用户文件，配置文件可以免去验证用户的流程</strong><br><strong>4、官方推荐是注册令牌来代替用户名和密码上传，注册令牌是一种更安全可靠的方式</strong></p>\n<p>如果以上步骤都没问题，你就可以在自己的账号上面看到上传的pip软件包了</p>\n<p>——更多内容待更新——</p>\n"},{"title":"使用Hexo-NexT时遇到的问题","date":"2019-03-28T16:00:00.000Z","_content":"## 部署到github显示的网页和本地测试的网页不一样\n\n<font size=\"4\">\n之前设置了网页的背景图片还有側框的边角，同时添加了右上角的github跳转图标和阅读全文的设置。\n\n但是在在本地测试完，部署到github时，发现只有github图标和阅读全文的设置生效了，背景图片和边角设置没有体现出来。\n\n这是因为github部署的时候缓存加载比较慢，有时候要过一段时间才会显示出你想要的效果，用`hexo clean`清除一下public文件夹,再重新部署用`hexo g -d`部署一下，多刷新几次就行了。\n</font><br /> \n\n## [生成了空白的html文件](#生成了空白的html文件)\n\n第一次遇到这个问题的时候，我是直接重新搭建了这个博客的，毕竟一直不知道怎么解决，明明上一步操作还是没问题的，下一步页面突然就崩溃了。\n\n后来这个博客又遇到了一次，好在我找到了解决方法：\n\n如果找不到index.html文件（在生成的public文件夹里面）的话，要先用`npm ls --depth 0`检查一下插件情况,如果插件缺失了deploy和generator这两个插件的话就要用`npm install`重新安装插件。\n\n**如果是有html文件，但文件是空白的。那么你就要检查你刚刚修改的配置了，如果你修改一个文件里某一个配置下的某一项，但那一个配置忘记打开的话就会导致这样的情况。**\n\n例如我在主题配置文件里的友情链接links下增加了网易云音乐这一个选项，但是links前面原先有一个#号，我没有删除打开的话，生成的index.html文件就是空白的。\n\n而我就是遇到了这种情况，当时不知道是修改了哪一个配置，忘记把#号删了，结果就没有成功生成页面，发现了之后把#号删了就恢复正常了。\n\n## [hexo语句发生错误 Template render error: (unknown path)](#hexo语句发生错误%20Template%20render20%error:%20(unknown%20path))\n\n在我写完另外一篇文章后，打算测试一下，发现无论是hexo g还是hexo s都会报错，于是移除了那篇文章，重新尝试了一下发现可以了。\n在网上看到似乎不能用}}这样的符号，我回去看那篇文章时发现我有一个}误删了，这才的导致解析不通过。\n结合之前生成空白html的经历，我发现只要文件里面有一点语法错误都会出现很大问题，如果某次操作突然出错了，记得去检查你最近的修改和文章有没有语法错误。\n\n## [左下角多了一个undefined](#左下角多了一个undefined)\n\n最新版本的看板娘，在layout/_layout.swig的`</body>`前加上{ { live2d() } }，会产生一个默认的看板娘。\n如果在_config.yml文件中只设置一个，这就会产生冲突，导致有一个无法定义，所以会在页面多出一个undefined语句。\n在最新版本要把`</body>`前的{ { live2d() } }删除，这样才不会出错。\n\n## [文件过大push不了](#文件过大push不了)\n\n更新404页面的时候，我这404里面插入了一个视频，然后在上传的时候发现github不支持超过100M的文件，所以我把视频删了，重新部署一遍博客。\n但每次部署都会继续上传我删掉的那个视频，为什么呢？\n我已经把404文件夹里面的视频删了，也把public文件夹里面的视频删了，我还检查了一遍.deploy_git下面的文件夹，都没发现那个视频了。\n上网重新查了一下hexo的部署方式才知道，执行hexo d，就会把这个public文件夹的东西完完整整拷贝到.deploy_git文件夹里。\n想起了之前部署失败，应该是.deploy_git文件夹里面还保留了之前没push的信息，才会导致现在也部署不了。\n解决方法就是执行`hexo cl`清除一下缓存，或者直接把.deploy_git文件夹删了，\n这样重新部署就没问题了。\n顺便一提，其实那个视频我还是插进去了，只不过用了另外一种方法...\n","source":"_posts/使用Hexo-NexT时遇到的问题.md","raw":"---\ntitle: 使用Hexo-NexT时遇到的问题\ndate: 2019-3-29\ncategories: 开发记录\ntags:\n    - 博客\n---\n## 部署到github显示的网页和本地测试的网页不一样\n\n<font size=\"4\">\n之前设置了网页的背景图片还有側框的边角，同时添加了右上角的github跳转图标和阅读全文的设置。\n\n但是在在本地测试完，部署到github时，发现只有github图标和阅读全文的设置生效了，背景图片和边角设置没有体现出来。\n\n这是因为github部署的时候缓存加载比较慢，有时候要过一段时间才会显示出你想要的效果，用`hexo clean`清除一下public文件夹,再重新部署用`hexo g -d`部署一下，多刷新几次就行了。\n</font><br /> \n\n## [生成了空白的html文件](#生成了空白的html文件)\n\n第一次遇到这个问题的时候，我是直接重新搭建了这个博客的，毕竟一直不知道怎么解决，明明上一步操作还是没问题的，下一步页面突然就崩溃了。\n\n后来这个博客又遇到了一次，好在我找到了解决方法：\n\n如果找不到index.html文件（在生成的public文件夹里面）的话，要先用`npm ls --depth 0`检查一下插件情况,如果插件缺失了deploy和generator这两个插件的话就要用`npm install`重新安装插件。\n\n**如果是有html文件，但文件是空白的。那么你就要检查你刚刚修改的配置了，如果你修改一个文件里某一个配置下的某一项，但那一个配置忘记打开的话就会导致这样的情况。**\n\n例如我在主题配置文件里的友情链接links下增加了网易云音乐这一个选项，但是links前面原先有一个#号，我没有删除打开的话，生成的index.html文件就是空白的。\n\n而我就是遇到了这种情况，当时不知道是修改了哪一个配置，忘记把#号删了，结果就没有成功生成页面，发现了之后把#号删了就恢复正常了。\n\n## [hexo语句发生错误 Template render error: (unknown path)](#hexo语句发生错误%20Template%20render20%error:%20(unknown%20path))\n\n在我写完另外一篇文章后，打算测试一下，发现无论是hexo g还是hexo s都会报错，于是移除了那篇文章，重新尝试了一下发现可以了。\n在网上看到似乎不能用}}这样的符号，我回去看那篇文章时发现我有一个}误删了，这才的导致解析不通过。\n结合之前生成空白html的经历，我发现只要文件里面有一点语法错误都会出现很大问题，如果某次操作突然出错了，记得去检查你最近的修改和文章有没有语法错误。\n\n## [左下角多了一个undefined](#左下角多了一个undefined)\n\n最新版本的看板娘，在layout/_layout.swig的`</body>`前加上{ { live2d() } }，会产生一个默认的看板娘。\n如果在_config.yml文件中只设置一个，这就会产生冲突，导致有一个无法定义，所以会在页面多出一个undefined语句。\n在最新版本要把`</body>`前的{ { live2d() } }删除，这样才不会出错。\n\n## [文件过大push不了](#文件过大push不了)\n\n更新404页面的时候，我这404里面插入了一个视频，然后在上传的时候发现github不支持超过100M的文件，所以我把视频删了，重新部署一遍博客。\n但每次部署都会继续上传我删掉的那个视频，为什么呢？\n我已经把404文件夹里面的视频删了，也把public文件夹里面的视频删了，我还检查了一遍.deploy_git下面的文件夹，都没发现那个视频了。\n上网重新查了一下hexo的部署方式才知道，执行hexo d，就会把这个public文件夹的东西完完整整拷贝到.deploy_git文件夹里。\n想起了之前部署失败，应该是.deploy_git文件夹里面还保留了之前没push的信息，才会导致现在也部署不了。\n解决方法就是执行`hexo cl`清除一下缓存，或者直接把.deploy_git文件夹删了，\n这样重新部署就没问题了。\n顺便一提，其实那个视频我还是插进去了，只不过用了另外一种方法...\n","slug":"使用Hexo-NexT时遇到的问题","published":1,"updated":"2020-02-06T09:19:45.729Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6ywrivu000c54v5239j62nt","content":"<h2 id=\"部署到github显示的网页和本地测试的网页不一样\"><a href=\"#部署到github显示的网页和本地测试的网页不一样\" class=\"headerlink\" title=\"部署到github显示的网页和本地测试的网页不一样\"></a>部署到github显示的网页和本地测试的网页不一样</h2><font size=\"4\">\n之前设置了网页的背景图片还有側框的边角，同时添加了右上角的github跳转图标和阅读全文的设置。\n\n<p>但是在在本地测试完，部署到github时，发现只有github图标和阅读全文的设置生效了，背景图片和边角设置没有体现出来。</p>\n<p>这是因为github部署的时候缓存加载比较慢，有时候要过一段时间才会显示出你想要的效果，用<code>hexo clean</code>清除一下public文件夹,再重新部署用<code>hexo g -d</code>部署一下，多刷新几次就行了。<br></font><br /> </p>\n<h2 id=\"生成了空白的html文件\"><a href=\"#生成了空白的html文件\" class=\"headerlink\" title=\"生成了空白的html文件\"></a><a href=\"#生成了空白的html文件\">生成了空白的html文件</a></h2><p>第一次遇到这个问题的时候，我是直接重新搭建了这个博客的，毕竟一直不知道怎么解决，明明上一步操作还是没问题的，下一步页面突然就崩溃了。</p>\n<p>后来这个博客又遇到了一次，好在我找到了解决方法：</p>\n<p>如果找不到index.html文件（在生成的public文件夹里面）的话，要先用<code>npm ls --depth 0</code>检查一下插件情况,如果插件缺失了deploy和generator这两个插件的话就要用<code>npm install</code>重新安装插件。</p>\n<p><strong>如果是有html文件，但文件是空白的。那么你就要检查你刚刚修改的配置了，如果你修改一个文件里某一个配置下的某一项，但那一个配置忘记打开的话就会导致这样的情况。</strong></p>\n<p>例如我在主题配置文件里的友情链接links下增加了网易云音乐这一个选项，但是links前面原先有一个#号，我没有删除打开的话，生成的index.html文件就是空白的。</p>\n<p>而我就是遇到了这种情况，当时不知道是修改了哪一个配置，忘记把#号删了，结果就没有成功生成页面，发现了之后把#号删了就恢复正常了。</p>\n<h2 id=\"hexo语句发生错误-Template-render-error-unknown-path\"><a href=\"#hexo语句发生错误-Template-render-error-unknown-path\" class=\"headerlink\" title=\"hexo语句发生错误 Template render error: (unknown path)\"></a><a href=\"#hexo语句发生错误%20Template%20render20%error:%20(unknown%20path)\">hexo语句发生错误 Template render error: (unknown path)</a></h2><p>在我写完另外一篇文章后，打算测试一下，发现无论是hexo g还是hexo s都会报错，于是移除了那篇文章，重新尝试了一下发现可以了。<br>在网上看到似乎不能用}}这样的符号，我回去看那篇文章时发现我有一个}误删了，这才的导致解析不通过。<br>结合之前生成空白html的经历，我发现只要文件里面有一点语法错误都会出现很大问题，如果某次操作突然出错了，记得去检查你最近的修改和文章有没有语法错误。</p>\n<h2 id=\"左下角多了一个undefined\"><a href=\"#左下角多了一个undefined\" class=\"headerlink\" title=\"左下角多了一个undefined\"></a><a href=\"#左下角多了一个undefined\">左下角多了一个undefined</a></h2><p>最新版本的看板娘，在layout/_layout.swig的<code>&lt;/body&gt;</code>前加上{ { live2d() } }，会产生一个默认的看板娘。<br>如果在_config.yml文件中只设置一个，这就会产生冲突，导致有一个无法定义，所以会在页面多出一个undefined语句。<br>在最新版本要把<code>&lt;/body&gt;</code>前的{ { live2d() } }删除，这样才不会出错。</p>\n<h2 id=\"文件过大push不了\"><a href=\"#文件过大push不了\" class=\"headerlink\" title=\"文件过大push不了\"></a><a href=\"#文件过大push不了\">文件过大push不了</a></h2><p>更新404页面的时候，我这404里面插入了一个视频，然后在上传的时候发现github不支持超过100M的文件，所以我把视频删了，重新部署一遍博客。<br>但每次部署都会继续上传我删掉的那个视频，为什么呢？<br>我已经把404文件夹里面的视频删了，也把public文件夹里面的视频删了，我还检查了一遍.deploy_git下面的文件夹，都没发现那个视频了。<br>上网重新查了一下hexo的部署方式才知道，执行hexo d，就会把这个public文件夹的东西完完整整拷贝到.deploy_git文件夹里。<br>想起了之前部署失败，应该是.deploy_git文件夹里面还保留了之前没push的信息，才会导致现在也部署不了。<br>解决方法就是执行<code>hexo cl</code>清除一下缓存，或者直接把.deploy_git文件夹删了，<br>这样重新部署就没问题了。<br>顺便一提，其实那个视频我还是插进去了，只不过用了另外一种方法…</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"部署到github显示的网页和本地测试的网页不一样\"><a href=\"#部署到github显示的网页和本地测试的网页不一样\" class=\"headerlink\" title=\"部署到github显示的网页和本地测试的网页不一样\"></a>部署到github显示的网页和本地测试的网页不一样</h2><font size=\"4\">\n之前设置了网页的背景图片还有側框的边角，同时添加了右上角的github跳转图标和阅读全文的设置。\n\n<p>但是在在本地测试完，部署到github时，发现只有github图标和阅读全文的设置生效了，背景图片和边角设置没有体现出来。</p>\n<p>这是因为github部署的时候缓存加载比较慢，有时候要过一段时间才会显示出你想要的效果，用<code>hexo clean</code>清除一下public文件夹,再重新部署用<code>hexo g -d</code>部署一下，多刷新几次就行了。<br></font><br /> </p>\n<h2 id=\"生成了空白的html文件\"><a href=\"#生成了空白的html文件\" class=\"headerlink\" title=\"生成了空白的html文件\"></a><a href=\"#生成了空白的html文件\">生成了空白的html文件</a></h2><p>第一次遇到这个问题的时候，我是直接重新搭建了这个博客的，毕竟一直不知道怎么解决，明明上一步操作还是没问题的，下一步页面突然就崩溃了。</p>\n<p>后来这个博客又遇到了一次，好在我找到了解决方法：</p>\n<p>如果找不到index.html文件（在生成的public文件夹里面）的话，要先用<code>npm ls --depth 0</code>检查一下插件情况,如果插件缺失了deploy和generator这两个插件的话就要用<code>npm install</code>重新安装插件。</p>\n<p><strong>如果是有html文件，但文件是空白的。那么你就要检查你刚刚修改的配置了，如果你修改一个文件里某一个配置下的某一项，但那一个配置忘记打开的话就会导致这样的情况。</strong></p>\n<p>例如我在主题配置文件里的友情链接links下增加了网易云音乐这一个选项，但是links前面原先有一个#号，我没有删除打开的话，生成的index.html文件就是空白的。</p>\n<p>而我就是遇到了这种情况，当时不知道是修改了哪一个配置，忘记把#号删了，结果就没有成功生成页面，发现了之后把#号删了就恢复正常了。</p>\n<h2 id=\"hexo语句发生错误-Template-render-error-unknown-path\"><a href=\"#hexo语句发生错误-Template-render-error-unknown-path\" class=\"headerlink\" title=\"hexo语句发生错误 Template render error: (unknown path)\"></a><a href=\"#hexo语句发生错误%20Template%20render20%error:%20(unknown%20path)\">hexo语句发生错误 Template render error: (unknown path)</a></h2><p>在我写完另外一篇文章后，打算测试一下，发现无论是hexo g还是hexo s都会报错，于是移除了那篇文章，重新尝试了一下发现可以了。<br>在网上看到似乎不能用}}这样的符号，我回去看那篇文章时发现我有一个}误删了，这才的导致解析不通过。<br>结合之前生成空白html的经历，我发现只要文件里面有一点语法错误都会出现很大问题，如果某次操作突然出错了，记得去检查你最近的修改和文章有没有语法错误。</p>\n<h2 id=\"左下角多了一个undefined\"><a href=\"#左下角多了一个undefined\" class=\"headerlink\" title=\"左下角多了一个undefined\"></a><a href=\"#左下角多了一个undefined\">左下角多了一个undefined</a></h2><p>最新版本的看板娘，在layout/_layout.swig的<code>&lt;/body&gt;</code>前加上{ { live2d() } }，会产生一个默认的看板娘。<br>如果在_config.yml文件中只设置一个，这就会产生冲突，导致有一个无法定义，所以会在页面多出一个undefined语句。<br>在最新版本要把<code>&lt;/body&gt;</code>前的{ { live2d() } }删除，这样才不会出错。</p>\n<h2 id=\"文件过大push不了\"><a href=\"#文件过大push不了\" class=\"headerlink\" title=\"文件过大push不了\"></a><a href=\"#文件过大push不了\">文件过大push不了</a></h2><p>更新404页面的时候，我这404里面插入了一个视频，然后在上传的时候发现github不支持超过100M的文件，所以我把视频删了，重新部署一遍博客。<br>但每次部署都会继续上传我删掉的那个视频，为什么呢？<br>我已经把404文件夹里面的视频删了，也把public文件夹里面的视频删了，我还检查了一遍.deploy_git下面的文件夹，都没发现那个视频了。<br>上网重新查了一下hexo的部署方式才知道，执行hexo d，就会把这个public文件夹的东西完完整整拷贝到.deploy_git文件夹里。<br>想起了之前部署失败，应该是.deploy_git文件夹里面还保留了之前没push的信息，才会导致现在也部署不了。<br>解决方法就是执行<code>hexo cl</code>清除一下缓存，或者直接把.deploy_git文件夹删了，<br>这样重新部署就没问题了。<br>顺便一提，其实那个视频我还是插进去了，只不过用了另外一种方法…</p>\n"},{"title":"关于沉迷于东方Project这件事","date":"2020-01-23T16:00:00.000Z","_content":"\n这件事要从当初玩饥荒开始说起。\n\n快期末的时候被朋友拉去玩饥荒，依我这性格，刚入手的游戏肯定会沉迷其中，当时看各种玩法，安装各种模组，尤其是喜欢安装那些人物的模组，毕竟原本就很喜欢二次元的东西\n\n其中一个人物模组就是东方Project的一个人物\"幽幽子\"，当时并不知道她是怎么玩的，就拿个扇子到处跑，然后感觉不好玩就换了个人物了。\n\n后来一个偶然的机会，看到了关于这个模组的介绍视频，就点进去看了一下(毕竟还是想知道这个设计是怎么玩的)\n\n附上视频地址：[https://www.bilibili.com/video/av26511125/](https://www.bilibili.com/video/av26511125/)\n\n视频里介绍模组玩法的时候，也有介绍幽幽子的故事背景，当时就给幽幽子的人设和故事给吸引了，开始了寻找幽幽子相关内容的路程！\n\n然后就...一发不可收拾，开始往整个东方Project扩展了\n\n在网上到处找东方Project的故事介绍和视频，虽然知道是游戏，不过本人并没有打算入坑游戏的意思，毕竟像这种二次元的内容，我还是偏向喜欢看视频(什么时候才能动画化啊~滑稽)\n\n东方整个设定刚好符合我的口味(满是美少女的妖怪世界？)，其中的红魔馆的二小姐和妖妖梦的幽幽子的设定是我最喜欢的，当然感触最深的还是幽幽子和西行妖的设定。\n关于歌曲的，肯定得说说<華鳥風月>。东方的歌曲风格并不是我喜欢的那种类型，不过这首歌的曲调和里面的一些歌词我倒是挺喜欢的，例如我的about页面里的\"正しさなんてもの、人のモノサシによって変わる\"这句话，就是歌词4句ああ后的那前两句。\n博客的主页背景和文章背景也是来自东方，毕竟重新修改博客的这段时间刚好沉迷于这个，连桌面背景也都是这个(笑)。\n\n在网上看到有关于东方的同人视频作品，看百科似乎是作者不想轻易动画化，想做成剧场版，嘛~对我来说只要是视频都会期待一下，不知道官方动画作品出来那一天什么时候会到\n\n2020/1/30\n---\n\n东方歌曲真好听，Bad Apple真带感\n(真香)\n","source":"_posts/关于沉迷于东方Project这件事.md","raw":"---\ntitle: 关于沉迷于东方Project这件事\ndate: 2020-1-24\ncategories: 生活日常\n---\n\n这件事要从当初玩饥荒开始说起。\n\n快期末的时候被朋友拉去玩饥荒，依我这性格，刚入手的游戏肯定会沉迷其中，当时看各种玩法，安装各种模组，尤其是喜欢安装那些人物的模组，毕竟原本就很喜欢二次元的东西\n\n其中一个人物模组就是东方Project的一个人物\"幽幽子\"，当时并不知道她是怎么玩的，就拿个扇子到处跑，然后感觉不好玩就换了个人物了。\n\n后来一个偶然的机会，看到了关于这个模组的介绍视频，就点进去看了一下(毕竟还是想知道这个设计是怎么玩的)\n\n附上视频地址：[https://www.bilibili.com/video/av26511125/](https://www.bilibili.com/video/av26511125/)\n\n视频里介绍模组玩法的时候，也有介绍幽幽子的故事背景，当时就给幽幽子的人设和故事给吸引了，开始了寻找幽幽子相关内容的路程！\n\n然后就...一发不可收拾，开始往整个东方Project扩展了\n\n在网上到处找东方Project的故事介绍和视频，虽然知道是游戏，不过本人并没有打算入坑游戏的意思，毕竟像这种二次元的内容，我还是偏向喜欢看视频(什么时候才能动画化啊~滑稽)\n\n东方整个设定刚好符合我的口味(满是美少女的妖怪世界？)，其中的红魔馆的二小姐和妖妖梦的幽幽子的设定是我最喜欢的，当然感触最深的还是幽幽子和西行妖的设定。\n关于歌曲的，肯定得说说<華鳥風月>。东方的歌曲风格并不是我喜欢的那种类型，不过这首歌的曲调和里面的一些歌词我倒是挺喜欢的，例如我的about页面里的\"正しさなんてもの、人のモノサシによって変わる\"这句话，就是歌词4句ああ后的那前两句。\n博客的主页背景和文章背景也是来自东方，毕竟重新修改博客的这段时间刚好沉迷于这个，连桌面背景也都是这个(笑)。\n\n在网上看到有关于东方的同人视频作品，看百科似乎是作者不想轻易动画化，想做成剧场版，嘛~对我来说只要是视频都会期待一下，不知道官方动画作品出来那一天什么时候会到\n\n2020/1/30\n---\n\n东方歌曲真好听，Bad Apple真带感\n(真香)\n","slug":"关于沉迷于东方Project这件事","published":1,"updated":"2020-02-06T08:56:13.642Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6ywrivv000g54v5fi933jd3","content":"<p>这件事要从当初玩饥荒开始说起。</p>\n<p>快期末的时候被朋友拉去玩饥荒，依我这性格，刚入手的游戏肯定会沉迷其中，当时看各种玩法，安装各种模组，尤其是喜欢安装那些人物的模组，毕竟原本就很喜欢二次元的东西</p>\n<p>其中一个人物模组就是东方Project的一个人物”幽幽子”，当时并不知道她是怎么玩的，就拿个扇子到处跑，然后感觉不好玩就换了个人物了。</p>\n<p>后来一个偶然的机会，看到了关于这个模组的介绍视频，就点进去看了一下(毕竟还是想知道这个设计是怎么玩的)</p>\n<p>附上视频地址：<a href=\"https://www.bilibili.com/video/av26511125/\" target=\"_blank\" rel=\"noopener\">https://www.bilibili.com/video/av26511125/</a></p>\n<p>视频里介绍模组玩法的时候，也有介绍幽幽子的故事背景，当时就给幽幽子的人设和故事给吸引了，开始了寻找幽幽子相关内容的路程！</p>\n<p>然后就…一发不可收拾，开始往整个东方Project扩展了</p>\n<p>在网上到处找东方Project的故事介绍和视频，虽然知道是游戏，不过本人并没有打算入坑游戏的意思，毕竟像这种二次元的内容，我还是偏向喜欢看视频(什么时候才能动画化啊~滑稽)</p>\n<p>东方整个设定刚好符合我的口味(满是美少女的妖怪世界？)，其中的红魔馆的二小姐和妖妖梦的幽幽子的设定是我最喜欢的，当然感触最深的还是幽幽子和西行妖的设定。<br>关于歌曲的，肯定得说说&lt;華鳥風月&gt;。东方的歌曲风格并不是我喜欢的那种类型，不过这首歌的曲调和里面的一些歌词我倒是挺喜欢的，例如我的about页面里的”正しさなんてもの、人のモノサシによって変わる”这句话，就是歌词4句ああ后的那前两句。<br>博客的主页背景和文章背景也是来自东方，毕竟重新修改博客的这段时间刚好沉迷于这个，连桌面背景也都是这个(笑)。</p>\n<p>在网上看到有关于东方的同人视频作品，看百科似乎是作者不想轻易动画化，想做成剧场版，嘛~对我来说只要是视频都会期待一下，不知道官方动画作品出来那一天什么时候会到</p>\n<h2 id=\"2020-1-30\"><a href=\"#2020-1-30\" class=\"headerlink\" title=\"2020/1/30\"></a>2020/1/30</h2><p>东方歌曲真好听，Bad Apple真带感<br>(真香)</p>\n","site":{"data":{}},"excerpt":"","more":"<p>这件事要从当初玩饥荒开始说起。</p>\n<p>快期末的时候被朋友拉去玩饥荒，依我这性格，刚入手的游戏肯定会沉迷其中，当时看各种玩法，安装各种模组，尤其是喜欢安装那些人物的模组，毕竟原本就很喜欢二次元的东西</p>\n<p>其中一个人物模组就是东方Project的一个人物”幽幽子”，当时并不知道她是怎么玩的，就拿个扇子到处跑，然后感觉不好玩就换了个人物了。</p>\n<p>后来一个偶然的机会，看到了关于这个模组的介绍视频，就点进去看了一下(毕竟还是想知道这个设计是怎么玩的)</p>\n<p>附上视频地址：<a href=\"https://www.bilibili.com/video/av26511125/\" target=\"_blank\" rel=\"noopener\">https://www.bilibili.com/video/av26511125/</a></p>\n<p>视频里介绍模组玩法的时候，也有介绍幽幽子的故事背景，当时就给幽幽子的人设和故事给吸引了，开始了寻找幽幽子相关内容的路程！</p>\n<p>然后就…一发不可收拾，开始往整个东方Project扩展了</p>\n<p>在网上到处找东方Project的故事介绍和视频，虽然知道是游戏，不过本人并没有打算入坑游戏的意思，毕竟像这种二次元的内容，我还是偏向喜欢看视频(什么时候才能动画化啊~滑稽)</p>\n<p>东方整个设定刚好符合我的口味(满是美少女的妖怪世界？)，其中的红魔馆的二小姐和妖妖梦的幽幽子的设定是我最喜欢的，当然感触最深的还是幽幽子和西行妖的设定。<br>关于歌曲的，肯定得说说&lt;華鳥風月&gt;。东方的歌曲风格并不是我喜欢的那种类型，不过这首歌的曲调和里面的一些歌词我倒是挺喜欢的，例如我的about页面里的”正しさなんてもの、人のモノサシによって変わる”这句话，就是歌词4句ああ后的那前两句。<br>博客的主页背景和文章背景也是来自东方，毕竟重新修改博客的这段时间刚好沉迷于这个，连桌面背景也都是这个(笑)。</p>\n<p>在网上看到有关于东方的同人视频作品，看百科似乎是作者不想轻易动画化，想做成剧场版，嘛~对我来说只要是视频都会期待一下，不知道官方动画作品出来那一天什么时候会到</p>\n<h2 id=\"2020-1-30\"><a href=\"#2020-1-30\" class=\"headerlink\" title=\"2020/1/30\"></a>2020/1/30</h2><p>东方歌曲真好听，Bad Apple真带感<br>(真香)</p>\n"},{"title":"强类型与动态类型的Python","date":"2019-11-09T16:00:00.000Z","_content":"\n**很多人都会说到Python是一门强类型、动态类型的语言，为什么这么说呢？**\n\n我们先来看一下什么是强类型的语言\n**百度答案：强类型指的是程序中表达的任何对象所从属的类型都必须能在编译时刻确定。**\n什么意思呢？\n就是说，在编译的时候，变量的类型就可以被编译器确定，并且运行时该变量不经过强制转换将类型无法发生改变。\n例如我在Python里面定义了两个不同类型的变量，然后对这两个变量进行以下操作\n\n```Python\na = 1\nb = \"b\"\na + b\n```\n\n就会报如下的类型错误(TypeError)\n\n![TypeError](/images/Python特性/TypeError1.png)\n\n因为a和b是两个不同类型的变量，在不可以进行加号操作，但是在C语言里面可以，因为会进行隐式转换，而在Python里面不会进行类型隐式转换。\n对于Python来说，变量不通过int()或str()等方法进行转换的话，那么该变量的类型将无法发生改变\n**根据百度提供的信息可以了解到：强类型是针对类型检查的严格程度而言的，它指任何变量在使用的时候必须要指定这个变量的类型，而且在程序的运行过程中这个变量只能存储这个类型的数据。**\n\n但是我们在用Python的时候就会知道，我们是可以给变量赋其它类型的值的，例如我们可以这样写\n\n```Python\na = 1\na = False\nb = \"b\"\na = b\n```\n\n这不是和强类型的定义发生冲突了吗？\n其实这涉及到我们要讲的另外一个问题，**动态类型**。\n\n为什么说Python是动态类型呢？\n\n因为Python的变量并不是指定了类型的，Python的变量在进行赋值的时候，是指向了对象的地址，在进行重新赋值的时候，Python变量并不关心值的类型，因为它只是改变了地址的指向。这种赋值方式报错导致的类型错误，都是在运行的时候才会发生，包括上面举的例子的。\n\n**在编译的时候不对变量类型进行识别，在运行的时候可以改变其结构的语言，我们称为动态语言。**\n\n因为Python的这个特性，所以可以抛开强类型语言对于赋值时类型的要求，但是在运行时会对变量指向地址的值的类型进行判别。\n这就是Python既是动态类型语言，也是强类型语言的原因。\n\n对于Python这种动态指向，在编写程序的时候，给我们带来了很多方便，但是稍不注意，也会让程序发生一些难以察觉的错误。\n例如我们对列表操作的时候\n\n![dynamic](/images/Python特性/dynamic1.png)\n\n当Python将一个列表赋给变量a，此时a并不等于[1,2,3]，而是指向了这个列表的地址。\n将a的值赋给b的时候，相当于将b的指向修改成a的指向，也就是b也是指向这个列表的地址。当你对b进行操作的时候，就是在对这个地址的值进行操作，所以a的值也会发生改变，当程序在递归或者用树遍历的时候，如果这样进行列表的赋值，将会导致重大的错误。\n为了避免这种情况，Python也提供了一些方法给我们进行赋值使用，当我们希望将a和b不是指向同一个列表，但两个列表的值又要一样的时候，我们可以用list的copy()方法来对列表进行复制。这种情况下我们是复制出了一个新的列表赋给了b，所以对b操作的时候不会改变a的值。\n另外一种方法就是直接对整个列表进行截取：\n当我们使用a[x:y]时，可以截取到a中下标x到下标y的片段；\n当x或y的参数放空时，表示从头开始截取或者截取到尾；\n例：a[:y]就是截取下标0~y的片段，a[x:]就是从x开始截取到列表结束；\n而a[:]就是从头截取到最后一个元素，也就是整个列表都截取下来。\n\n![dynamic](/images/Python特性/dynamic2.png)\n\n或者是对多维列表的子列表进行修改\n\n![dynamic](/images/Python特性/dynamic3.png)\n\n**但是这两个方法对于多维列表操作单个元素来说，都不起作用！**\n\n![dynamic](/images/Python特性/dynamic4.png)\n\n**原因是：列表里面保存的元素，也是地址的指向！**\n当对多维列表的下一级列表进行操作的时候，是让该下标指向了另一个列表的地址，但是对该子列表的元素进行修改时，是修改子列表的元素的指向。\n\n附上图可能会更容易理解一点：\n![dynamic](/images/Python特性/introduce.png)\n\n例如：\n我将a复制给了b，虽然生成的是新列表，但是列表里面元素指向的地址是相同的，当我修改b[0]的时候，相当于是把b[0]指向了其它列表，此时a并不会收到影响。\n但是如果我修改的是b[1][1],此时我修改的是b[1]指向的列表下标为1的元素，但是a[1]和b[1]指向的是同一列表，相当于也是在修改a[1]的元素。\n\n这种情况下，也有应对的方法，我用的是for循环来进行重复制\n\n```Python\na = [[1,1,1],[1,1,1],[1,1,1]]\nb = []\nfor data in a:\n    b.append(data.copy())\n```\n\n但是这种办法对于对于n维列表，需要内嵌的for循环为n-1个，如果是维度高的列表，就不是很切实际了。\n如果大佬们有更好的方法，还请在评论区留言^_^\n\n掘金地址：<https://juejin.im/post/5dc7a58b51882521f62cc3c2>\n知乎地址：<https://zhuanlan.zhihu.com/p/91117079>\n","source":"_posts/强类型与动态类型的Python.md","raw":"---\ntitle: 强类型与动态类型的Python\ndate: 2019-11-10\ncategories: 技术文章\ntags:\n    - Python\n---\n\n**很多人都会说到Python是一门强类型、动态类型的语言，为什么这么说呢？**\n\n我们先来看一下什么是强类型的语言\n**百度答案：强类型指的是程序中表达的任何对象所从属的类型都必须能在编译时刻确定。**\n什么意思呢？\n就是说，在编译的时候，变量的类型就可以被编译器确定，并且运行时该变量不经过强制转换将类型无法发生改变。\n例如我在Python里面定义了两个不同类型的变量，然后对这两个变量进行以下操作\n\n```Python\na = 1\nb = \"b\"\na + b\n```\n\n就会报如下的类型错误(TypeError)\n\n![TypeError](/images/Python特性/TypeError1.png)\n\n因为a和b是两个不同类型的变量，在不可以进行加号操作，但是在C语言里面可以，因为会进行隐式转换，而在Python里面不会进行类型隐式转换。\n对于Python来说，变量不通过int()或str()等方法进行转换的话，那么该变量的类型将无法发生改变\n**根据百度提供的信息可以了解到：强类型是针对类型检查的严格程度而言的，它指任何变量在使用的时候必须要指定这个变量的类型，而且在程序的运行过程中这个变量只能存储这个类型的数据。**\n\n但是我们在用Python的时候就会知道，我们是可以给变量赋其它类型的值的，例如我们可以这样写\n\n```Python\na = 1\na = False\nb = \"b\"\na = b\n```\n\n这不是和强类型的定义发生冲突了吗？\n其实这涉及到我们要讲的另外一个问题，**动态类型**。\n\n为什么说Python是动态类型呢？\n\n因为Python的变量并不是指定了类型的，Python的变量在进行赋值的时候，是指向了对象的地址，在进行重新赋值的时候，Python变量并不关心值的类型，因为它只是改变了地址的指向。这种赋值方式报错导致的类型错误，都是在运行的时候才会发生，包括上面举的例子的。\n\n**在编译的时候不对变量类型进行识别，在运行的时候可以改变其结构的语言，我们称为动态语言。**\n\n因为Python的这个特性，所以可以抛开强类型语言对于赋值时类型的要求，但是在运行时会对变量指向地址的值的类型进行判别。\n这就是Python既是动态类型语言，也是强类型语言的原因。\n\n对于Python这种动态指向，在编写程序的时候，给我们带来了很多方便，但是稍不注意，也会让程序发生一些难以察觉的错误。\n例如我们对列表操作的时候\n\n![dynamic](/images/Python特性/dynamic1.png)\n\n当Python将一个列表赋给变量a，此时a并不等于[1,2,3]，而是指向了这个列表的地址。\n将a的值赋给b的时候，相当于将b的指向修改成a的指向，也就是b也是指向这个列表的地址。当你对b进行操作的时候，就是在对这个地址的值进行操作，所以a的值也会发生改变，当程序在递归或者用树遍历的时候，如果这样进行列表的赋值，将会导致重大的错误。\n为了避免这种情况，Python也提供了一些方法给我们进行赋值使用，当我们希望将a和b不是指向同一个列表，但两个列表的值又要一样的时候，我们可以用list的copy()方法来对列表进行复制。这种情况下我们是复制出了一个新的列表赋给了b，所以对b操作的时候不会改变a的值。\n另外一种方法就是直接对整个列表进行截取：\n当我们使用a[x:y]时，可以截取到a中下标x到下标y的片段；\n当x或y的参数放空时，表示从头开始截取或者截取到尾；\n例：a[:y]就是截取下标0~y的片段，a[x:]就是从x开始截取到列表结束；\n而a[:]就是从头截取到最后一个元素，也就是整个列表都截取下来。\n\n![dynamic](/images/Python特性/dynamic2.png)\n\n或者是对多维列表的子列表进行修改\n\n![dynamic](/images/Python特性/dynamic3.png)\n\n**但是这两个方法对于多维列表操作单个元素来说，都不起作用！**\n\n![dynamic](/images/Python特性/dynamic4.png)\n\n**原因是：列表里面保存的元素，也是地址的指向！**\n当对多维列表的下一级列表进行操作的时候，是让该下标指向了另一个列表的地址，但是对该子列表的元素进行修改时，是修改子列表的元素的指向。\n\n附上图可能会更容易理解一点：\n![dynamic](/images/Python特性/introduce.png)\n\n例如：\n我将a复制给了b，虽然生成的是新列表，但是列表里面元素指向的地址是相同的，当我修改b[0]的时候，相当于是把b[0]指向了其它列表，此时a并不会收到影响。\n但是如果我修改的是b[1][1],此时我修改的是b[1]指向的列表下标为1的元素，但是a[1]和b[1]指向的是同一列表，相当于也是在修改a[1]的元素。\n\n这种情况下，也有应对的方法，我用的是for循环来进行重复制\n\n```Python\na = [[1,1,1],[1,1,1],[1,1,1]]\nb = []\nfor data in a:\n    b.append(data.copy())\n```\n\n但是这种办法对于对于n维列表，需要内嵌的for循环为n-1个，如果是维度高的列表，就不是很切实际了。\n如果大佬们有更好的方法，还请在评论区留言^_^\n\n掘金地址：<https://juejin.im/post/5dc7a58b51882521f62cc3c2>\n知乎地址：<https://zhuanlan.zhihu.com/p/91117079>\n","slug":"强类型与动态类型的Python","published":1,"updated":"2020-01-29T18:42:11.373Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6ywrivx000i54v55l4bchn9","content":"<p><strong>很多人都会说到Python是一门强类型、动态类型的语言，为什么这么说呢？</strong></p>\n<p>我们先来看一下什么是强类型的语言<br><strong>百度答案：强类型指的是程序中表达的任何对象所从属的类型都必须能在编译时刻确定。</strong><br>什么意思呢？<br>就是说，在编译的时候，变量的类型就可以被编译器确定，并且运行时该变量不经过强制转换将类型无法发生改变。<br>例如我在Python里面定义了两个不同类型的变量，然后对这两个变量进行以下操作</p>\n<pre><code class=\"Python\">a = 1\nb = &quot;b&quot;\na + b</code></pre>\n<p>就会报如下的类型错误(TypeError)</p>\n<p><img src=\"/images/Python%E7%89%B9%E6%80%A7/TypeError1.png\" alt=\"TypeError\"></p>\n<p>因为a和b是两个不同类型的变量，在不可以进行加号操作，但是在C语言里面可以，因为会进行隐式转换，而在Python里面不会进行类型隐式转换。<br>对于Python来说，变量不通过int()或str()等方法进行转换的话，那么该变量的类型将无法发生改变<br><strong>根据百度提供的信息可以了解到：强类型是针对类型检查的严格程度而言的，它指任何变量在使用的时候必须要指定这个变量的类型，而且在程序的运行过程中这个变量只能存储这个类型的数据。</strong></p>\n<p>但是我们在用Python的时候就会知道，我们是可以给变量赋其它类型的值的，例如我们可以这样写</p>\n<pre><code class=\"Python\">a = 1\na = False\nb = &quot;b&quot;\na = b</code></pre>\n<p>这不是和强类型的定义发生冲突了吗？<br>其实这涉及到我们要讲的另外一个问题，<strong>动态类型</strong>。</p>\n<p>为什么说Python是动态类型呢？</p>\n<p>因为Python的变量并不是指定了类型的，Python的变量在进行赋值的时候，是指向了对象的地址，在进行重新赋值的时候，Python变量并不关心值的类型，因为它只是改变了地址的指向。这种赋值方式报错导致的类型错误，都是在运行的时候才会发生，包括上面举的例子的。</p>\n<p><strong>在编译的时候不对变量类型进行识别，在运行的时候可以改变其结构的语言，我们称为动态语言。</strong></p>\n<p>因为Python的这个特性，所以可以抛开强类型语言对于赋值时类型的要求，但是在运行时会对变量指向地址的值的类型进行判别。<br>这就是Python既是动态类型语言，也是强类型语言的原因。</p>\n<p>对于Python这种动态指向，在编写程序的时候，给我们带来了很多方便，但是稍不注意，也会让程序发生一些难以察觉的错误。<br>例如我们对列表操作的时候</p>\n<p><img src=\"/images/Python%E7%89%B9%E6%80%A7/dynamic1.png\" alt=\"dynamic\"></p>\n<p>当Python将一个列表赋给变量a，此时a并不等于[1,2,3]，而是指向了这个列表的地址。<br>将a的值赋给b的时候，相当于将b的指向修改成a的指向，也就是b也是指向这个列表的地址。当你对b进行操作的时候，就是在对这个地址的值进行操作，所以a的值也会发生改变，当程序在递归或者用树遍历的时候，如果这样进行列表的赋值，将会导致重大的错误。<br>为了避免这种情况，Python也提供了一些方法给我们进行赋值使用，当我们希望将a和b不是指向同一个列表，但两个列表的值又要一样的时候，我们可以用list的copy()方法来对列表进行复制。这种情况下我们是复制出了一个新的列表赋给了b，所以对b操作的时候不会改变a的值。<br>另外一种方法就是直接对整个列表进行截取：<br>当我们使用a[x:y]时，可以截取到a中下标x到下标y的片段；<br>当x或y的参数放空时，表示从头开始截取或者截取到尾；<br>例：a[:y]就是截取下标0~y的片段，a[x:]就是从x开始截取到列表结束；<br>而a[:]就是从头截取到最后一个元素，也就是整个列表都截取下来。</p>\n<p><img src=\"/images/Python%E7%89%B9%E6%80%A7/dynamic2.png\" alt=\"dynamic\"></p>\n<p>或者是对多维列表的子列表进行修改</p>\n<p><img src=\"/images/Python%E7%89%B9%E6%80%A7/dynamic3.png\" alt=\"dynamic\"></p>\n<p><strong>但是这两个方法对于多维列表操作单个元素来说，都不起作用！</strong></p>\n<p><img src=\"/images/Python%E7%89%B9%E6%80%A7/dynamic4.png\" alt=\"dynamic\"></p>\n<p><strong>原因是：列表里面保存的元素，也是地址的指向！</strong><br>当对多维列表的下一级列表进行操作的时候，是让该下标指向了另一个列表的地址，但是对该子列表的元素进行修改时，是修改子列表的元素的指向。</p>\n<p>附上图可能会更容易理解一点：<br><img src=\"/images/Python%E7%89%B9%E6%80%A7/introduce.png\" alt=\"dynamic\"></p>\n<p>例如：<br>我将a复制给了b，虽然生成的是新列表，但是列表里面元素指向的地址是相同的，当我修改b[0]的时候，相当于是把b[0]指向了其它列表，此时a并不会收到影响。<br>但是如果我修改的是b[1][1],此时我修改的是b[1]指向的列表下标为1的元素，但是a[1]和b[1]指向的是同一列表，相当于也是在修改a[1]的元素。</p>\n<p>这种情况下，也有应对的方法，我用的是for循环来进行重复制</p>\n<pre><code class=\"Python\">a = [[1,1,1],[1,1,1],[1,1,1]]\nb = []\nfor data in a:\n    b.append(data.copy())</code></pre>\n<p>但是这种办法对于对于n维列表，需要内嵌的for循环为n-1个，如果是维度高的列表，就不是很切实际了。<br>如果大佬们有更好的方法，还请在评论区留言^_^</p>\n<p>掘金地址：<a href=\"https://juejin.im/post/5dc7a58b51882521f62cc3c2\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5dc7a58b51882521f62cc3c2</a><br>知乎地址：<a href=\"https://zhuanlan.zhihu.com/p/91117079\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/91117079</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>很多人都会说到Python是一门强类型、动态类型的语言，为什么这么说呢？</strong></p>\n<p>我们先来看一下什么是强类型的语言<br><strong>百度答案：强类型指的是程序中表达的任何对象所从属的类型都必须能在编译时刻确定。</strong><br>什么意思呢？<br>就是说，在编译的时候，变量的类型就可以被编译器确定，并且运行时该变量不经过强制转换将类型无法发生改变。<br>例如我在Python里面定义了两个不同类型的变量，然后对这两个变量进行以下操作</p>\n<pre><code class=\"Python\">a = 1\nb = &quot;b&quot;\na + b</code></pre>\n<p>就会报如下的类型错误(TypeError)</p>\n<p><img src=\"/images/Python%E7%89%B9%E6%80%A7/TypeError1.png\" alt=\"TypeError\"></p>\n<p>因为a和b是两个不同类型的变量，在不可以进行加号操作，但是在C语言里面可以，因为会进行隐式转换，而在Python里面不会进行类型隐式转换。<br>对于Python来说，变量不通过int()或str()等方法进行转换的话，那么该变量的类型将无法发生改变<br><strong>根据百度提供的信息可以了解到：强类型是针对类型检查的严格程度而言的，它指任何变量在使用的时候必须要指定这个变量的类型，而且在程序的运行过程中这个变量只能存储这个类型的数据。</strong></p>\n<p>但是我们在用Python的时候就会知道，我们是可以给变量赋其它类型的值的，例如我们可以这样写</p>\n<pre><code class=\"Python\">a = 1\na = False\nb = &quot;b&quot;\na = b</code></pre>\n<p>这不是和强类型的定义发生冲突了吗？<br>其实这涉及到我们要讲的另外一个问题，<strong>动态类型</strong>。</p>\n<p>为什么说Python是动态类型呢？</p>\n<p>因为Python的变量并不是指定了类型的，Python的变量在进行赋值的时候，是指向了对象的地址，在进行重新赋值的时候，Python变量并不关心值的类型，因为它只是改变了地址的指向。这种赋值方式报错导致的类型错误，都是在运行的时候才会发生，包括上面举的例子的。</p>\n<p><strong>在编译的时候不对变量类型进行识别，在运行的时候可以改变其结构的语言，我们称为动态语言。</strong></p>\n<p>因为Python的这个特性，所以可以抛开强类型语言对于赋值时类型的要求，但是在运行时会对变量指向地址的值的类型进行判别。<br>这就是Python既是动态类型语言，也是强类型语言的原因。</p>\n<p>对于Python这种动态指向，在编写程序的时候，给我们带来了很多方便，但是稍不注意，也会让程序发生一些难以察觉的错误。<br>例如我们对列表操作的时候</p>\n<p><img src=\"/images/Python%E7%89%B9%E6%80%A7/dynamic1.png\" alt=\"dynamic\"></p>\n<p>当Python将一个列表赋给变量a，此时a并不等于[1,2,3]，而是指向了这个列表的地址。<br>将a的值赋给b的时候，相当于将b的指向修改成a的指向，也就是b也是指向这个列表的地址。当你对b进行操作的时候，就是在对这个地址的值进行操作，所以a的值也会发生改变，当程序在递归或者用树遍历的时候，如果这样进行列表的赋值，将会导致重大的错误。<br>为了避免这种情况，Python也提供了一些方法给我们进行赋值使用，当我们希望将a和b不是指向同一个列表，但两个列表的值又要一样的时候，我们可以用list的copy()方法来对列表进行复制。这种情况下我们是复制出了一个新的列表赋给了b，所以对b操作的时候不会改变a的值。<br>另外一种方法就是直接对整个列表进行截取：<br>当我们使用a[x:y]时，可以截取到a中下标x到下标y的片段；<br>当x或y的参数放空时，表示从头开始截取或者截取到尾；<br>例：a[:y]就是截取下标0~y的片段，a[x:]就是从x开始截取到列表结束；<br>而a[:]就是从头截取到最后一个元素，也就是整个列表都截取下来。</p>\n<p><img src=\"/images/Python%E7%89%B9%E6%80%A7/dynamic2.png\" alt=\"dynamic\"></p>\n<p>或者是对多维列表的子列表进行修改</p>\n<p><img src=\"/images/Python%E7%89%B9%E6%80%A7/dynamic3.png\" alt=\"dynamic\"></p>\n<p><strong>但是这两个方法对于多维列表操作单个元素来说，都不起作用！</strong></p>\n<p><img src=\"/images/Python%E7%89%B9%E6%80%A7/dynamic4.png\" alt=\"dynamic\"></p>\n<p><strong>原因是：列表里面保存的元素，也是地址的指向！</strong><br>当对多维列表的下一级列表进行操作的时候，是让该下标指向了另一个列表的地址，但是对该子列表的元素进行修改时，是修改子列表的元素的指向。</p>\n<p>附上图可能会更容易理解一点：<br><img src=\"/images/Python%E7%89%B9%E6%80%A7/introduce.png\" alt=\"dynamic\"></p>\n<p>例如：<br>我将a复制给了b，虽然生成的是新列表，但是列表里面元素指向的地址是相同的，当我修改b[0]的时候，相当于是把b[0]指向了其它列表，此时a并不会收到影响。<br>但是如果我修改的是b[1][1],此时我修改的是b[1]指向的列表下标为1的元素，但是a[1]和b[1]指向的是同一列表，相当于也是在修改a[1]的元素。</p>\n<p>这种情况下，也有应对的方法，我用的是for循环来进行重复制</p>\n<pre><code class=\"Python\">a = [[1,1,1],[1,1,1],[1,1,1]]\nb = []\nfor data in a:\n    b.append(data.copy())</code></pre>\n<p>但是这种办法对于对于n维列表，需要内嵌的for循环为n-1个，如果是维度高的列表，就不是很切实际了。<br>如果大佬们有更好的方法，还请在评论区留言^_^</p>\n<p>掘金地址：<a href=\"https://juejin.im/post/5dc7a58b51882521f62cc3c2\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5dc7a58b51882521f62cc3c2</a><br>知乎地址：<a href=\"https://zhuanlan.zhihu.com/p/91117079\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/91117079</a></p>\n"},{"title":"基于operator构建的Nested-List","date":"2020-01-30T13:30:00.000Z","_content":"\n## [简介](#简介)\n\nNested-List是一个使用operator库构建的一个嵌套列表操作库，主要用于对元素不是基本数据类型的列表进行排序、删除等操作，里面的大多函数使用了operator库，可以简化项目代码编写量。\n\n## [使用与示例](#使用与示例)\n\nNested-List可以使用pip进行安装：`pip install Nested-List`\n\nNested-List-1.0.x有4个可用函数，分别是排序、删除元素、最大值和最小值，Nested-List会自动判断传入的列表的元素是什么类型，并调用相应的处理函数，无论进行哪些操作，都要保证列表里的元素是同一类型，这是这个库的工作基础。\n\n```Python\ndef sort(nl, *key, order=False):\n    ...\n\ndef delete_items(dl, keys, values, compare=None):\n    ...\n\ndef max(nl, *keys):\n    ...\n\ndef min(nl, *keys):\n    ...\n```\n\n每个函数使用时都需要传入需要操作的列表。\n\n### [排序](#排序)\n\n排序可根据列表中元素的属性来对元素进行排序，排序顺序默认是升序，当order字段设置为True或者\"DESC\"时，将会降序排序，当传入值不符合规定时将会按照默认排序处理，有一个注意点是如果要设置order的值，要在全部参数传入完成后再传入order的值。\n\n```Python\nimport nested_list as ntls\n\ndict_list = [\n    {'name':'one', 'age':11},\n    {'name':'two', 'age':5},\n    {'name':'three','age':26},\n    {'name':'four','age':19}\n]\n\nntls.sort(dict_list,'age',order=False)\nprint(dict_list)\n\n# 排序完的输出将会是[{'name': 'two', 'age': 5}, {'name': 'one', 'age': 11}, {'name': 'four', 'age': 19}, {'name': 'three', 'age': 26}]\n```\n\n当然列表里的元素也可以是对象，但是你要确保你的对象都是同一类型的对象，并可以指定可排序属性\n\n```Python\nclass User:\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n    def __repr__(self):\n        return 'User({})'.format(self.age)\n\nuser_list = [\n    User('one',18),\n    User('two',9),\n    User('three',7),\n    User('four',15)\n]\n\nntls.sort(user_list, 'age')\nprint(user_list)\n\n# 排序完的输出将会是[User(7), User(9), User(15), User(18)]，如果你不重写__repr__，那么将会打印的列表里将会是对象信息，你将看不到排序效果\n```\n\n你可以传入多个参数来进行多次排序，如下\n\n```Python\nntls.sort(user_list, 'id', 'age',order=\"DESC\")\n```\n\n此时sort函数将会先根据id进行降序排序，排序完再根据age排序一次\n\n### [删除元素](#删除元素)\n\ndelete_items可根据列表的中元素的属性值来删除元素，同样的，delete_items处理的列表元素类型也可以是对象，但使用delete_items的时候传入参数有两个个注意点：\n\n1、无论要根据的属性有多少个，传入时只能存为一个可迭代对象传入，在Python里，虽然字符串可以被迭代，传入字符串也不会报错，但会得出错误的执行结果，所以建议传入一个tuple或者list\n\n2、当传入属性值只有一个时，传入的判断值不需要存入可迭代对象，直接传入即可，否则会出现错误的执行结果；当传入属性值有多个时，传入的判断值**只能**存为tuple对象传入\n\n**以下是例子：**\n\n```Python\n# 单个属性时正确的使用方式\nntls.delete_items(user_list, ['age'], 7)\n# 或者可以这样\nntls.delete_items(user_list, ('age'), 7)\n\n# 单个属性时错误的使用方式\nntls.delete_items(user_list, ['age'], (7))\nntls.delete_items(user_list, 'age', 7)\n\n# 传入多个属性时正确的使用方式\nntls.delete_items(user_list, None, ['age','name'],(7,'four'))\n\n# 传入多个属性时错误的使用方式\nntls.delete_items(user_list, None, ['age','name'],7,'four')\nntls.delete_items(user_list, None, ['age','name'],[7,'four'])\n```\n\n### [最大值与最小值](#最大值与最小值)\n\n如果要根据元素中某个属性来找出最值，可以调用max传入key来处理，Nested-List底层也是这么使用，对于Nested-List来说，只是引入了operator的attrgetter和itemgetter来传入key并进行了简单的包装，Nested-List的max和min也是返回了Python内置的max和min函数的工作结果。\n\n对于Nested-List的max和min的使用方法如下\n\n```Python\nntls.max(user_list, \"age\")\n```\n\n当有多个判断属性时，可直接传入多个属性名称\n\n```Python\nntls.max(user_list, \"age\", \"id\")\n```\n\n## [致谢](#致谢)\n\n感谢《Python Cookbook》3rd Edition的作者和翻译者，本项目的开发离不开Python Cookbook 3rd Edition Documentation里面的内容带给我的帮助和启发。\n\nNested-List起初的开发是针对项目中对列表中字典的排序，但随后的开发中在《Python Cookbook》3rd Edition的翻译文档中学习到了更加方便且有效率的方法，按照其中的思路将功能打包在一起供给其它人使用，同时Nested-List变得不再只能对列表中的字典进行操作，也可以对列表或者其他对象使用。\n\n## [链接](#链接)\n\n**Nested-List GitHub仓库主页：**[https://github.com/arukione/Nested-List](https://github.com/arukione/Nested-List)\n\n**Python Cookbook 3rd Edition Documentation：**[https://python3-cookbook.readthedocs.io/zh_CN/latest/index.html](https://python3-cookbook.readthedocs.io/zh_CN/latest/index.html)\n\n[闲着没事造轮子](https://www.arukione.com/2020/01/30/%E9%97%B2%E7%9D%80%E6%B2%A1%E4%BA%8B%E9%80%A0%E8%BD%AE%E5%AD%90/)\n","source":"_posts/基于operator构建的Nested-List.md","raw":"---\ntitle: 基于operator构建的Nested-List\ndate: 2020-1-30 21:30\ncategories: 技术文章\ntags:\n    - Python\n---\n\n## [简介](#简介)\n\nNested-List是一个使用operator库构建的一个嵌套列表操作库，主要用于对元素不是基本数据类型的列表进行排序、删除等操作，里面的大多函数使用了operator库，可以简化项目代码编写量。\n\n## [使用与示例](#使用与示例)\n\nNested-List可以使用pip进行安装：`pip install Nested-List`\n\nNested-List-1.0.x有4个可用函数，分别是排序、删除元素、最大值和最小值，Nested-List会自动判断传入的列表的元素是什么类型，并调用相应的处理函数，无论进行哪些操作，都要保证列表里的元素是同一类型，这是这个库的工作基础。\n\n```Python\ndef sort(nl, *key, order=False):\n    ...\n\ndef delete_items(dl, keys, values, compare=None):\n    ...\n\ndef max(nl, *keys):\n    ...\n\ndef min(nl, *keys):\n    ...\n```\n\n每个函数使用时都需要传入需要操作的列表。\n\n### [排序](#排序)\n\n排序可根据列表中元素的属性来对元素进行排序，排序顺序默认是升序，当order字段设置为True或者\"DESC\"时，将会降序排序，当传入值不符合规定时将会按照默认排序处理，有一个注意点是如果要设置order的值，要在全部参数传入完成后再传入order的值。\n\n```Python\nimport nested_list as ntls\n\ndict_list = [\n    {'name':'one', 'age':11},\n    {'name':'two', 'age':5},\n    {'name':'three','age':26},\n    {'name':'four','age':19}\n]\n\nntls.sort(dict_list,'age',order=False)\nprint(dict_list)\n\n# 排序完的输出将会是[{'name': 'two', 'age': 5}, {'name': 'one', 'age': 11}, {'name': 'four', 'age': 19}, {'name': 'three', 'age': 26}]\n```\n\n当然列表里的元素也可以是对象，但是你要确保你的对象都是同一类型的对象，并可以指定可排序属性\n\n```Python\nclass User:\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n    def __repr__(self):\n        return 'User({})'.format(self.age)\n\nuser_list = [\n    User('one',18),\n    User('two',9),\n    User('three',7),\n    User('four',15)\n]\n\nntls.sort(user_list, 'age')\nprint(user_list)\n\n# 排序完的输出将会是[User(7), User(9), User(15), User(18)]，如果你不重写__repr__，那么将会打印的列表里将会是对象信息，你将看不到排序效果\n```\n\n你可以传入多个参数来进行多次排序，如下\n\n```Python\nntls.sort(user_list, 'id', 'age',order=\"DESC\")\n```\n\n此时sort函数将会先根据id进行降序排序，排序完再根据age排序一次\n\n### [删除元素](#删除元素)\n\ndelete_items可根据列表的中元素的属性值来删除元素，同样的，delete_items处理的列表元素类型也可以是对象，但使用delete_items的时候传入参数有两个个注意点：\n\n1、无论要根据的属性有多少个，传入时只能存为一个可迭代对象传入，在Python里，虽然字符串可以被迭代，传入字符串也不会报错，但会得出错误的执行结果，所以建议传入一个tuple或者list\n\n2、当传入属性值只有一个时，传入的判断值不需要存入可迭代对象，直接传入即可，否则会出现错误的执行结果；当传入属性值有多个时，传入的判断值**只能**存为tuple对象传入\n\n**以下是例子：**\n\n```Python\n# 单个属性时正确的使用方式\nntls.delete_items(user_list, ['age'], 7)\n# 或者可以这样\nntls.delete_items(user_list, ('age'), 7)\n\n# 单个属性时错误的使用方式\nntls.delete_items(user_list, ['age'], (7))\nntls.delete_items(user_list, 'age', 7)\n\n# 传入多个属性时正确的使用方式\nntls.delete_items(user_list, None, ['age','name'],(7,'four'))\n\n# 传入多个属性时错误的使用方式\nntls.delete_items(user_list, None, ['age','name'],7,'four')\nntls.delete_items(user_list, None, ['age','name'],[7,'four'])\n```\n\n### [最大值与最小值](#最大值与最小值)\n\n如果要根据元素中某个属性来找出最值，可以调用max传入key来处理，Nested-List底层也是这么使用，对于Nested-List来说，只是引入了operator的attrgetter和itemgetter来传入key并进行了简单的包装，Nested-List的max和min也是返回了Python内置的max和min函数的工作结果。\n\n对于Nested-List的max和min的使用方法如下\n\n```Python\nntls.max(user_list, \"age\")\n```\n\n当有多个判断属性时，可直接传入多个属性名称\n\n```Python\nntls.max(user_list, \"age\", \"id\")\n```\n\n## [致谢](#致谢)\n\n感谢《Python Cookbook》3rd Edition的作者和翻译者，本项目的开发离不开Python Cookbook 3rd Edition Documentation里面的内容带给我的帮助和启发。\n\nNested-List起初的开发是针对项目中对列表中字典的排序，但随后的开发中在《Python Cookbook》3rd Edition的翻译文档中学习到了更加方便且有效率的方法，按照其中的思路将功能打包在一起供给其它人使用，同时Nested-List变得不再只能对列表中的字典进行操作，也可以对列表或者其他对象使用。\n\n## [链接](#链接)\n\n**Nested-List GitHub仓库主页：**[https://github.com/arukione/Nested-List](https://github.com/arukione/Nested-List)\n\n**Python Cookbook 3rd Edition Documentation：**[https://python3-cookbook.readthedocs.io/zh_CN/latest/index.html](https://python3-cookbook.readthedocs.io/zh_CN/latest/index.html)\n\n[闲着没事造轮子](https://www.arukione.com/2020/01/30/%E9%97%B2%E7%9D%80%E6%B2%A1%E4%BA%8B%E9%80%A0%E8%BD%AE%E5%AD%90/)\n","slug":"基于operator构建的Nested-List","published":1,"updated":"2020-01-31T04:48:49.195Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6ywrivy000m54v5d1rkhcmr","content":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a><a href=\"#简介\">简介</a></h2><p>Nested-List是一个使用operator库构建的一个嵌套列表操作库，主要用于对元素不是基本数据类型的列表进行排序、删除等操作，里面的大多函数使用了operator库，可以简化项目代码编写量。</p>\n<h2 id=\"使用与示例\"><a href=\"#使用与示例\" class=\"headerlink\" title=\"使用与示例\"></a><a href=\"#使用与示例\">使用与示例</a></h2><p>Nested-List可以使用pip进行安装：<code>pip install Nested-List</code></p>\n<p>Nested-List-1.0.x有4个可用函数，分别是排序、删除元素、最大值和最小值，Nested-List会自动判断传入的列表的元素是什么类型，并调用相应的处理函数，无论进行哪些操作，都要保证列表里的元素是同一类型，这是这个库的工作基础。</p>\n<pre><code class=\"Python\">def sort(nl, *key, order=False):\n    ...\n\ndef delete_items(dl, keys, values, compare=None):\n    ...\n\ndef max(nl, *keys):\n    ...\n\ndef min(nl, *keys):\n    ...</code></pre>\n<p>每个函数使用时都需要传入需要操作的列表。</p>\n<h3 id=\"排序\"><a href=\"#排序\" class=\"headerlink\" title=\"排序\"></a><a href=\"#排序\">排序</a></h3><p>排序可根据列表中元素的属性来对元素进行排序，排序顺序默认是升序，当order字段设置为True或者”DESC”时，将会降序排序，当传入值不符合规定时将会按照默认排序处理，有一个注意点是如果要设置order的值，要在全部参数传入完成后再传入order的值。</p>\n<pre><code class=\"Python\">import nested_list as ntls\n\ndict_list = [\n    {&#39;name&#39;:&#39;one&#39;, &#39;age&#39;:11},\n    {&#39;name&#39;:&#39;two&#39;, &#39;age&#39;:5},\n    {&#39;name&#39;:&#39;three&#39;,&#39;age&#39;:26},\n    {&#39;name&#39;:&#39;four&#39;,&#39;age&#39;:19}\n]\n\nntls.sort(dict_list,&#39;age&#39;,order=False)\nprint(dict_list)\n\n# 排序完的输出将会是[{&#39;name&#39;: &#39;two&#39;, &#39;age&#39;: 5}, {&#39;name&#39;: &#39;one&#39;, &#39;age&#39;: 11}, {&#39;name&#39;: &#39;four&#39;, &#39;age&#39;: 19}, {&#39;name&#39;: &#39;three&#39;, &#39;age&#39;: 26}]</code></pre>\n<p>当然列表里的元素也可以是对象，但是你要确保你的对象都是同一类型的对象，并可以指定可排序属性</p>\n<pre><code class=\"Python\">class User:\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n    def __repr__(self):\n        return &#39;User({})&#39;.format(self.age)\n\nuser_list = [\n    User(&#39;one&#39;,18),\n    User(&#39;two&#39;,9),\n    User(&#39;three&#39;,7),\n    User(&#39;four&#39;,15)\n]\n\nntls.sort(user_list, &#39;age&#39;)\nprint(user_list)\n\n# 排序完的输出将会是[User(7), User(9), User(15), User(18)]，如果你不重写__repr__，那么将会打印的列表里将会是对象信息，你将看不到排序效果</code></pre>\n<p>你可以传入多个参数来进行多次排序，如下</p>\n<pre><code class=\"Python\">ntls.sort(user_list, &#39;id&#39;, &#39;age&#39;,order=&quot;DESC&quot;)</code></pre>\n<p>此时sort函数将会先根据id进行降序排序，排序完再根据age排序一次</p>\n<h3 id=\"删除元素\"><a href=\"#删除元素\" class=\"headerlink\" title=\"删除元素\"></a><a href=\"#删除元素\">删除元素</a></h3><p>delete_items可根据列表的中元素的属性值来删除元素，同样的，delete_items处理的列表元素类型也可以是对象，但使用delete_items的时候传入参数有两个个注意点：</p>\n<p>1、无论要根据的属性有多少个，传入时只能存为一个可迭代对象传入，在Python里，虽然字符串可以被迭代，传入字符串也不会报错，但会得出错误的执行结果，所以建议传入一个tuple或者list</p>\n<p>2、当传入属性值只有一个时，传入的判断值不需要存入可迭代对象，直接传入即可，否则会出现错误的执行结果；当传入属性值有多个时，传入的判断值<strong>只能</strong>存为tuple对象传入</p>\n<p><strong>以下是例子：</strong></p>\n<pre><code class=\"Python\"># 单个属性时正确的使用方式\nntls.delete_items(user_list, [&#39;age&#39;], 7)\n# 或者可以这样\nntls.delete_items(user_list, (&#39;age&#39;), 7)\n\n# 单个属性时错误的使用方式\nntls.delete_items(user_list, [&#39;age&#39;], (7))\nntls.delete_items(user_list, &#39;age&#39;, 7)\n\n# 传入多个属性时正确的使用方式\nntls.delete_items(user_list, None, [&#39;age&#39;,&#39;name&#39;],(7,&#39;four&#39;))\n\n# 传入多个属性时错误的使用方式\nntls.delete_items(user_list, None, [&#39;age&#39;,&#39;name&#39;],7,&#39;four&#39;)\nntls.delete_items(user_list, None, [&#39;age&#39;,&#39;name&#39;],[7,&#39;four&#39;])</code></pre>\n<h3 id=\"最大值与最小值\"><a href=\"#最大值与最小值\" class=\"headerlink\" title=\"最大值与最小值\"></a><a href=\"#最大值与最小值\">最大值与最小值</a></h3><p>如果要根据元素中某个属性来找出最值，可以调用max传入key来处理，Nested-List底层也是这么使用，对于Nested-List来说，只是引入了operator的attrgetter和itemgetter来传入key并进行了简单的包装，Nested-List的max和min也是返回了Python内置的max和min函数的工作结果。</p>\n<p>对于Nested-List的max和min的使用方法如下</p>\n<pre><code class=\"Python\">ntls.max(user_list, &quot;age&quot;)</code></pre>\n<p>当有多个判断属性时，可直接传入多个属性名称</p>\n<pre><code class=\"Python\">ntls.max(user_list, &quot;age&quot;, &quot;id&quot;)</code></pre>\n<h2 id=\"致谢\"><a href=\"#致谢\" class=\"headerlink\" title=\"致谢\"></a><a href=\"#致谢\">致谢</a></h2><p>感谢《Python Cookbook》3rd Edition的作者和翻译者，本项目的开发离不开Python Cookbook 3rd Edition Documentation里面的内容带给我的帮助和启发。</p>\n<p>Nested-List起初的开发是针对项目中对列表中字典的排序，但随后的开发中在《Python Cookbook》3rd Edition的翻译文档中学习到了更加方便且有效率的方法，按照其中的思路将功能打包在一起供给其它人使用，同时Nested-List变得不再只能对列表中的字典进行操作，也可以对列表或者其他对象使用。</p>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a><a href=\"#链接\">链接</a></h2><p><strong>Nested-List GitHub仓库主页：</strong><a href=\"https://github.com/arukione/Nested-List\" target=\"_blank\" rel=\"noopener\">https://github.com/arukione/Nested-List</a></p>\n<p><strong>Python Cookbook 3rd Edition Documentation：</strong><a href=\"https://python3-cookbook.readthedocs.io/zh_CN/latest/index.html\" target=\"_blank\" rel=\"noopener\">https://python3-cookbook.readthedocs.io/zh_CN/latest/index.html</a></p>\n<p><a href=\"https://www.arukione.com/2020/01/30/%E9%97%B2%E7%9D%80%E6%B2%A1%E4%BA%8B%E9%80%A0%E8%BD%AE%E5%AD%90/\" target=\"_blank\" rel=\"noopener\">闲着没事造轮子</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a><a href=\"#简介\">简介</a></h2><p>Nested-List是一个使用operator库构建的一个嵌套列表操作库，主要用于对元素不是基本数据类型的列表进行排序、删除等操作，里面的大多函数使用了operator库，可以简化项目代码编写量。</p>\n<h2 id=\"使用与示例\"><a href=\"#使用与示例\" class=\"headerlink\" title=\"使用与示例\"></a><a href=\"#使用与示例\">使用与示例</a></h2><p>Nested-List可以使用pip进行安装：<code>pip install Nested-List</code></p>\n<p>Nested-List-1.0.x有4个可用函数，分别是排序、删除元素、最大值和最小值，Nested-List会自动判断传入的列表的元素是什么类型，并调用相应的处理函数，无论进行哪些操作，都要保证列表里的元素是同一类型，这是这个库的工作基础。</p>\n<pre><code class=\"Python\">def sort(nl, *key, order=False):\n    ...\n\ndef delete_items(dl, keys, values, compare=None):\n    ...\n\ndef max(nl, *keys):\n    ...\n\ndef min(nl, *keys):\n    ...</code></pre>\n<p>每个函数使用时都需要传入需要操作的列表。</p>\n<h3 id=\"排序\"><a href=\"#排序\" class=\"headerlink\" title=\"排序\"></a><a href=\"#排序\">排序</a></h3><p>排序可根据列表中元素的属性来对元素进行排序，排序顺序默认是升序，当order字段设置为True或者”DESC”时，将会降序排序，当传入值不符合规定时将会按照默认排序处理，有一个注意点是如果要设置order的值，要在全部参数传入完成后再传入order的值。</p>\n<pre><code class=\"Python\">import nested_list as ntls\n\ndict_list = [\n    {&#39;name&#39;:&#39;one&#39;, &#39;age&#39;:11},\n    {&#39;name&#39;:&#39;two&#39;, &#39;age&#39;:5},\n    {&#39;name&#39;:&#39;three&#39;,&#39;age&#39;:26},\n    {&#39;name&#39;:&#39;four&#39;,&#39;age&#39;:19}\n]\n\nntls.sort(dict_list,&#39;age&#39;,order=False)\nprint(dict_list)\n\n# 排序完的输出将会是[{&#39;name&#39;: &#39;two&#39;, &#39;age&#39;: 5}, {&#39;name&#39;: &#39;one&#39;, &#39;age&#39;: 11}, {&#39;name&#39;: &#39;four&#39;, &#39;age&#39;: 19}, {&#39;name&#39;: &#39;three&#39;, &#39;age&#39;: 26}]</code></pre>\n<p>当然列表里的元素也可以是对象，但是你要确保你的对象都是同一类型的对象，并可以指定可排序属性</p>\n<pre><code class=\"Python\">class User:\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n    def __repr__(self):\n        return &#39;User({})&#39;.format(self.age)\n\nuser_list = [\n    User(&#39;one&#39;,18),\n    User(&#39;two&#39;,9),\n    User(&#39;three&#39;,7),\n    User(&#39;four&#39;,15)\n]\n\nntls.sort(user_list, &#39;age&#39;)\nprint(user_list)\n\n# 排序完的输出将会是[User(7), User(9), User(15), User(18)]，如果你不重写__repr__，那么将会打印的列表里将会是对象信息，你将看不到排序效果</code></pre>\n<p>你可以传入多个参数来进行多次排序，如下</p>\n<pre><code class=\"Python\">ntls.sort(user_list, &#39;id&#39;, &#39;age&#39;,order=&quot;DESC&quot;)</code></pre>\n<p>此时sort函数将会先根据id进行降序排序，排序完再根据age排序一次</p>\n<h3 id=\"删除元素\"><a href=\"#删除元素\" class=\"headerlink\" title=\"删除元素\"></a><a href=\"#删除元素\">删除元素</a></h3><p>delete_items可根据列表的中元素的属性值来删除元素，同样的，delete_items处理的列表元素类型也可以是对象，但使用delete_items的时候传入参数有两个个注意点：</p>\n<p>1、无论要根据的属性有多少个，传入时只能存为一个可迭代对象传入，在Python里，虽然字符串可以被迭代，传入字符串也不会报错，但会得出错误的执行结果，所以建议传入一个tuple或者list</p>\n<p>2、当传入属性值只有一个时，传入的判断值不需要存入可迭代对象，直接传入即可，否则会出现错误的执行结果；当传入属性值有多个时，传入的判断值<strong>只能</strong>存为tuple对象传入</p>\n<p><strong>以下是例子：</strong></p>\n<pre><code class=\"Python\"># 单个属性时正确的使用方式\nntls.delete_items(user_list, [&#39;age&#39;], 7)\n# 或者可以这样\nntls.delete_items(user_list, (&#39;age&#39;), 7)\n\n# 单个属性时错误的使用方式\nntls.delete_items(user_list, [&#39;age&#39;], (7))\nntls.delete_items(user_list, &#39;age&#39;, 7)\n\n# 传入多个属性时正确的使用方式\nntls.delete_items(user_list, None, [&#39;age&#39;,&#39;name&#39;],(7,&#39;four&#39;))\n\n# 传入多个属性时错误的使用方式\nntls.delete_items(user_list, None, [&#39;age&#39;,&#39;name&#39;],7,&#39;four&#39;)\nntls.delete_items(user_list, None, [&#39;age&#39;,&#39;name&#39;],[7,&#39;four&#39;])</code></pre>\n<h3 id=\"最大值与最小值\"><a href=\"#最大值与最小值\" class=\"headerlink\" title=\"最大值与最小值\"></a><a href=\"#最大值与最小值\">最大值与最小值</a></h3><p>如果要根据元素中某个属性来找出最值，可以调用max传入key来处理，Nested-List底层也是这么使用，对于Nested-List来说，只是引入了operator的attrgetter和itemgetter来传入key并进行了简单的包装，Nested-List的max和min也是返回了Python内置的max和min函数的工作结果。</p>\n<p>对于Nested-List的max和min的使用方法如下</p>\n<pre><code class=\"Python\">ntls.max(user_list, &quot;age&quot;)</code></pre>\n<p>当有多个判断属性时，可直接传入多个属性名称</p>\n<pre><code class=\"Python\">ntls.max(user_list, &quot;age&quot;, &quot;id&quot;)</code></pre>\n<h2 id=\"致谢\"><a href=\"#致谢\" class=\"headerlink\" title=\"致谢\"></a><a href=\"#致谢\">致谢</a></h2><p>感谢《Python Cookbook》3rd Edition的作者和翻译者，本项目的开发离不开Python Cookbook 3rd Edition Documentation里面的内容带给我的帮助和启发。</p>\n<p>Nested-List起初的开发是针对项目中对列表中字典的排序，但随后的开发中在《Python Cookbook》3rd Edition的翻译文档中学习到了更加方便且有效率的方法，按照其中的思路将功能打包在一起供给其它人使用，同时Nested-List变得不再只能对列表中的字典进行操作，也可以对列表或者其他对象使用。</p>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a><a href=\"#链接\">链接</a></h2><p><strong>Nested-List GitHub仓库主页：</strong><a href=\"https://github.com/arukione/Nested-List\" target=\"_blank\" rel=\"noopener\">https://github.com/arukione/Nested-List</a></p>\n<p><strong>Python Cookbook 3rd Edition Documentation：</strong><a href=\"https://python3-cookbook.readthedocs.io/zh_CN/latest/index.html\" target=\"_blank\" rel=\"noopener\">https://python3-cookbook.readthedocs.io/zh_CN/latest/index.html</a></p>\n<p><a href=\"https://www.arukione.com/2020/01/30/%E9%97%B2%E7%9D%80%E6%B2%A1%E4%BA%8B%E9%80%A0%E8%BD%AE%E5%AD%90/\" target=\"_blank\" rel=\"noopener\">闲着没事造轮子</a></p>\n"},{"title":"数据结构基础","date":"2019-09-10T16:00:00.000Z","_content":"\n## 基本概念和术语\n\n**数据(Data)：**客观事物的符号表示，是所有能输入到计算机中并被计算机程序处理的符号的总称\n\n**数据元素(Data Element)：**数据的基本单位，在计算机中通常作为一个整体进行考虑和处理\n\n**数据项(Data Item)：**组成数据元素的、有独立含义的、不可分割的最小单位\n\n**数据对象(Data Object)：**是性质相同的数据元素的集合，是数据的一个子集\n\n数据是什么？如何理解数据对象？什么是性质相同的数据元素的集合？\n数据对象相当于数据的一部分内容，而这部分内容里面的元素都有相同的特点，举个例子：\n\n```text\n数据                                            一个班级里面的学生\n数据对象                                        一个班里学生的信息表\n数据元素                                        学生信息表的每一条数据都是数据元素\n数据项                                          学生信息表里面的每一项信息\n```\n\n这里面，学生的信息表是学生的一个部分内容，学生可以包含很多内容，除了信息表，还有成绩单，身份内容，这些都算是学生这个数据的一部分，也就是数据的子集，即数据对象。而学生信息表里面会含有很多个信息项，例如姓名学号、专业、性别等等，这些信息项就是数据项，有着独立的含义。信息表里面的每一个学生的数据，都算是一个数据元素，这些学生的数据构和数据项构造成了信息表，所以数据对象是数据元素的集合。\n\n## **数据结构**\n\n**数据结构(Data Stucture)：是相互之间存在一种或多种特定关系的数据元素的集合。**\n数据结构其实就是带有“结构”的数据元素的集合。不过说是数据元素的集合，我们平时的理解更多的是倾向于结构，学得主要也是结构，但这个名词本身指的还是集合！\n数据结构包括逻辑结构和储存结构两个层次。\n\n### **逻辑结构**\n\n**逻辑结构是对于数据来讲的，从逻辑关系上描述数据，和数据的储存无关，独立于计算机。**\n**数据的逻辑结构分为：线性结构和非线性结构。**\n\n四类基本逻辑结构：\n\n**集合结构：**数据元素除了属于同一集合外，没有其他关系\n**线性结构：**数据元素之间存在一对一的关系\n**树结构：**数据元素之间存在一对多的关系\n**图结构或网状结构：**数据元素之间存在多对多的关系\n\n下面图示，会更容易理解\n\n![数据的逻辑结构层次图](/images/数据结构基础/数据逻辑结构层次图.jpg)\n\n### **储存结构**\n\n**储存结构也称为物理结构，指的是数据对象在计算机中的存储方式。**\n通常要求数据对象在存入计算机时既要存储数据元素的数据，也要存储数据元素之间的逻辑关系，数据元素在计算机内用一个结点来表示。\n\n数据元素在计算机中的两种基本储存结构：\n\n**顺序存储结构：**借助元素在存储器中的相对位置来表示数据元素之间的逻辑关系，要求所有的元素依次存放在一片连续的存储空间中\n\n**链式存储结构：**无需占用一整块存储空间，为了表示结点之间的关系，给每个结点附加指针字段，用于存放后继元素的存储地址。\n\n```Text\n课外补充：\n逻辑结构与数据元素本身的形式、内容、相对位置、个数无关。\n一些表面上很不相同的数据可以有相同的逻辑结构\n通常要求同一逻辑结构中的所有数据元素具有相同的特性，这意味着不仅数据元素所包含的数据项的个数要相同，而且对应数据项的类型要一致\n```\n\n## **算法和算法分析**\n\n**算法：**是为了解决某类问题而规定的一个有限长的操作序列\n一个算法必须满足的五个重要特征：**有穷性、确定性、可行性、输入、输出**。\n\n一个算法的优劣评价的方面：**正确性、可读性、健壮性、高效性**。\n高效性包括时间和空间两个方面：\n时间高效是指算法设计合理，执行效率高，可以用**时间复杂度**来度量\n空间高效是指算法占用存储容量合理，可以用**空间复杂度**来度量\n**时间复杂度和空间复杂度是衡量算法的两个主要指标。**\n\n衡量算法效率的方法主要有两种：事后统计法和事前分析估算法。\n通常采用事前分析估算法，通过计算算法的渐进复杂度来衡量算法的效率。\n\n### 渐进时间复杂度\n\n**一般情况下对于算法中基本语句的执行的是问题规模n的某个函数f(n)，我们用\"O\"来表示数量级，算法的时间量度记作**\n**T(n) = O(f(n))**\n**它表示随问题规模n的增大，算法执行时间的增长率和 f(n) 的增长率相同，称做算法的渐渐时间复杂度，简称时间复杂度(Time Complexity).**\n\n**问题规模：**问题规模是算法求解问题输入量的多少，是问题大小的本质表示，一般用整数n表示\n**语句频度：**一条语句的重复执行次数\n\n「 以下代码来自书中 」\n\n**一个算法的执行时间大致上等于所有语句执行时间的总和，而语句的执行时间则为该条语句的财富执行次数和执行一次所需时间的乘积。**\n\n```C\n两个n阶矩阵的乘积算法\n设每条语句执行一次所需时间均为单位时间，n为执行规模\n\nfor(i=1; i<=n; i++)                                                     //频度为 n+1\n    for(j=1; j<=n; j++){                                                //频度为 n*(n+1)\n        c[i][j] = 0;                                                    //频度为 n^2\n        for(k=1; k<=n; k++)                                             //频度为 n^2 * (n+1)\n        c[i][j] = c[i][j] + a[i][k] * b[k][j];                          //频度为 n^3\n    }\n\n该算法中所有语句频度的和 f(n) = 2n^3 + 3n^2 + 2n + 1\n```\n\n**为了客观反映一个算法的执行时间，可以通过算法中“基本语句”(重复执行次数和算法的执行时间成正比的语句，它对算法运行时间的贡献最大) 执行次数来度量算法的工作量。**\n**通常，算法的执行时间随问题规模增长而增长，因此对算法的评价只需考虑其随问题规模增长的趋势。**\n\n```Markdown\n上面那个例子,当执行规模n趋向无穷大时\nf(n) / n^3  的极限等于2\n也就是当n充分大时，f(n) 和 n^3 的比是一个不等于0的常数\n即 f(n) 和 n^3 同阶(数量级Order of Magnitude相同)\n时间复杂度T(n) = O(f(n)) = O(n^3)\n```\n\n```Text\n关于常量阶\n当语句频度为1时，算法执行时间是一个与问题规模n无关的常数，即T(n) = O(1)，称为常量阶。\n只要算法执行时间不随问题规模n增长而增长，算法中语句的频度就是某个常数，无论这个常数多大，算法的时间复杂度都是O(1)。\n例如：for(i=0;i<10000;i++){x++;s=0;}\n\n\n关于线性阶\n循环体内两条基本语句的频度均为 f(n)=n，算法的时间复杂度为 T(n) = O(n)，称为线性阶。\n当算法的基本语句频度最大为 n^2 时，T(n) = O(n^2)， 则为平方阶；\n同样，当频度最大为 n^3 时，则为立方阶。\n\n\n对数阶示例\n\ni = 1;\nwhile (i <= n)\n    i = i*3;\n\n设循环体里面的基本语句的频度为 f(n)\n也就是执行了 f(n) 次 i*3\n所以执行完 i的值为 3^f(n)\n由于 i<=n，所以 3^f(n) <= n\n可得到 f(n) <= log_3 n\n所以这个程序的时间复杂度为f(log3 n)\n\n\n最好、最坏、平均时间复杂度\n对于某些问题，算法的基本语句的频度不仅仅和问题的规模有关，还依赖于其他因素，例如：未知的输入值、随机的初始化等等。\n这些问题的算法，在计算时间复杂度的时候需要考虑各种情况。\n称算法在最好情况下的时间复杂度为最好时间复杂度；最坏情况下算法的时间复杂度为最坏时间复杂度，分别指的是算法计算量可能达到的最小值和最大值。\n算法的平均时间复杂度是指算法在所有情况下，按照输入实例以等概率出现时，算法计算量的加权平均值。\n一般来说，人们更关心的是平均情况下和最坏情况下的时间复杂度，但是算法的平均时间复杂度难以确定。\n```\n\n### 渐进空间复杂度\n\n**和时间复杂度类似，渐进空间复杂度(Space Complexity)作为算法所需存储空间的量度，它也是问题规模n的函数，记作S(n) = O(f(n))**\n在分析时，输入数据所占的具体存储量取决于问题，和算法无关，所以秩序分析该算法在实现是所需要的辅助空间就行了。\n若算法实现时所需的辅助存储空间相对于输入数据量而言是个常数，与问题本身无关，则称这个算法为原地工作，辅助空间为O(1)。\n\n```C\n示例：\n\nfor(i=0;i<n/2;i++){\n    t = a[i];\n    a[i] = a[n-i-1];\n    a[n-i-1] = t;\n}\n\n由于算法只需借助一个变量t，与问题规模n的大小无关，所以其空间复杂度为O(1)\n\n\nfor(i=0;i<n;i++)\n    b[i] = a[n-i-1];\nfor(i=0;i<n/2;i++)\n    a[i] = b[i];\n\n算法需要借助一个大小为n的辅助数组b，所以其空间复杂度为O(n)\n```\n\n>参考：人民邮电出版社《数据结构    C语言版|第二版》严蔚敏\n","source":"_posts/数据结构基础.md","raw":"---\ntitle: 数据结构基础\ndate: 2019-9-11\ncategories: 学习笔记\n---\n\n## 基本概念和术语\n\n**数据(Data)：**客观事物的符号表示，是所有能输入到计算机中并被计算机程序处理的符号的总称\n\n**数据元素(Data Element)：**数据的基本单位，在计算机中通常作为一个整体进行考虑和处理\n\n**数据项(Data Item)：**组成数据元素的、有独立含义的、不可分割的最小单位\n\n**数据对象(Data Object)：**是性质相同的数据元素的集合，是数据的一个子集\n\n数据是什么？如何理解数据对象？什么是性质相同的数据元素的集合？\n数据对象相当于数据的一部分内容，而这部分内容里面的元素都有相同的特点，举个例子：\n\n```text\n数据                                            一个班级里面的学生\n数据对象                                        一个班里学生的信息表\n数据元素                                        学生信息表的每一条数据都是数据元素\n数据项                                          学生信息表里面的每一项信息\n```\n\n这里面，学生的信息表是学生的一个部分内容，学生可以包含很多内容，除了信息表，还有成绩单，身份内容，这些都算是学生这个数据的一部分，也就是数据的子集，即数据对象。而学生信息表里面会含有很多个信息项，例如姓名学号、专业、性别等等，这些信息项就是数据项，有着独立的含义。信息表里面的每一个学生的数据，都算是一个数据元素，这些学生的数据构和数据项构造成了信息表，所以数据对象是数据元素的集合。\n\n## **数据结构**\n\n**数据结构(Data Stucture)：是相互之间存在一种或多种特定关系的数据元素的集合。**\n数据结构其实就是带有“结构”的数据元素的集合。不过说是数据元素的集合，我们平时的理解更多的是倾向于结构，学得主要也是结构，但这个名词本身指的还是集合！\n数据结构包括逻辑结构和储存结构两个层次。\n\n### **逻辑结构**\n\n**逻辑结构是对于数据来讲的，从逻辑关系上描述数据，和数据的储存无关，独立于计算机。**\n**数据的逻辑结构分为：线性结构和非线性结构。**\n\n四类基本逻辑结构：\n\n**集合结构：**数据元素除了属于同一集合外，没有其他关系\n**线性结构：**数据元素之间存在一对一的关系\n**树结构：**数据元素之间存在一对多的关系\n**图结构或网状结构：**数据元素之间存在多对多的关系\n\n下面图示，会更容易理解\n\n![数据的逻辑结构层次图](/images/数据结构基础/数据逻辑结构层次图.jpg)\n\n### **储存结构**\n\n**储存结构也称为物理结构，指的是数据对象在计算机中的存储方式。**\n通常要求数据对象在存入计算机时既要存储数据元素的数据，也要存储数据元素之间的逻辑关系，数据元素在计算机内用一个结点来表示。\n\n数据元素在计算机中的两种基本储存结构：\n\n**顺序存储结构：**借助元素在存储器中的相对位置来表示数据元素之间的逻辑关系，要求所有的元素依次存放在一片连续的存储空间中\n\n**链式存储结构：**无需占用一整块存储空间，为了表示结点之间的关系，给每个结点附加指针字段，用于存放后继元素的存储地址。\n\n```Text\n课外补充：\n逻辑结构与数据元素本身的形式、内容、相对位置、个数无关。\n一些表面上很不相同的数据可以有相同的逻辑结构\n通常要求同一逻辑结构中的所有数据元素具有相同的特性，这意味着不仅数据元素所包含的数据项的个数要相同，而且对应数据项的类型要一致\n```\n\n## **算法和算法分析**\n\n**算法：**是为了解决某类问题而规定的一个有限长的操作序列\n一个算法必须满足的五个重要特征：**有穷性、确定性、可行性、输入、输出**。\n\n一个算法的优劣评价的方面：**正确性、可读性、健壮性、高效性**。\n高效性包括时间和空间两个方面：\n时间高效是指算法设计合理，执行效率高，可以用**时间复杂度**来度量\n空间高效是指算法占用存储容量合理，可以用**空间复杂度**来度量\n**时间复杂度和空间复杂度是衡量算法的两个主要指标。**\n\n衡量算法效率的方法主要有两种：事后统计法和事前分析估算法。\n通常采用事前分析估算法，通过计算算法的渐进复杂度来衡量算法的效率。\n\n### 渐进时间复杂度\n\n**一般情况下对于算法中基本语句的执行的是问题规模n的某个函数f(n)，我们用\"O\"来表示数量级，算法的时间量度记作**\n**T(n) = O(f(n))**\n**它表示随问题规模n的增大，算法执行时间的增长率和 f(n) 的增长率相同，称做算法的渐渐时间复杂度，简称时间复杂度(Time Complexity).**\n\n**问题规模：**问题规模是算法求解问题输入量的多少，是问题大小的本质表示，一般用整数n表示\n**语句频度：**一条语句的重复执行次数\n\n「 以下代码来自书中 」\n\n**一个算法的执行时间大致上等于所有语句执行时间的总和，而语句的执行时间则为该条语句的财富执行次数和执行一次所需时间的乘积。**\n\n```C\n两个n阶矩阵的乘积算法\n设每条语句执行一次所需时间均为单位时间，n为执行规模\n\nfor(i=1; i<=n; i++)                                                     //频度为 n+1\n    for(j=1; j<=n; j++){                                                //频度为 n*(n+1)\n        c[i][j] = 0;                                                    //频度为 n^2\n        for(k=1; k<=n; k++)                                             //频度为 n^2 * (n+1)\n        c[i][j] = c[i][j] + a[i][k] * b[k][j];                          //频度为 n^3\n    }\n\n该算法中所有语句频度的和 f(n) = 2n^3 + 3n^2 + 2n + 1\n```\n\n**为了客观反映一个算法的执行时间，可以通过算法中“基本语句”(重复执行次数和算法的执行时间成正比的语句，它对算法运行时间的贡献最大) 执行次数来度量算法的工作量。**\n**通常，算法的执行时间随问题规模增长而增长，因此对算法的评价只需考虑其随问题规模增长的趋势。**\n\n```Markdown\n上面那个例子,当执行规模n趋向无穷大时\nf(n) / n^3  的极限等于2\n也就是当n充分大时，f(n) 和 n^3 的比是一个不等于0的常数\n即 f(n) 和 n^3 同阶(数量级Order of Magnitude相同)\n时间复杂度T(n) = O(f(n)) = O(n^3)\n```\n\n```Text\n关于常量阶\n当语句频度为1时，算法执行时间是一个与问题规模n无关的常数，即T(n) = O(1)，称为常量阶。\n只要算法执行时间不随问题规模n增长而增长，算法中语句的频度就是某个常数，无论这个常数多大，算法的时间复杂度都是O(1)。\n例如：for(i=0;i<10000;i++){x++;s=0;}\n\n\n关于线性阶\n循环体内两条基本语句的频度均为 f(n)=n，算法的时间复杂度为 T(n) = O(n)，称为线性阶。\n当算法的基本语句频度最大为 n^2 时，T(n) = O(n^2)， 则为平方阶；\n同样，当频度最大为 n^3 时，则为立方阶。\n\n\n对数阶示例\n\ni = 1;\nwhile (i <= n)\n    i = i*3;\n\n设循环体里面的基本语句的频度为 f(n)\n也就是执行了 f(n) 次 i*3\n所以执行完 i的值为 3^f(n)\n由于 i<=n，所以 3^f(n) <= n\n可得到 f(n) <= log_3 n\n所以这个程序的时间复杂度为f(log3 n)\n\n\n最好、最坏、平均时间复杂度\n对于某些问题，算法的基本语句的频度不仅仅和问题的规模有关，还依赖于其他因素，例如：未知的输入值、随机的初始化等等。\n这些问题的算法，在计算时间复杂度的时候需要考虑各种情况。\n称算法在最好情况下的时间复杂度为最好时间复杂度；最坏情况下算法的时间复杂度为最坏时间复杂度，分别指的是算法计算量可能达到的最小值和最大值。\n算法的平均时间复杂度是指算法在所有情况下，按照输入实例以等概率出现时，算法计算量的加权平均值。\n一般来说，人们更关心的是平均情况下和最坏情况下的时间复杂度，但是算法的平均时间复杂度难以确定。\n```\n\n### 渐进空间复杂度\n\n**和时间复杂度类似，渐进空间复杂度(Space Complexity)作为算法所需存储空间的量度，它也是问题规模n的函数，记作S(n) = O(f(n))**\n在分析时，输入数据所占的具体存储量取决于问题，和算法无关，所以秩序分析该算法在实现是所需要的辅助空间就行了。\n若算法实现时所需的辅助存储空间相对于输入数据量而言是个常数，与问题本身无关，则称这个算法为原地工作，辅助空间为O(1)。\n\n```C\n示例：\n\nfor(i=0;i<n/2;i++){\n    t = a[i];\n    a[i] = a[n-i-1];\n    a[n-i-1] = t;\n}\n\n由于算法只需借助一个变量t，与问题规模n的大小无关，所以其空间复杂度为O(1)\n\n\nfor(i=0;i<n;i++)\n    b[i] = a[n-i-1];\nfor(i=0;i<n/2;i++)\n    a[i] = b[i];\n\n算法需要借助一个大小为n的辅助数组b，所以其空间复杂度为O(n)\n```\n\n>参考：人民邮电出版社《数据结构    C语言版|第二版》严蔚敏\n","slug":"数据结构基础","published":1,"updated":"2020-02-23T09:05:46.211Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6ywriw1000o54v53mkg8h5o","content":"<h2 id=\"基本概念和术语\"><a href=\"#基本概念和术语\" class=\"headerlink\" title=\"基本概念和术语\"></a>基本概念和术语</h2><p><strong>数据(Data)：</strong>客观事物的符号表示，是所有能输入到计算机中并被计算机程序处理的符号的总称</p>\n<p><strong>数据元素(Data Element)：</strong>数据的基本单位，在计算机中通常作为一个整体进行考虑和处理</p>\n<p><strong>数据项(Data Item)：</strong>组成数据元素的、有独立含义的、不可分割的最小单位</p>\n<p><strong>数据对象(Data Object)：</strong>是性质相同的数据元素的集合，是数据的一个子集</p>\n<p>数据是什么？如何理解数据对象？什么是性质相同的数据元素的集合？<br>数据对象相当于数据的一部分内容，而这部分内容里面的元素都有相同的特点，举个例子：</p>\n<pre><code class=\"text\">数据                                            一个班级里面的学生\n数据对象                                        一个班里学生的信息表\n数据元素                                        学生信息表的每一条数据都是数据元素\n数据项                                          学生信息表里面的每一项信息</code></pre>\n<p>这里面，学生的信息表是学生的一个部分内容，学生可以包含很多内容，除了信息表，还有成绩单，身份内容，这些都算是学生这个数据的一部分，也就是数据的子集，即数据对象。而学生信息表里面会含有很多个信息项，例如姓名学号、专业、性别等等，这些信息项就是数据项，有着独立的含义。信息表里面的每一个学生的数据，都算是一个数据元素，这些学生的数据构和数据项构造成了信息表，所以数据对象是数据元素的集合。</p>\n<h2 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a><strong>数据结构</strong></h2><p><strong>数据结构(Data Stucture)：是相互之间存在一种或多种特定关系的数据元素的集合。</strong><br>数据结构其实就是带有“结构”的数据元素的集合。不过说是数据元素的集合，我们平时的理解更多的是倾向于结构，学得主要也是结构，但这个名词本身指的还是集合！<br>数据结构包括逻辑结构和储存结构两个层次。</p>\n<h3 id=\"逻辑结构\"><a href=\"#逻辑结构\" class=\"headerlink\" title=\"逻辑结构\"></a><strong>逻辑结构</strong></h3><p><strong>逻辑结构是对于数据来讲的，从逻辑关系上描述数据，和数据的储存无关，独立于计算机。</strong><br><strong>数据的逻辑结构分为：线性结构和非线性结构。</strong></p>\n<p>四类基本逻辑结构：</p>\n<p><strong>集合结构：</strong>数据元素除了属于同一集合外，没有其他关系<br><strong>线性结构：</strong>数据元素之间存在一对一的关系<br><strong>树结构：</strong>数据元素之间存在一对多的关系<br><strong>图结构或网状结构：</strong>数据元素之间存在多对多的关系</p>\n<p>下面图示，会更容易理解</p>\n<p><img src=\"/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84%E5%B1%82%E6%AC%A1%E5%9B%BE.jpg\" alt=\"数据的逻辑结构层次图\"></p>\n<h3 id=\"储存结构\"><a href=\"#储存结构\" class=\"headerlink\" title=\"储存结构\"></a><strong>储存结构</strong></h3><p><strong>储存结构也称为物理结构，指的是数据对象在计算机中的存储方式。</strong><br>通常要求数据对象在存入计算机时既要存储数据元素的数据，也要存储数据元素之间的逻辑关系，数据元素在计算机内用一个结点来表示。</p>\n<p>数据元素在计算机中的两种基本储存结构：</p>\n<p><strong>顺序存储结构：</strong>借助元素在存储器中的相对位置来表示数据元素之间的逻辑关系，要求所有的元素依次存放在一片连续的存储空间中</p>\n<p><strong>链式存储结构：</strong>无需占用一整块存储空间，为了表示结点之间的关系，给每个结点附加指针字段，用于存放后继元素的存储地址。</p>\n<pre><code class=\"Text\">课外补充：\n逻辑结构与数据元素本身的形式、内容、相对位置、个数无关。\n一些表面上很不相同的数据可以有相同的逻辑结构\n通常要求同一逻辑结构中的所有数据元素具有相同的特性，这意味着不仅数据元素所包含的数据项的个数要相同，而且对应数据项的类型要一致</code></pre>\n<h2 id=\"算法和算法分析\"><a href=\"#算法和算法分析\" class=\"headerlink\" title=\"算法和算法分析\"></a><strong>算法和算法分析</strong></h2><p><strong>算法：</strong>是为了解决某类问题而规定的一个有限长的操作序列<br>一个算法必须满足的五个重要特征：<strong>有穷性、确定性、可行性、输入、输出</strong>。</p>\n<p>一个算法的优劣评价的方面：<strong>正确性、可读性、健壮性、高效性</strong>。<br>高效性包括时间和空间两个方面：<br>时间高效是指算法设计合理，执行效率高，可以用<strong>时间复杂度</strong>来度量<br>空间高效是指算法占用存储容量合理，可以用<strong>空间复杂度</strong>来度量<br><strong>时间复杂度和空间复杂度是衡量算法的两个主要指标。</strong></p>\n<p>衡量算法效率的方法主要有两种：事后统计法和事前分析估算法。<br>通常采用事前分析估算法，通过计算算法的渐进复杂度来衡量算法的效率。</p>\n<h3 id=\"渐进时间复杂度\"><a href=\"#渐进时间复杂度\" class=\"headerlink\" title=\"渐进时间复杂度\"></a>渐进时间复杂度</h3><p><strong>一般情况下对于算法中基本语句的执行的是问题规模n的某个函数f(n)，我们用”O”来表示数量级，算法的时间量度记作</strong><br><strong>T(n) = O(f(n))</strong><br><strong>它表示随问题规模n的增大，算法执行时间的增长率和 f(n) 的增长率相同，称做算法的渐渐时间复杂度，简称时间复杂度(Time Complexity).</strong></p>\n<p><strong>问题规模：</strong>问题规模是算法求解问题输入量的多少，是问题大小的本质表示，一般用整数n表示<br><strong>语句频度：</strong>一条语句的重复执行次数</p>\n<p>「 以下代码来自书中 」</p>\n<p><strong>一个算法的执行时间大致上等于所有语句执行时间的总和，而语句的执行时间则为该条语句的财富执行次数和执行一次所需时间的乘积。</strong></p>\n<pre><code class=\"C\">两个n阶矩阵的乘积算法\n设每条语句执行一次所需时间均为单位时间，n为执行规模\n\nfor(i=1; i&lt;=n; i++)                                                     //频度为 n+1\n    for(j=1; j&lt;=n; j++){                                                //频度为 n*(n+1)\n        c[i][j] = 0;                                                    //频度为 n^2\n        for(k=1; k&lt;=n; k++)                                             //频度为 n^2 * (n+1)\n        c[i][j] = c[i][j] + a[i][k] * b[k][j];                          //频度为 n^3\n    }\n\n该算法中所有语句频度的和 f(n) = 2n^3 + 3n^2 + 2n + 1</code></pre>\n<p><strong>为了客观反映一个算法的执行时间，可以通过算法中“基本语句”(重复执行次数和算法的执行时间成正比的语句，它对算法运行时间的贡献最大) 执行次数来度量算法的工作量。</strong><br><strong>通常，算法的执行时间随问题规模增长而增长，因此对算法的评价只需考虑其随问题规模增长的趋势。</strong></p>\n<pre><code class=\"Markdown\">上面那个例子,当执行规模n趋向无穷大时\nf(n) / n^3  的极限等于2\n也就是当n充分大时，f(n) 和 n^3 的比是一个不等于0的常数\n即 f(n) 和 n^3 同阶(数量级Order of Magnitude相同)\n时间复杂度T(n) = O(f(n)) = O(n^3)</code></pre>\n<pre><code class=\"Text\">关于常量阶\n当语句频度为1时，算法执行时间是一个与问题规模n无关的常数，即T(n) = O(1)，称为常量阶。\n只要算法执行时间不随问题规模n增长而增长，算法中语句的频度就是某个常数，无论这个常数多大，算法的时间复杂度都是O(1)。\n例如：for(i=0;i&lt;10000;i++){x++;s=0;}\n\n\n关于线性阶\n循环体内两条基本语句的频度均为 f(n)=n，算法的时间复杂度为 T(n) = O(n)，称为线性阶。\n当算法的基本语句频度最大为 n^2 时，T(n) = O(n^2)， 则为平方阶；\n同样，当频度最大为 n^3 时，则为立方阶。\n\n\n对数阶示例\n\ni = 1;\nwhile (i &lt;= n)\n    i = i*3;\n\n设循环体里面的基本语句的频度为 f(n)\n也就是执行了 f(n) 次 i*3\n所以执行完 i的值为 3^f(n)\n由于 i&lt;=n，所以 3^f(n) &lt;= n\n可得到 f(n) &lt;= log_3 n\n所以这个程序的时间复杂度为f(log3 n)\n\n\n最好、最坏、平均时间复杂度\n对于某些问题，算法的基本语句的频度不仅仅和问题的规模有关，还依赖于其他因素，例如：未知的输入值、随机的初始化等等。\n这些问题的算法，在计算时间复杂度的时候需要考虑各种情况。\n称算法在最好情况下的时间复杂度为最好时间复杂度；最坏情况下算法的时间复杂度为最坏时间复杂度，分别指的是算法计算量可能达到的最小值和最大值。\n算法的平均时间复杂度是指算法在所有情况下，按照输入实例以等概率出现时，算法计算量的加权平均值。\n一般来说，人们更关心的是平均情况下和最坏情况下的时间复杂度，但是算法的平均时间复杂度难以确定。</code></pre>\n<h3 id=\"渐进空间复杂度\"><a href=\"#渐进空间复杂度\" class=\"headerlink\" title=\"渐进空间复杂度\"></a>渐进空间复杂度</h3><p><strong>和时间复杂度类似，渐进空间复杂度(Space Complexity)作为算法所需存储空间的量度，它也是问题规模n的函数，记作S(n) = O(f(n))</strong><br>在分析时，输入数据所占的具体存储量取决于问题，和算法无关，所以秩序分析该算法在实现是所需要的辅助空间就行了。<br>若算法实现时所需的辅助存储空间相对于输入数据量而言是个常数，与问题本身无关，则称这个算法为原地工作，辅助空间为O(1)。</p>\n<pre><code class=\"C\">示例：\n\nfor(i=0;i&lt;n/2;i++){\n    t = a[i];\n    a[i] = a[n-i-1];\n    a[n-i-1] = t;\n}\n\n由于算法只需借助一个变量t，与问题规模n的大小无关，所以其空间复杂度为O(1)\n\n\nfor(i=0;i&lt;n;i++)\n    b[i] = a[n-i-1];\nfor(i=0;i&lt;n/2;i++)\n    a[i] = b[i];\n\n算法需要借助一个大小为n的辅助数组b，所以其空间复杂度为O(n)</code></pre>\n<blockquote>\n<p>参考：人民邮电出版社《数据结构    C语言版|第二版》严蔚敏</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"基本概念和术语\"><a href=\"#基本概念和术语\" class=\"headerlink\" title=\"基本概念和术语\"></a>基本概念和术语</h2><p><strong>数据(Data)：</strong>客观事物的符号表示，是所有能输入到计算机中并被计算机程序处理的符号的总称</p>\n<p><strong>数据元素(Data Element)：</strong>数据的基本单位，在计算机中通常作为一个整体进行考虑和处理</p>\n<p><strong>数据项(Data Item)：</strong>组成数据元素的、有独立含义的、不可分割的最小单位</p>\n<p><strong>数据对象(Data Object)：</strong>是性质相同的数据元素的集合，是数据的一个子集</p>\n<p>数据是什么？如何理解数据对象？什么是性质相同的数据元素的集合？<br>数据对象相当于数据的一部分内容，而这部分内容里面的元素都有相同的特点，举个例子：</p>\n<pre><code class=\"text\">数据                                            一个班级里面的学生\n数据对象                                        一个班里学生的信息表\n数据元素                                        学生信息表的每一条数据都是数据元素\n数据项                                          学生信息表里面的每一项信息</code></pre>\n<p>这里面，学生的信息表是学生的一个部分内容，学生可以包含很多内容，除了信息表，还有成绩单，身份内容，这些都算是学生这个数据的一部分，也就是数据的子集，即数据对象。而学生信息表里面会含有很多个信息项，例如姓名学号、专业、性别等等，这些信息项就是数据项，有着独立的含义。信息表里面的每一个学生的数据，都算是一个数据元素，这些学生的数据构和数据项构造成了信息表，所以数据对象是数据元素的集合。</p>\n<h2 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a><strong>数据结构</strong></h2><p><strong>数据结构(Data Stucture)：是相互之间存在一种或多种特定关系的数据元素的集合。</strong><br>数据结构其实就是带有“结构”的数据元素的集合。不过说是数据元素的集合，我们平时的理解更多的是倾向于结构，学得主要也是结构，但这个名词本身指的还是集合！<br>数据结构包括逻辑结构和储存结构两个层次。</p>\n<h3 id=\"逻辑结构\"><a href=\"#逻辑结构\" class=\"headerlink\" title=\"逻辑结构\"></a><strong>逻辑结构</strong></h3><p><strong>逻辑结构是对于数据来讲的，从逻辑关系上描述数据，和数据的储存无关，独立于计算机。</strong><br><strong>数据的逻辑结构分为：线性结构和非线性结构。</strong></p>\n<p>四类基本逻辑结构：</p>\n<p><strong>集合结构：</strong>数据元素除了属于同一集合外，没有其他关系<br><strong>线性结构：</strong>数据元素之间存在一对一的关系<br><strong>树结构：</strong>数据元素之间存在一对多的关系<br><strong>图结构或网状结构：</strong>数据元素之间存在多对多的关系</p>\n<p>下面图示，会更容易理解</p>\n<p><img src=\"/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84%E5%B1%82%E6%AC%A1%E5%9B%BE.jpg\" alt=\"数据的逻辑结构层次图\"></p>\n<h3 id=\"储存结构\"><a href=\"#储存结构\" class=\"headerlink\" title=\"储存结构\"></a><strong>储存结构</strong></h3><p><strong>储存结构也称为物理结构，指的是数据对象在计算机中的存储方式。</strong><br>通常要求数据对象在存入计算机时既要存储数据元素的数据，也要存储数据元素之间的逻辑关系，数据元素在计算机内用一个结点来表示。</p>\n<p>数据元素在计算机中的两种基本储存结构：</p>\n<p><strong>顺序存储结构：</strong>借助元素在存储器中的相对位置来表示数据元素之间的逻辑关系，要求所有的元素依次存放在一片连续的存储空间中</p>\n<p><strong>链式存储结构：</strong>无需占用一整块存储空间，为了表示结点之间的关系，给每个结点附加指针字段，用于存放后继元素的存储地址。</p>\n<pre><code class=\"Text\">课外补充：\n逻辑结构与数据元素本身的形式、内容、相对位置、个数无关。\n一些表面上很不相同的数据可以有相同的逻辑结构\n通常要求同一逻辑结构中的所有数据元素具有相同的特性，这意味着不仅数据元素所包含的数据项的个数要相同，而且对应数据项的类型要一致</code></pre>\n<h2 id=\"算法和算法分析\"><a href=\"#算法和算法分析\" class=\"headerlink\" title=\"算法和算法分析\"></a><strong>算法和算法分析</strong></h2><p><strong>算法：</strong>是为了解决某类问题而规定的一个有限长的操作序列<br>一个算法必须满足的五个重要特征：<strong>有穷性、确定性、可行性、输入、输出</strong>。</p>\n<p>一个算法的优劣评价的方面：<strong>正确性、可读性、健壮性、高效性</strong>。<br>高效性包括时间和空间两个方面：<br>时间高效是指算法设计合理，执行效率高，可以用<strong>时间复杂度</strong>来度量<br>空间高效是指算法占用存储容量合理，可以用<strong>空间复杂度</strong>来度量<br><strong>时间复杂度和空间复杂度是衡量算法的两个主要指标。</strong></p>\n<p>衡量算法效率的方法主要有两种：事后统计法和事前分析估算法。<br>通常采用事前分析估算法，通过计算算法的渐进复杂度来衡量算法的效率。</p>\n<h3 id=\"渐进时间复杂度\"><a href=\"#渐进时间复杂度\" class=\"headerlink\" title=\"渐进时间复杂度\"></a>渐进时间复杂度</h3><p><strong>一般情况下对于算法中基本语句的执行的是问题规模n的某个函数f(n)，我们用”O”来表示数量级，算法的时间量度记作</strong><br><strong>T(n) = O(f(n))</strong><br><strong>它表示随问题规模n的增大，算法执行时间的增长率和 f(n) 的增长率相同，称做算法的渐渐时间复杂度，简称时间复杂度(Time Complexity).</strong></p>\n<p><strong>问题规模：</strong>问题规模是算法求解问题输入量的多少，是问题大小的本质表示，一般用整数n表示<br><strong>语句频度：</strong>一条语句的重复执行次数</p>\n<p>「 以下代码来自书中 」</p>\n<p><strong>一个算法的执行时间大致上等于所有语句执行时间的总和，而语句的执行时间则为该条语句的财富执行次数和执行一次所需时间的乘积。</strong></p>\n<pre><code class=\"C\">两个n阶矩阵的乘积算法\n设每条语句执行一次所需时间均为单位时间，n为执行规模\n\nfor(i=1; i&lt;=n; i++)                                                     //频度为 n+1\n    for(j=1; j&lt;=n; j++){                                                //频度为 n*(n+1)\n        c[i][j] = 0;                                                    //频度为 n^2\n        for(k=1; k&lt;=n; k++)                                             //频度为 n^2 * (n+1)\n        c[i][j] = c[i][j] + a[i][k] * b[k][j];                          //频度为 n^3\n    }\n\n该算法中所有语句频度的和 f(n) = 2n^3 + 3n^2 + 2n + 1</code></pre>\n<p><strong>为了客观反映一个算法的执行时间，可以通过算法中“基本语句”(重复执行次数和算法的执行时间成正比的语句，它对算法运行时间的贡献最大) 执行次数来度量算法的工作量。</strong><br><strong>通常，算法的执行时间随问题规模增长而增长，因此对算法的评价只需考虑其随问题规模增长的趋势。</strong></p>\n<pre><code class=\"Markdown\">上面那个例子,当执行规模n趋向无穷大时\nf(n) / n^3  的极限等于2\n也就是当n充分大时，f(n) 和 n^3 的比是一个不等于0的常数\n即 f(n) 和 n^3 同阶(数量级Order of Magnitude相同)\n时间复杂度T(n) = O(f(n)) = O(n^3)</code></pre>\n<pre><code class=\"Text\">关于常量阶\n当语句频度为1时，算法执行时间是一个与问题规模n无关的常数，即T(n) = O(1)，称为常量阶。\n只要算法执行时间不随问题规模n增长而增长，算法中语句的频度就是某个常数，无论这个常数多大，算法的时间复杂度都是O(1)。\n例如：for(i=0;i&lt;10000;i++){x++;s=0;}\n\n\n关于线性阶\n循环体内两条基本语句的频度均为 f(n)=n，算法的时间复杂度为 T(n) = O(n)，称为线性阶。\n当算法的基本语句频度最大为 n^2 时，T(n) = O(n^2)， 则为平方阶；\n同样，当频度最大为 n^3 时，则为立方阶。\n\n\n对数阶示例\n\ni = 1;\nwhile (i &lt;= n)\n    i = i*3;\n\n设循环体里面的基本语句的频度为 f(n)\n也就是执行了 f(n) 次 i*3\n所以执行完 i的值为 3^f(n)\n由于 i&lt;=n，所以 3^f(n) &lt;= n\n可得到 f(n) &lt;= log_3 n\n所以这个程序的时间复杂度为f(log3 n)\n\n\n最好、最坏、平均时间复杂度\n对于某些问题，算法的基本语句的频度不仅仅和问题的规模有关，还依赖于其他因素，例如：未知的输入值、随机的初始化等等。\n这些问题的算法，在计算时间复杂度的时候需要考虑各种情况。\n称算法在最好情况下的时间复杂度为最好时间复杂度；最坏情况下算法的时间复杂度为最坏时间复杂度，分别指的是算法计算量可能达到的最小值和最大值。\n算法的平均时间复杂度是指算法在所有情况下，按照输入实例以等概率出现时，算法计算量的加权平均值。\n一般来说，人们更关心的是平均情况下和最坏情况下的时间复杂度，但是算法的平均时间复杂度难以确定。</code></pre>\n<h3 id=\"渐进空间复杂度\"><a href=\"#渐进空间复杂度\" class=\"headerlink\" title=\"渐进空间复杂度\"></a>渐进空间复杂度</h3><p><strong>和时间复杂度类似，渐进空间复杂度(Space Complexity)作为算法所需存储空间的量度，它也是问题规模n的函数，记作S(n) = O(f(n))</strong><br>在分析时，输入数据所占的具体存储量取决于问题，和算法无关，所以秩序分析该算法在实现是所需要的辅助空间就行了。<br>若算法实现时所需的辅助存储空间相对于输入数据量而言是个常数，与问题本身无关，则称这个算法为原地工作，辅助空间为O(1)。</p>\n<pre><code class=\"C\">示例：\n\nfor(i=0;i&lt;n/2;i++){\n    t = a[i];\n    a[i] = a[n-i-1];\n    a[n-i-1] = t;\n}\n\n由于算法只需借助一个变量t，与问题规模n的大小无关，所以其空间复杂度为O(1)\n\n\nfor(i=0;i&lt;n;i++)\n    b[i] = a[n-i-1];\nfor(i=0;i&lt;n/2;i++)\n    a[i] = b[i];\n\n算法需要借助一个大小为n的辅助数组b，所以其空间复杂度为O(n)</code></pre>\n<blockquote>\n<p>参考：人民邮电出版社《数据结构    C语言版|第二版》严蔚敏</p>\n</blockquote>\n"},{"title":"用于小型网站后端的Web-MySQL","date":"2020-01-29T17:49:00.000Z","_content":"\n[简介](#简介)\n---\n\nWeb-MySQL是一个用于后端使用Python连接数据库的包，主要用于小型的Web项目开发时简化数据库连接操作，它可用于Flask或者Django，也可用于其他类型的项目开发。\n\n它是基于PyMySQL构建出来的一个简单的SQL命令执行工具包，可以使用pip进行安装，主要使用Connector类的executor、fetchone和fetchall这3个功能，调用了PyMySQL的功能进行自动连接数据库和断开连接。\n\n使用Web-MySQL的时候，需要导入Web-MySQL的Connector类，创建一个对象并初始化数据库配置，就可以调用函数对相应的MySQL数据库执行SQL命令。\n\nGitHub仓库地址：[https://github.com/arukione/Web-MySQL](https://github.com/arukione/Web-MySQL)\n\n[使用](#使用)\n---\n\n你可以使用pip安装来Web-MySQL：`pip install Web-MySQL`\n\n使用时推荐将操作这个数据库的函数写在一个单独Python文件里，方便函数的管理和引入使用，创建一个全局的Connector实例，并修改实例中连接数据库的相应信息变量\n\n调用相应函数传入SQL命令和values就可以执行数据库操作，当SQL命令中没有需要传入的变量时，可不传入values，默认values为None。\n\n[示例](#示例)\n---\n\n```Python\nfrom web_mysql import Connector\n\nconnector = Connector()\nconnector.host = \"localhost\"\nconnector.user = \"root\"\nconnector.password = \"123456\"\nconnector.database = \"test\"\n\ndef insert_user():\n  sql = \"insert into users (name,id) values (%s,%s);\"\n  values = [\"name\", 10001]\n  connector.executor(sql, values)\n\ndef get_user(name, id):\n  sql = \"select * from users where name=%s and id=%s;\"\n  values = [name, id]\n  user = connector.fetchone(sql, values)\n\ndef get_users():\n  sql = \"select * from users;\"\n  all_user = connector.fetchall(sql)\n```\n\n[建议](#建议)\n---\n\n对不同数据库进行操作是应当在不同文件下创建另外一个connector实例，这也是为什么要将该数据库的操作函数写在同一个单独的Python文件里，这样有利于代码的维护。\n\n当然也可以使用类来代替文件，此时应有多个Python类来创建不同的实例去操作不同的数据库\n\n[附带](#附带)\n---\n\n**PyMySQL：**[https://github.com/PyMySQL/PyMySQL](https://github.com/PyMySQL/PyMySQL)\n\n[闲着没事造轮子](https://www.arukione.com/2020/01/30/%E9%97%B2%E7%9D%80%E6%B2%A1%E4%BA%8B%E9%80%A0%E8%BD%AE%E5%AD%90/)\n","source":"_posts/用于小型网站后端的Web-MySQL.md","raw":"---\ntitle: 用于小型网站后端的Web-MySQL\ndate: 2020-1-30 1:49\ncategories: 技术文章\ntags:\n    - Python\n    - MySQL\n---\n\n[简介](#简介)\n---\n\nWeb-MySQL是一个用于后端使用Python连接数据库的包，主要用于小型的Web项目开发时简化数据库连接操作，它可用于Flask或者Django，也可用于其他类型的项目开发。\n\n它是基于PyMySQL构建出来的一个简单的SQL命令执行工具包，可以使用pip进行安装，主要使用Connector类的executor、fetchone和fetchall这3个功能，调用了PyMySQL的功能进行自动连接数据库和断开连接。\n\n使用Web-MySQL的时候，需要导入Web-MySQL的Connector类，创建一个对象并初始化数据库配置，就可以调用函数对相应的MySQL数据库执行SQL命令。\n\nGitHub仓库地址：[https://github.com/arukione/Web-MySQL](https://github.com/arukione/Web-MySQL)\n\n[使用](#使用)\n---\n\n你可以使用pip安装来Web-MySQL：`pip install Web-MySQL`\n\n使用时推荐将操作这个数据库的函数写在一个单独Python文件里，方便函数的管理和引入使用，创建一个全局的Connector实例，并修改实例中连接数据库的相应信息变量\n\n调用相应函数传入SQL命令和values就可以执行数据库操作，当SQL命令中没有需要传入的变量时，可不传入values，默认values为None。\n\n[示例](#示例)\n---\n\n```Python\nfrom web_mysql import Connector\n\nconnector = Connector()\nconnector.host = \"localhost\"\nconnector.user = \"root\"\nconnector.password = \"123456\"\nconnector.database = \"test\"\n\ndef insert_user():\n  sql = \"insert into users (name,id) values (%s,%s);\"\n  values = [\"name\", 10001]\n  connector.executor(sql, values)\n\ndef get_user(name, id):\n  sql = \"select * from users where name=%s and id=%s;\"\n  values = [name, id]\n  user = connector.fetchone(sql, values)\n\ndef get_users():\n  sql = \"select * from users;\"\n  all_user = connector.fetchall(sql)\n```\n\n[建议](#建议)\n---\n\n对不同数据库进行操作是应当在不同文件下创建另外一个connector实例，这也是为什么要将该数据库的操作函数写在同一个单独的Python文件里，这样有利于代码的维护。\n\n当然也可以使用类来代替文件，此时应有多个Python类来创建不同的实例去操作不同的数据库\n\n[附带](#附带)\n---\n\n**PyMySQL：**[https://github.com/PyMySQL/PyMySQL](https://github.com/PyMySQL/PyMySQL)\n\n[闲着没事造轮子](https://www.arukione.com/2020/01/30/%E9%97%B2%E7%9D%80%E6%B2%A1%E4%BA%8B%E9%80%A0%E8%BD%AE%E5%AD%90/)\n","slug":"用于小型网站后端的Web-MySQL","published":1,"updated":"2020-02-03T13:32:14.340Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6ywriw3000t54v5944odmqd","content":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a><a href=\"#简介\">简介</a></h2><p>Web-MySQL是一个用于后端使用Python连接数据库的包，主要用于小型的Web项目开发时简化数据库连接操作，它可用于Flask或者Django，也可用于其他类型的项目开发。</p>\n<p>它是基于PyMySQL构建出来的一个简单的SQL命令执行工具包，可以使用pip进行安装，主要使用Connector类的executor、fetchone和fetchall这3个功能，调用了PyMySQL的功能进行自动连接数据库和断开连接。</p>\n<p>使用Web-MySQL的时候，需要导入Web-MySQL的Connector类，创建一个对象并初始化数据库配置，就可以调用函数对相应的MySQL数据库执行SQL命令。</p>\n<p>GitHub仓库地址：<a href=\"https://github.com/arukione/Web-MySQL\" target=\"_blank\" rel=\"noopener\">https://github.com/arukione/Web-MySQL</a></p>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a><a href=\"#使用\">使用</a></h2><p>你可以使用pip安装来Web-MySQL：<code>pip install Web-MySQL</code></p>\n<p>使用时推荐将操作这个数据库的函数写在一个单独Python文件里，方便函数的管理和引入使用，创建一个全局的Connector实例，并修改实例中连接数据库的相应信息变量</p>\n<p>调用相应函数传入SQL命令和values就可以执行数据库操作，当SQL命令中没有需要传入的变量时，可不传入values，默认values为None。</p>\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a><a href=\"#示例\">示例</a></h2><pre><code class=\"Python\">from web_mysql import Connector\n\nconnector = Connector()\nconnector.host = &quot;localhost&quot;\nconnector.user = &quot;root&quot;\nconnector.password = &quot;123456&quot;\nconnector.database = &quot;test&quot;\n\ndef insert_user():\n  sql = &quot;insert into users (name,id) values (%s,%s);&quot;\n  values = [&quot;name&quot;, 10001]\n  connector.executor(sql, values)\n\ndef get_user(name, id):\n  sql = &quot;select * from users where name=%s and id=%s;&quot;\n  values = [name, id]\n  user = connector.fetchone(sql, values)\n\ndef get_users():\n  sql = &quot;select * from users;&quot;\n  all_user = connector.fetchall(sql)</code></pre>\n<h2 id=\"建议\"><a href=\"#建议\" class=\"headerlink\" title=\"建议\"></a><a href=\"#建议\">建议</a></h2><p>对不同数据库进行操作是应当在不同文件下创建另外一个connector实例，这也是为什么要将该数据库的操作函数写在同一个单独的Python文件里，这样有利于代码的维护。</p>\n<p>当然也可以使用类来代替文件，此时应有多个Python类来创建不同的实例去操作不同的数据库</p>\n<h2 id=\"附带\"><a href=\"#附带\" class=\"headerlink\" title=\"附带\"></a><a href=\"#附带\">附带</a></h2><p><strong>PyMySQL：</strong><a href=\"https://github.com/PyMySQL/PyMySQL\" target=\"_blank\" rel=\"noopener\">https://github.com/PyMySQL/PyMySQL</a></p>\n<p><a href=\"https://www.arukione.com/2020/01/30/%E9%97%B2%E7%9D%80%E6%B2%A1%E4%BA%8B%E9%80%A0%E8%BD%AE%E5%AD%90/\" target=\"_blank\" rel=\"noopener\">闲着没事造轮子</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a><a href=\"#简介\">简介</a></h2><p>Web-MySQL是一个用于后端使用Python连接数据库的包，主要用于小型的Web项目开发时简化数据库连接操作，它可用于Flask或者Django，也可用于其他类型的项目开发。</p>\n<p>它是基于PyMySQL构建出来的一个简单的SQL命令执行工具包，可以使用pip进行安装，主要使用Connector类的executor、fetchone和fetchall这3个功能，调用了PyMySQL的功能进行自动连接数据库和断开连接。</p>\n<p>使用Web-MySQL的时候，需要导入Web-MySQL的Connector类，创建一个对象并初始化数据库配置，就可以调用函数对相应的MySQL数据库执行SQL命令。</p>\n<p>GitHub仓库地址：<a href=\"https://github.com/arukione/Web-MySQL\" target=\"_blank\" rel=\"noopener\">https://github.com/arukione/Web-MySQL</a></p>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a><a href=\"#使用\">使用</a></h2><p>你可以使用pip安装来Web-MySQL：<code>pip install Web-MySQL</code></p>\n<p>使用时推荐将操作这个数据库的函数写在一个单独Python文件里，方便函数的管理和引入使用，创建一个全局的Connector实例，并修改实例中连接数据库的相应信息变量</p>\n<p>调用相应函数传入SQL命令和values就可以执行数据库操作，当SQL命令中没有需要传入的变量时，可不传入values，默认values为None。</p>\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a><a href=\"#示例\">示例</a></h2><pre><code class=\"Python\">from web_mysql import Connector\n\nconnector = Connector()\nconnector.host = &quot;localhost&quot;\nconnector.user = &quot;root&quot;\nconnector.password = &quot;123456&quot;\nconnector.database = &quot;test&quot;\n\ndef insert_user():\n  sql = &quot;insert into users (name,id) values (%s,%s);&quot;\n  values = [&quot;name&quot;, 10001]\n  connector.executor(sql, values)\n\ndef get_user(name, id):\n  sql = &quot;select * from users where name=%s and id=%s;&quot;\n  values = [name, id]\n  user = connector.fetchone(sql, values)\n\ndef get_users():\n  sql = &quot;select * from users;&quot;\n  all_user = connector.fetchall(sql)</code></pre>\n<h2 id=\"建议\"><a href=\"#建议\" class=\"headerlink\" title=\"建议\"></a><a href=\"#建议\">建议</a></h2><p>对不同数据库进行操作是应当在不同文件下创建另外一个connector实例，这也是为什么要将该数据库的操作函数写在同一个单独的Python文件里，这样有利于代码的维护。</p>\n<p>当然也可以使用类来代替文件，此时应有多个Python类来创建不同的实例去操作不同的数据库</p>\n<h2 id=\"附带\"><a href=\"#附带\" class=\"headerlink\" title=\"附带\"></a><a href=\"#附带\">附带</a></h2><p><strong>PyMySQL：</strong><a href=\"https://github.com/PyMySQL/PyMySQL\" target=\"_blank\" rel=\"noopener\">https://github.com/PyMySQL/PyMySQL</a></p>\n<p><a href=\"https://www.arukione.com/2020/01/30/%E9%97%B2%E7%9D%80%E6%B2%A1%E4%BA%8B%E9%80%A0%E8%BD%AE%E5%AD%90/\" target=\"_blank\" rel=\"noopener\">闲着没事造轮子</a></p>\n"},{"title":"机器学习资源分享","date":"2019-04-03T16:00:00.000Z","_content":"<div align=\"center\">\n\n**我只想说虽然很有兴趣，但是学习深度学习感觉有点难！！！**\n**在这里和大家分享点学习资源，希望能给学习机器学习、深度学习的小伙伴帮助。**\n\n**B站机器学习视频：**\n    **上交ACM机器学习：<https://www.bilibili.com/video/av58580135>**\n    **吴恩达（Ng）机器学习：<https://www.bilibili.com/video/av9912938>**\n    **斯坦福 CS224n 自然语言处理：<https://www.bilibili.com/video/av46216519>**\n\n**ApacheCN学习组织：<https://github.com/apachecn/AiLearning>**\n**斯坦福 CS224n 自然语言处理中文笔记：<https://github.com/apachecn/stanford-cs224n-notes-zh>**\n\n**知乎卷积神经网络讲解：<https://zhuanlan.zhihu.com/c_141391545>**\n\n**神经网络&CNN论文（需要翻墙）：<http://cs231n.github.io/>**\n**深度学习论文网站 ：<https://paperswithcode.com/task/video-classification#code>**\n\n**一个有点好玩、能帮助理解的数学可视化视频：**\n    **深度学习（Deep Learning）：<https://space.bilibili.com/88461692/channel/detail?cid=26587>**\n    **微积分：<https://space.bilibili.com/88461692/channel/detail?cid=13407>**\n    **在B站的全部视频：<https://space.bilibili.com/88461692?spm_id_from=333.788.b_765f7570696e666f.1>**\n\n</div>\n","source":"_posts/机器学习资源分享.md","raw":"---\ntitle: 机器学习资源分享\ndate: 2019-4-4\ncategories: 学习笔记\ntags:\n    - 深度学习\n    - 神经网络\n---\n<div align=\"center\">\n\n**我只想说虽然很有兴趣，但是学习深度学习感觉有点难！！！**\n**在这里和大家分享点学习资源，希望能给学习机器学习、深度学习的小伙伴帮助。**\n\n**B站机器学习视频：**\n    **上交ACM机器学习：<https://www.bilibili.com/video/av58580135>**\n    **吴恩达（Ng）机器学习：<https://www.bilibili.com/video/av9912938>**\n    **斯坦福 CS224n 自然语言处理：<https://www.bilibili.com/video/av46216519>**\n\n**ApacheCN学习组织：<https://github.com/apachecn/AiLearning>**\n**斯坦福 CS224n 自然语言处理中文笔记：<https://github.com/apachecn/stanford-cs224n-notes-zh>**\n\n**知乎卷积神经网络讲解：<https://zhuanlan.zhihu.com/c_141391545>**\n\n**神经网络&CNN论文（需要翻墙）：<http://cs231n.github.io/>**\n**深度学习论文网站 ：<https://paperswithcode.com/task/video-classification#code>**\n\n**一个有点好玩、能帮助理解的数学可视化视频：**\n    **深度学习（Deep Learning）：<https://space.bilibili.com/88461692/channel/detail?cid=26587>**\n    **微积分：<https://space.bilibili.com/88461692/channel/detail?cid=13407>**\n    **在B站的全部视频：<https://space.bilibili.com/88461692?spm_id_from=333.788.b_765f7570696e666f.1>**\n\n</div>\n","slug":"机器学习资源分享","published":1,"updated":"2020-02-06T09:15:48.183Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6ywriw6000v54v55d6t0v4r","content":"<div align=\"center\">\n\n<p><strong>我只想说虽然很有兴趣，但是学习深度学习感觉有点难！！！</strong><br><strong>在这里和大家分享点学习资源，希望能给学习机器学习、深度学习的小伙伴帮助。</strong></p>\n<p><strong>B站机器学习视频：</strong><br>    <strong>上交ACM机器学习：<a href=\"https://www.bilibili.com/video/av58580135\" target=\"_blank\" rel=\"noopener\">https://www.bilibili.com/video/av58580135</a></strong><br>    <strong>吴恩达（Ng）机器学习：<a href=\"https://www.bilibili.com/video/av9912938\" target=\"_blank\" rel=\"noopener\">https://www.bilibili.com/video/av9912938</a></strong><br>    <strong>斯坦福 CS224n 自然语言处理：<a href=\"https://www.bilibili.com/video/av46216519\" target=\"_blank\" rel=\"noopener\">https://www.bilibili.com/video/av46216519</a></strong></p>\n<p><strong>ApacheCN学习组织：<a href=\"https://github.com/apachecn/AiLearning\" target=\"_blank\" rel=\"noopener\">https://github.com/apachecn/AiLearning</a></strong><br><strong>斯坦福 CS224n 自然语言处理中文笔记：<a href=\"https://github.com/apachecn/stanford-cs224n-notes-zh\" target=\"_blank\" rel=\"noopener\">https://github.com/apachecn/stanford-cs224n-notes-zh</a></strong></p>\n<p><strong>知乎卷积神经网络讲解：<a href=\"https://zhuanlan.zhihu.com/c_141391545\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/c_141391545</a></strong></p>\n<p><strong>神经网络&amp;CNN论文（需要翻墙）：<a href=\"http://cs231n.github.io/\" target=\"_blank\" rel=\"noopener\">http://cs231n.github.io/</a></strong><br><strong>深度学习论文网站 ：<a href=\"https://paperswithcode.com/task/video-classification#code\" target=\"_blank\" rel=\"noopener\">https://paperswithcode.com/task/video-classification#code</a></strong></p>\n<p><strong>一个有点好玩、能帮助理解的数学可视化视频：</strong><br>    <strong>深度学习（Deep Learning）：<a href=\"https://space.bilibili.com/88461692/channel/detail?cid=26587\" target=\"_blank\" rel=\"noopener\">https://space.bilibili.com/88461692/channel/detail?cid=26587</a></strong><br>    <strong>微积分：<a href=\"https://space.bilibili.com/88461692/channel/detail?cid=13407\" target=\"_blank\" rel=\"noopener\">https://space.bilibili.com/88461692/channel/detail?cid=13407</a></strong><br>    <strong>在B站的全部视频：<a href=\"https://space.bilibili.com/88461692?spm_id_from=333.788.b_765f7570696e666f.1\" target=\"_blank\" rel=\"noopener\">https://space.bilibili.com/88461692?spm_id_from=333.788.b_765f7570696e666f.1</a></strong></p>\n</div>\n","site":{"data":{}},"excerpt":"","more":"<div align=\"center\">\n\n<p><strong>我只想说虽然很有兴趣，但是学习深度学习感觉有点难！！！</strong><br><strong>在这里和大家分享点学习资源，希望能给学习机器学习、深度学习的小伙伴帮助。</strong></p>\n<p><strong>B站机器学习视频：</strong><br>    <strong>上交ACM机器学习：<a href=\"https://www.bilibili.com/video/av58580135\" target=\"_blank\" rel=\"noopener\">https://www.bilibili.com/video/av58580135</a></strong><br>    <strong>吴恩达（Ng）机器学习：<a href=\"https://www.bilibili.com/video/av9912938\" target=\"_blank\" rel=\"noopener\">https://www.bilibili.com/video/av9912938</a></strong><br>    <strong>斯坦福 CS224n 自然语言处理：<a href=\"https://www.bilibili.com/video/av46216519\" target=\"_blank\" rel=\"noopener\">https://www.bilibili.com/video/av46216519</a></strong></p>\n<p><strong>ApacheCN学习组织：<a href=\"https://github.com/apachecn/AiLearning\" target=\"_blank\" rel=\"noopener\">https://github.com/apachecn/AiLearning</a></strong><br><strong>斯坦福 CS224n 自然语言处理中文笔记：<a href=\"https://github.com/apachecn/stanford-cs224n-notes-zh\" target=\"_blank\" rel=\"noopener\">https://github.com/apachecn/stanford-cs224n-notes-zh</a></strong></p>\n<p><strong>知乎卷积神经网络讲解：<a href=\"https://zhuanlan.zhihu.com/c_141391545\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/c_141391545</a></strong></p>\n<p><strong>神经网络&amp;CNN论文（需要翻墙）：<a href=\"http://cs231n.github.io/\" target=\"_blank\" rel=\"noopener\">http://cs231n.github.io/</a></strong><br><strong>深度学习论文网站 ：<a href=\"https://paperswithcode.com/task/video-classification#code\" target=\"_blank\" rel=\"noopener\">https://paperswithcode.com/task/video-classification#code</a></strong></p>\n<p><strong>一个有点好玩、能帮助理解的数学可视化视频：</strong><br>    <strong>深度学习（Deep Learning）：<a href=\"https://space.bilibili.com/88461692/channel/detail?cid=26587\" target=\"_blank\" rel=\"noopener\">https://space.bilibili.com/88461692/channel/detail?cid=26587</a></strong><br>    <strong>微积分：<a href=\"https://space.bilibili.com/88461692/channel/detail?cid=13407\" target=\"_blank\" rel=\"noopener\">https://space.bilibili.com/88461692/channel/detail?cid=13407</a></strong><br>    <strong>在B站的全部视频：<a href=\"https://space.bilibili.com/88461692?spm_id_from=333.788.b_765f7570696e666f.1\" target=\"_blank\" rel=\"noopener\">https://space.bilibili.com/88461692?spm_id_from=333.788.b_765f7570696e666f.1</a></strong></p>\n</div>\n"},{"title":"算法导论python快速排序代码理解","date":"2020-01-24T16:00:00.000Z","_content":"\n写易班2020新年专栏项目的时候，想给文章按照列表里文章的点赞数和评论数的和来从大到小排序，毕竟是网站，为了用户体验，访问速度肯定是不能慢的。\n\n但是Python这语言本身执行效率就堪忧...以前做题目的时候，发现同样是2千万次循环，同样的算法，Java几百毫秒就解决了，Python用了7秒？\n\n想让排序快点就只能选择快速排序了，虽然看学校数据结构的书有看到快速排序的思想，但实际没有去实现过所以去网上找了关于快速排序的Python代码\n\n偶然在一篇文章看到了《算法导论》中的快速排序，当时觉得，哇塞，代码居然这么精简(虽然后来看到了更加精简的代码，我还是太菜了，还够不到大佬的后脚跟~)，当时为了赶时间就从这个代码下手理解了。\n\n```Python\n# 据说是《算法导论》中的快速排序\n\ndef quick_sort(array, l, r):\n    if l < r:\n        q = partition(array, l, r)\n        quick_sort(array, l, q - 1)\n        quick_sort(array, q + 1, r)\n\ndef partition(array, l, r):\n    x = array[r]\n    i = l - 1\n    for j in range(l, r):\n        if array[j] <= x:\n            i += 1\n            array[i], array[j] = array[j], array[i]\n    array[i + 1], array[r] = array[r], array[i + 1]\n    return i + 1\n```\n\n怎么理解这个快速排序的代码呢？\n\n嘛，首先是要知道快速排序的思路，忘记的不知道的先去补课。\n\n从这个代码可以看出，每次排序用了一次循环，代码中的l就是left，r就是right，分别代表操作的列表的左下标和右下标，初始传入的下标就是0和len(array)-1\n\npartition是分片的意思，其实在分片的时候，就是进行了一次排序了。\n\npartition函数中把列表最右边的值作为划分值，交换点下标为传入列表最右边-1，为什么是-1，而不是l呢，因为这个代码后面每一次交换位置分点的下标都会向右移，为了防止漏掉l下标，所以要先减一，第一次交换的时候+1就变成l下标了。当然代码也可以改成下面这种直接把l赋值给i的形式\n\n```Python\ndef partition(array, l, r):\n    x = array[r]\n    i = l\n    for j in range(l, r):\n        if array[j] <= x:\n            array[i], array[j] = array[j], array[i]\n            i += 1\n    array[i], array[r] = array[r], array[i]\n    return i\n```\n\nfor循环是遍历下标从l到r-1的元素，由于下标为r的元素是我们的分片点，所以不需要进行比较，当遍历到的元素值小于划分值，就把这个元素向左边的i移动，这样到最后，所有小于划分值的元素都会在i下标位置的左边，而i下标位置右边的，都是大于划分值的，但是此时i下标的元素仍然是大于划分值的，我们要把划分的元素放到划分点，所以最后要把i下标的元素和划分元素(最右边那个没有被遍历到的元素)交换位置，这样就完成了分片，然后返回分片点的下标，然后回到quick_sort函数继续递归。\n\n在quick_sort函数中的q是partition函数返回是划分点下标，所以已经不需要进行排序了，只需要对分片后的两边列表进行排序就行了，所以调用quick_sort函数(`quick_sort(array, l, q - 1)`和`quick_sort(array, q + 1, r)`)，继续对两边子列表进行排序，直到最后分片的两个元素排序好返回分片点下标，由于就剩下两个元素，所以排序完返回的下标肯定是这两个元素其中一个，这时传入q-1和另外一个下标到quick_sort已经无法满足`if l < r`了，所以该子列表排序完成，结束递归，等所有子列表都排序完，整个列表就从小到大排序好了。\n\n当然我们也可以吧partition里的`<=`改成`>=`，这样就是所有大于划分值的元素都在i下标位置的左边，列表将从大到小排序。\n\n由于快速排序是原地排序，在Python里直接采取原列表交换元素的方式，按照Python语言的特性不需要进行返回，原本传入的列表就会被排序好，当然也就无法传入元组(tuple)了\n","source":"_posts/算法导论python快速排序代码理解.md","raw":"---\ntitle: 算法导论python快速排序代码理解\ndate: 2020-1-25\ncategories: 学习笔记\ntags:\n    - Python\n---\n\n写易班2020新年专栏项目的时候，想给文章按照列表里文章的点赞数和评论数的和来从大到小排序，毕竟是网站，为了用户体验，访问速度肯定是不能慢的。\n\n但是Python这语言本身执行效率就堪忧...以前做题目的时候，发现同样是2千万次循环，同样的算法，Java几百毫秒就解决了，Python用了7秒？\n\n想让排序快点就只能选择快速排序了，虽然看学校数据结构的书有看到快速排序的思想，但实际没有去实现过所以去网上找了关于快速排序的Python代码\n\n偶然在一篇文章看到了《算法导论》中的快速排序，当时觉得，哇塞，代码居然这么精简(虽然后来看到了更加精简的代码，我还是太菜了，还够不到大佬的后脚跟~)，当时为了赶时间就从这个代码下手理解了。\n\n```Python\n# 据说是《算法导论》中的快速排序\n\ndef quick_sort(array, l, r):\n    if l < r:\n        q = partition(array, l, r)\n        quick_sort(array, l, q - 1)\n        quick_sort(array, q + 1, r)\n\ndef partition(array, l, r):\n    x = array[r]\n    i = l - 1\n    for j in range(l, r):\n        if array[j] <= x:\n            i += 1\n            array[i], array[j] = array[j], array[i]\n    array[i + 1], array[r] = array[r], array[i + 1]\n    return i + 1\n```\n\n怎么理解这个快速排序的代码呢？\n\n嘛，首先是要知道快速排序的思路，忘记的不知道的先去补课。\n\n从这个代码可以看出，每次排序用了一次循环，代码中的l就是left，r就是right，分别代表操作的列表的左下标和右下标，初始传入的下标就是0和len(array)-1\n\npartition是分片的意思，其实在分片的时候，就是进行了一次排序了。\n\npartition函数中把列表最右边的值作为划分值，交换点下标为传入列表最右边-1，为什么是-1，而不是l呢，因为这个代码后面每一次交换位置分点的下标都会向右移，为了防止漏掉l下标，所以要先减一，第一次交换的时候+1就变成l下标了。当然代码也可以改成下面这种直接把l赋值给i的形式\n\n```Python\ndef partition(array, l, r):\n    x = array[r]\n    i = l\n    for j in range(l, r):\n        if array[j] <= x:\n            array[i], array[j] = array[j], array[i]\n            i += 1\n    array[i], array[r] = array[r], array[i]\n    return i\n```\n\nfor循环是遍历下标从l到r-1的元素，由于下标为r的元素是我们的分片点，所以不需要进行比较，当遍历到的元素值小于划分值，就把这个元素向左边的i移动，这样到最后，所有小于划分值的元素都会在i下标位置的左边，而i下标位置右边的，都是大于划分值的，但是此时i下标的元素仍然是大于划分值的，我们要把划分的元素放到划分点，所以最后要把i下标的元素和划分元素(最右边那个没有被遍历到的元素)交换位置，这样就完成了分片，然后返回分片点的下标，然后回到quick_sort函数继续递归。\n\n在quick_sort函数中的q是partition函数返回是划分点下标，所以已经不需要进行排序了，只需要对分片后的两边列表进行排序就行了，所以调用quick_sort函数(`quick_sort(array, l, q - 1)`和`quick_sort(array, q + 1, r)`)，继续对两边子列表进行排序，直到最后分片的两个元素排序好返回分片点下标，由于就剩下两个元素，所以排序完返回的下标肯定是这两个元素其中一个，这时传入q-1和另外一个下标到quick_sort已经无法满足`if l < r`了，所以该子列表排序完成，结束递归，等所有子列表都排序完，整个列表就从小到大排序好了。\n\n当然我们也可以吧partition里的`<=`改成`>=`，这样就是所有大于划分值的元素都在i下标位置的左边，列表将从大到小排序。\n\n由于快速排序是原地排序，在Python里直接采取原列表交换元素的方式，按照Python语言的特性不需要进行返回，原本传入的列表就会被排序好，当然也就无法传入元组(tuple)了\n","slug":"算法导论python快速排序代码理解","published":1,"updated":"2020-01-29T18:42:32.658Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6ywriw8001054v586xee192","content":"<p>写易班2020新年专栏项目的时候，想给文章按照列表里文章的点赞数和评论数的和来从大到小排序，毕竟是网站，为了用户体验，访问速度肯定是不能慢的。</p>\n<p>但是Python这语言本身执行效率就堪忧…以前做题目的时候，发现同样是2千万次循环，同样的算法，Java几百毫秒就解决了，Python用了7秒？</p>\n<p>想让排序快点就只能选择快速排序了，虽然看学校数据结构的书有看到快速排序的思想，但实际没有去实现过所以去网上找了关于快速排序的Python代码</p>\n<p>偶然在一篇文章看到了《算法导论》中的快速排序，当时觉得，哇塞，代码居然这么精简(虽然后来看到了更加精简的代码，我还是太菜了，还够不到大佬的后脚跟~)，当时为了赶时间就从这个代码下手理解了。</p>\n<pre><code class=\"Python\"># 据说是《算法导论》中的快速排序\n\ndef quick_sort(array, l, r):\n    if l &lt; r:\n        q = partition(array, l, r)\n        quick_sort(array, l, q - 1)\n        quick_sort(array, q + 1, r)\n\ndef partition(array, l, r):\n    x = array[r]\n    i = l - 1\n    for j in range(l, r):\n        if array[j] &lt;= x:\n            i += 1\n            array[i], array[j] = array[j], array[i]\n    array[i + 1], array[r] = array[r], array[i + 1]\n    return i + 1</code></pre>\n<p>怎么理解这个快速排序的代码呢？</p>\n<p>嘛，首先是要知道快速排序的思路，忘记的不知道的先去补课。</p>\n<p>从这个代码可以看出，每次排序用了一次循环，代码中的l就是left，r就是right，分别代表操作的列表的左下标和右下标，初始传入的下标就是0和len(array)-1</p>\n<p>partition是分片的意思，其实在分片的时候，就是进行了一次排序了。</p>\n<p>partition函数中把列表最右边的值作为划分值，交换点下标为传入列表最右边-1，为什么是-1，而不是l呢，因为这个代码后面每一次交换位置分点的下标都会向右移，为了防止漏掉l下标，所以要先减一，第一次交换的时候+1就变成l下标了。当然代码也可以改成下面这种直接把l赋值给i的形式</p>\n<pre><code class=\"Python\">def partition(array, l, r):\n    x = array[r]\n    i = l\n    for j in range(l, r):\n        if array[j] &lt;= x:\n            array[i], array[j] = array[j], array[i]\n            i += 1\n    array[i], array[r] = array[r], array[i]\n    return i</code></pre>\n<p>for循环是遍历下标从l到r-1的元素，由于下标为r的元素是我们的分片点，所以不需要进行比较，当遍历到的元素值小于划分值，就把这个元素向左边的i移动，这样到最后，所有小于划分值的元素都会在i下标位置的左边，而i下标位置右边的，都是大于划分值的，但是此时i下标的元素仍然是大于划分值的，我们要把划分的元素放到划分点，所以最后要把i下标的元素和划分元素(最右边那个没有被遍历到的元素)交换位置，这样就完成了分片，然后返回分片点的下标，然后回到quick_sort函数继续递归。</p>\n<p>在quick_sort函数中的q是partition函数返回是划分点下标，所以已经不需要进行排序了，只需要对分片后的两边列表进行排序就行了，所以调用quick_sort函数(<code>quick_sort(array, l, q - 1)</code>和<code>quick_sort(array, q + 1, r)</code>)，继续对两边子列表进行排序，直到最后分片的两个元素排序好返回分片点下标，由于就剩下两个元素，所以排序完返回的下标肯定是这两个元素其中一个，这时传入q-1和另外一个下标到quick_sort已经无法满足<code>if l &lt; r</code>了，所以该子列表排序完成，结束递归，等所有子列表都排序完，整个列表就从小到大排序好了。</p>\n<p>当然我们也可以吧partition里的<code>&lt;=</code>改成<code>&gt;=</code>，这样就是所有大于划分值的元素都在i下标位置的左边，列表将从大到小排序。</p>\n<p>由于快速排序是原地排序，在Python里直接采取原列表交换元素的方式，按照Python语言的特性不需要进行返回，原本传入的列表就会被排序好，当然也就无法传入元组(tuple)了</p>\n","site":{"data":{}},"excerpt":"","more":"<p>写易班2020新年专栏项目的时候，想给文章按照列表里文章的点赞数和评论数的和来从大到小排序，毕竟是网站，为了用户体验，访问速度肯定是不能慢的。</p>\n<p>但是Python这语言本身执行效率就堪忧…以前做题目的时候，发现同样是2千万次循环，同样的算法，Java几百毫秒就解决了，Python用了7秒？</p>\n<p>想让排序快点就只能选择快速排序了，虽然看学校数据结构的书有看到快速排序的思想，但实际没有去实现过所以去网上找了关于快速排序的Python代码</p>\n<p>偶然在一篇文章看到了《算法导论》中的快速排序，当时觉得，哇塞，代码居然这么精简(虽然后来看到了更加精简的代码，我还是太菜了，还够不到大佬的后脚跟~)，当时为了赶时间就从这个代码下手理解了。</p>\n<pre><code class=\"Python\"># 据说是《算法导论》中的快速排序\n\ndef quick_sort(array, l, r):\n    if l &lt; r:\n        q = partition(array, l, r)\n        quick_sort(array, l, q - 1)\n        quick_sort(array, q + 1, r)\n\ndef partition(array, l, r):\n    x = array[r]\n    i = l - 1\n    for j in range(l, r):\n        if array[j] &lt;= x:\n            i += 1\n            array[i], array[j] = array[j], array[i]\n    array[i + 1], array[r] = array[r], array[i + 1]\n    return i + 1</code></pre>\n<p>怎么理解这个快速排序的代码呢？</p>\n<p>嘛，首先是要知道快速排序的思路，忘记的不知道的先去补课。</p>\n<p>从这个代码可以看出，每次排序用了一次循环，代码中的l就是left，r就是right，分别代表操作的列表的左下标和右下标，初始传入的下标就是0和len(array)-1</p>\n<p>partition是分片的意思，其实在分片的时候，就是进行了一次排序了。</p>\n<p>partition函数中把列表最右边的值作为划分值，交换点下标为传入列表最右边-1，为什么是-1，而不是l呢，因为这个代码后面每一次交换位置分点的下标都会向右移，为了防止漏掉l下标，所以要先减一，第一次交换的时候+1就变成l下标了。当然代码也可以改成下面这种直接把l赋值给i的形式</p>\n<pre><code class=\"Python\">def partition(array, l, r):\n    x = array[r]\n    i = l\n    for j in range(l, r):\n        if array[j] &lt;= x:\n            array[i], array[j] = array[j], array[i]\n            i += 1\n    array[i], array[r] = array[r], array[i]\n    return i</code></pre>\n<p>for循环是遍历下标从l到r-1的元素，由于下标为r的元素是我们的分片点，所以不需要进行比较，当遍历到的元素值小于划分值，就把这个元素向左边的i移动，这样到最后，所有小于划分值的元素都会在i下标位置的左边，而i下标位置右边的，都是大于划分值的，但是此时i下标的元素仍然是大于划分值的，我们要把划分的元素放到划分点，所以最后要把i下标的元素和划分元素(最右边那个没有被遍历到的元素)交换位置，这样就完成了分片，然后返回分片点的下标，然后回到quick_sort函数继续递归。</p>\n<p>在quick_sort函数中的q是partition函数返回是划分点下标，所以已经不需要进行排序了，只需要对分片后的两边列表进行排序就行了，所以调用quick_sort函数(<code>quick_sort(array, l, q - 1)</code>和<code>quick_sort(array, q + 1, r)</code>)，继续对两边子列表进行排序，直到最后分片的两个元素排序好返回分片点下标，由于就剩下两个元素，所以排序完返回的下标肯定是这两个元素其中一个，这时传入q-1和另外一个下标到quick_sort已经无法满足<code>if l &lt; r</code>了，所以该子列表排序完成，结束递归，等所有子列表都排序完，整个列表就从小到大排序好了。</p>\n<p>当然我们也可以吧partition里的<code>&lt;=</code>改成<code>&gt;=</code>，这样就是所有大于划分值的元素都在i下标位置的左边，列表将从大到小排序。</p>\n<p>由于快速排序是原地排序，在Python里直接采取原列表交换元素的方式，按照Python语言的特性不需要进行返回，原本传入的列表就会被排序好，当然也就无法传入元组(tuple)了</p>\n"},{"title":"用树结构获取自然数拆分结果","date":"2019-11-09T16:00:00.000Z","_content":"\n**任何一个大于1的自然数n，都可以拆分成若干个小于n的自然数相加，现在输入一个数n，列出该数的所有拆分可能**\n像这种获取所有可能性的问题，我第一想到的当然是...\n好吧，这次其实我第一次想到的不是树，而是for循环，其实就是被那么规律的排列给误导了~\n但是最后还是靠树来实现了\n\n不过这一次的问题没定义Tree类了，直接定义了Node类传入列表进行计算存储。\n其实这个问题就是从1到n-1开始遍历，将遍历到的数存到列表里面，每次存完1个数将列表传入下一个节点，再从1开始存，直到列表的和等于n的值，把这个列表进行排序然后存入全局列表result里面，最后再打印出来。\n\n以下是实现代码\n\n```Python\n# 储存结果\nresult = []\n\n# 定义全局变量n\nn=0\n\nclass Node:\n    def __init__(self,num_list):\n        # 计算列表里值的和\n        list_sum = sum(num_list)\n        # 遍历1到当前可储存的最大值\n        for i in range(1,n-list_sum+1):\n            # 复制已存储自然数的列表\n            new_num_list = num_list[:]\n            # 将可存储的值添加进列表\n            new_num_list.append(i)\n            # 如果添加新值后列表里全部元素的和等于n，则该节点为尾节点\n            if list_sum+i == n:\n                # 判断存的自然数是否全都小于n\n                if len(new_num_list)!=1:\n                    # 对存储的自然数进行排序\n                    new_num_list.sort()\n                    # 判断该结果是否已存在\n                    if new_num_list not in result:\n                        result.append(new_num_list)\n            # 如果不是尾节点，继续添加节点\n            if list_sum+i < n:\n                Node(new_num_list)\n\nif __name__ == \"__main__\":\n    print(\"Enter a number greater than two\")\n    # 设置n的值\n    n = int(input())\n    # 开始拆分\n    num_list = []\n    Node(num_list)\n    # 展示结果\n    for i in result:\n        print(i)\n\n```\n\n其实无论是拆分还是组合，只要是求全部可能性的问题，用树结构都可以很好的解决，如果有其它问题请在评论区留言。\n附上GitHub代码链接：<https://github.com/arukione/PythonLearning>\n","source":"_posts/用树结构获取自然数拆分结果.md","raw":"---\ntitle: 用树结构获取自然数拆分结果\ndate: 2019-11-10\ncategories: 算法代码\ntags:\n    - Python\n---\n\n**任何一个大于1的自然数n，都可以拆分成若干个小于n的自然数相加，现在输入一个数n，列出该数的所有拆分可能**\n像这种获取所有可能性的问题，我第一想到的当然是...\n好吧，这次其实我第一次想到的不是树，而是for循环，其实就是被那么规律的排列给误导了~\n但是最后还是靠树来实现了\n\n不过这一次的问题没定义Tree类了，直接定义了Node类传入列表进行计算存储。\n其实这个问题就是从1到n-1开始遍历，将遍历到的数存到列表里面，每次存完1个数将列表传入下一个节点，再从1开始存，直到列表的和等于n的值，把这个列表进行排序然后存入全局列表result里面，最后再打印出来。\n\n以下是实现代码\n\n```Python\n# 储存结果\nresult = []\n\n# 定义全局变量n\nn=0\n\nclass Node:\n    def __init__(self,num_list):\n        # 计算列表里值的和\n        list_sum = sum(num_list)\n        # 遍历1到当前可储存的最大值\n        for i in range(1,n-list_sum+1):\n            # 复制已存储自然数的列表\n            new_num_list = num_list[:]\n            # 将可存储的值添加进列表\n            new_num_list.append(i)\n            # 如果添加新值后列表里全部元素的和等于n，则该节点为尾节点\n            if list_sum+i == n:\n                # 判断存的自然数是否全都小于n\n                if len(new_num_list)!=1:\n                    # 对存储的自然数进行排序\n                    new_num_list.sort()\n                    # 判断该结果是否已存在\n                    if new_num_list not in result:\n                        result.append(new_num_list)\n            # 如果不是尾节点，继续添加节点\n            if list_sum+i < n:\n                Node(new_num_list)\n\nif __name__ == \"__main__\":\n    print(\"Enter a number greater than two\")\n    # 设置n的值\n    n = int(input())\n    # 开始拆分\n    num_list = []\n    Node(num_list)\n    # 展示结果\n    for i in result:\n        print(i)\n\n```\n\n其实无论是拆分还是组合，只要是求全部可能性的问题，用树结构都可以很好的解决，如果有其它问题请在评论区留言。\n附上GitHub代码链接：<https://github.com/arukione/PythonLearning>\n","slug":"用树结构获取自然数拆分结果","published":1,"updated":"2020-02-06T05:34:54.240Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6ywriwa001354v5cwpzdw1v","content":"<p><strong>任何一个大于1的自然数n，都可以拆分成若干个小于n的自然数相加，现在输入一个数n，列出该数的所有拆分可能</strong><br>像这种获取所有可能性的问题，我第一想到的当然是…<br>好吧，这次其实我第一次想到的不是树，而是for循环，其实就是被那么规律的排列给误导了~<br>但是最后还是靠树来实现了</p>\n<p>不过这一次的问题没定义Tree类了，直接定义了Node类传入列表进行计算存储。<br>其实这个问题就是从1到n-1开始遍历，将遍历到的数存到列表里面，每次存完1个数将列表传入下一个节点，再从1开始存，直到列表的和等于n的值，把这个列表进行排序然后存入全局列表result里面，最后再打印出来。</p>\n<p>以下是实现代码</p>\n<pre><code class=\"Python\"># 储存结果\nresult = []\n\n# 定义全局变量n\nn=0\n\nclass Node:\n    def __init__(self,num_list):\n        # 计算列表里值的和\n        list_sum = sum(num_list)\n        # 遍历1到当前可储存的最大值\n        for i in range(1,n-list_sum+1):\n            # 复制已存储自然数的列表\n            new_num_list = num_list[:]\n            # 将可存储的值添加进列表\n            new_num_list.append(i)\n            # 如果添加新值后列表里全部元素的和等于n，则该节点为尾节点\n            if list_sum+i == n:\n                # 判断存的自然数是否全都小于n\n                if len(new_num_list)!=1:\n                    # 对存储的自然数进行排序\n                    new_num_list.sort()\n                    # 判断该结果是否已存在\n                    if new_num_list not in result:\n                        result.append(new_num_list)\n            # 如果不是尾节点，继续添加节点\n            if list_sum+i &lt; n:\n                Node(new_num_list)\n\nif __name__ == &quot;__main__&quot;:\n    print(&quot;Enter a number greater than two&quot;)\n    # 设置n的值\n    n = int(input())\n    # 开始拆分\n    num_list = []\n    Node(num_list)\n    # 展示结果\n    for i in result:\n        print(i)\n</code></pre>\n<p>其实无论是拆分还是组合，只要是求全部可能性的问题，用树结构都可以很好的解决，如果有其它问题请在评论区留言。<br>附上GitHub代码链接：<a href=\"https://github.com/arukione/PythonLearning\" target=\"_blank\" rel=\"noopener\">https://github.com/arukione/PythonLearning</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>任何一个大于1的自然数n，都可以拆分成若干个小于n的自然数相加，现在输入一个数n，列出该数的所有拆分可能</strong><br>像这种获取所有可能性的问题，我第一想到的当然是…<br>好吧，这次其实我第一次想到的不是树，而是for循环，其实就是被那么规律的排列给误导了~<br>但是最后还是靠树来实现了</p>\n<p>不过这一次的问题没定义Tree类了，直接定义了Node类传入列表进行计算存储。<br>其实这个问题就是从1到n-1开始遍历，将遍历到的数存到列表里面，每次存完1个数将列表传入下一个节点，再从1开始存，直到列表的和等于n的值，把这个列表进行排序然后存入全局列表result里面，最后再打印出来。</p>\n<p>以下是实现代码</p>\n<pre><code class=\"Python\"># 储存结果\nresult = []\n\n# 定义全局变量n\nn=0\n\nclass Node:\n    def __init__(self,num_list):\n        # 计算列表里值的和\n        list_sum = sum(num_list)\n        # 遍历1到当前可储存的最大值\n        for i in range(1,n-list_sum+1):\n            # 复制已存储自然数的列表\n            new_num_list = num_list[:]\n            # 将可存储的值添加进列表\n            new_num_list.append(i)\n            # 如果添加新值后列表里全部元素的和等于n，则该节点为尾节点\n            if list_sum+i == n:\n                # 判断存的自然数是否全都小于n\n                if len(new_num_list)!=1:\n                    # 对存储的自然数进行排序\n                    new_num_list.sort()\n                    # 判断该结果是否已存在\n                    if new_num_list not in result:\n                        result.append(new_num_list)\n            # 如果不是尾节点，继续添加节点\n            if list_sum+i &lt; n:\n                Node(new_num_list)\n\nif __name__ == &quot;__main__&quot;:\n    print(&quot;Enter a number greater than two&quot;)\n    # 设置n的值\n    n = int(input())\n    # 开始拆分\n    num_list = []\n    Node(num_list)\n    # 展示结果\n    for i in result:\n        print(i)\n</code></pre>\n<p>其实无论是拆分还是组合，只要是求全部可能性的问题，用树结构都可以很好的解决，如果有其它问题请在评论区留言。<br>附上GitHub代码链接：<a href=\"https://github.com/arukione/PythonLearning\" target=\"_blank\" rel=\"noopener\">https://github.com/arukione/PythonLearning</a></p>\n"},{"title":"用树结构获取字符排列组合","date":"2019-11-09T16:00:00.000Z","_content":"\n**假如有一串字符串，要对字符串里所有字符进行排列，列出所有排列组合的可能**\n对于这种获取所有可能性的问题我第一想到的就是用树结构来实现，显然这个问题不能用二叉树，那我们就不用二叉树了，反正也没要求一定要用(hhhhh)\n\n对于这种问题，我们知道遍历到最后的树叶就是其中的一种结果，所以我们定义一个全局列表来储存全部树叶的结果。\n对于这个问题，并没有所谓的树根，树的开头就是所有可能的第一个字符。\n所以我们定义一个树的类来对第一次传入节点进行操作；\n定义一个节点类来作为树节点，并直接把向下添加的节点写在构造函数里面，只要符合要求就一直向下传入节点，直到全部字符都遍历完，到达树叶的时候将该结果存储起来。\n\n```Python\n# 存储树叶结果\nresult = []\n\n\n# 树结构\nclass Tree:\n\n    def __init__(self,strings):\n        # 树根节点\n        self.nodes = []\n        if strings != []:\n            for index in range(0,len(strings)):\n                # 把字符传入节点\n                node = Node(index,strings[index],strings)\n                # 添加子节点到树根\n                self.nodes.append(node)\n\n\n# 节点结构\nclass Node:\n    def __init__(self,index,string,strings):\n        # 树节点的值\n        self.value = string\n        # 树节点的子节点\n        self.nodes = []\n        # 复制新的字符列表\n        self.strings = strings[:]\n        # 将已拼接入节点值的字符从字符列表里删除\n        self.strings.pop(index)\n        # 如果字符列表为空，则结束添加节点，将当前树叶节点保存的值存进result\n        if len(self.strings) == 0:\n            result.append(self.value)\n        # 不为空，继续将字符存入新节点添加到当前节点的子节点中\n        else:\n            for i in range(0,len(self.strings)):\n                node = Node(i,self.value+self.strings[i],self.strings)\n                self.nodes.append(node)\n```\n\n以下是执行的主方法\n先从键盘获取字符串，再将字符串转成列表以便进行遍历，然后将字符列表传入树进行操作\n最后按照不同字符开头分段打印出结果\n\n```Python\nif __name__ == \"__main__\":\n    string = str(input())\n\n    strings = list(string)\n    tree = Tree(strings)\n\n    for i in range(0,len(strings)):\n        length = int(len(result)/len(strings))\n        print(result[i*length:i*length+length])\n\n```\n\n对于遍历所有可能的问题，树结构往往会是我第一考虑的解决方法，因为这种结构基本可以将需要的可能都列出来，即使会有累赘的元素，但是所有可能往往都可以很好的列出来，实现起来也很方便。\n有问题反馈请在评论区留言。\nGitHub源代码链接：<https://github.com/arukione/PythonLearning>\n","source":"_posts/用树结构获取字符排列组合.md","raw":"---\ntitle: 用树结构获取字符排列组合\ndate: 2019-11-10\ncategories: 算法代码\ntags:\n    - Python\n---\n\n**假如有一串字符串，要对字符串里所有字符进行排列，列出所有排列组合的可能**\n对于这种获取所有可能性的问题我第一想到的就是用树结构来实现，显然这个问题不能用二叉树，那我们就不用二叉树了，反正也没要求一定要用(hhhhh)\n\n对于这种问题，我们知道遍历到最后的树叶就是其中的一种结果，所以我们定义一个全局列表来储存全部树叶的结果。\n对于这个问题，并没有所谓的树根，树的开头就是所有可能的第一个字符。\n所以我们定义一个树的类来对第一次传入节点进行操作；\n定义一个节点类来作为树节点，并直接把向下添加的节点写在构造函数里面，只要符合要求就一直向下传入节点，直到全部字符都遍历完，到达树叶的时候将该结果存储起来。\n\n```Python\n# 存储树叶结果\nresult = []\n\n\n# 树结构\nclass Tree:\n\n    def __init__(self,strings):\n        # 树根节点\n        self.nodes = []\n        if strings != []:\n            for index in range(0,len(strings)):\n                # 把字符传入节点\n                node = Node(index,strings[index],strings)\n                # 添加子节点到树根\n                self.nodes.append(node)\n\n\n# 节点结构\nclass Node:\n    def __init__(self,index,string,strings):\n        # 树节点的值\n        self.value = string\n        # 树节点的子节点\n        self.nodes = []\n        # 复制新的字符列表\n        self.strings = strings[:]\n        # 将已拼接入节点值的字符从字符列表里删除\n        self.strings.pop(index)\n        # 如果字符列表为空，则结束添加节点，将当前树叶节点保存的值存进result\n        if len(self.strings) == 0:\n            result.append(self.value)\n        # 不为空，继续将字符存入新节点添加到当前节点的子节点中\n        else:\n            for i in range(0,len(self.strings)):\n                node = Node(i,self.value+self.strings[i],self.strings)\n                self.nodes.append(node)\n```\n\n以下是执行的主方法\n先从键盘获取字符串，再将字符串转成列表以便进行遍历，然后将字符列表传入树进行操作\n最后按照不同字符开头分段打印出结果\n\n```Python\nif __name__ == \"__main__\":\n    string = str(input())\n\n    strings = list(string)\n    tree = Tree(strings)\n\n    for i in range(0,len(strings)):\n        length = int(len(result)/len(strings))\n        print(result[i*length:i*length+length])\n\n```\n\n对于遍历所有可能的问题，树结构往往会是我第一考虑的解决方法，因为这种结构基本可以将需要的可能都列出来，即使会有累赘的元素，但是所有可能往往都可以很好的列出来，实现起来也很方便。\n有问题反馈请在评论区留言。\nGitHub源代码链接：<https://github.com/arukione/PythonLearning>\n","slug":"用树结构获取字符排列组合","published":1,"updated":"2020-02-06T05:35:04.187Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6ywriwc001754v5dvo5atvv","content":"<p><strong>假如有一串字符串，要对字符串里所有字符进行排列，列出所有排列组合的可能</strong><br>对于这种获取所有可能性的问题我第一想到的就是用树结构来实现，显然这个问题不能用二叉树，那我们就不用二叉树了，反正也没要求一定要用(hhhhh)</p>\n<p>对于这种问题，我们知道遍历到最后的树叶就是其中的一种结果，所以我们定义一个全局列表来储存全部树叶的结果。<br>对于这个问题，并没有所谓的树根，树的开头就是所有可能的第一个字符。<br>所以我们定义一个树的类来对第一次传入节点进行操作；<br>定义一个节点类来作为树节点，并直接把向下添加的节点写在构造函数里面，只要符合要求就一直向下传入节点，直到全部字符都遍历完，到达树叶的时候将该结果存储起来。</p>\n<pre><code class=\"Python\"># 存储树叶结果\nresult = []\n\n\n# 树结构\nclass Tree:\n\n    def __init__(self,strings):\n        # 树根节点\n        self.nodes = []\n        if strings != []:\n            for index in range(0,len(strings)):\n                # 把字符传入节点\n                node = Node(index,strings[index],strings)\n                # 添加子节点到树根\n                self.nodes.append(node)\n\n\n# 节点结构\nclass Node:\n    def __init__(self,index,string,strings):\n        # 树节点的值\n        self.value = string\n        # 树节点的子节点\n        self.nodes = []\n        # 复制新的字符列表\n        self.strings = strings[:]\n        # 将已拼接入节点值的字符从字符列表里删除\n        self.strings.pop(index)\n        # 如果字符列表为空，则结束添加节点，将当前树叶节点保存的值存进result\n        if len(self.strings) == 0:\n            result.append(self.value)\n        # 不为空，继续将字符存入新节点添加到当前节点的子节点中\n        else:\n            for i in range(0,len(self.strings)):\n                node = Node(i,self.value+self.strings[i],self.strings)\n                self.nodes.append(node)</code></pre>\n<p>以下是执行的主方法<br>先从键盘获取字符串，再将字符串转成列表以便进行遍历，然后将字符列表传入树进行操作<br>最后按照不同字符开头分段打印出结果</p>\n<pre><code class=\"Python\">if __name__ == &quot;__main__&quot;:\n    string = str(input())\n\n    strings = list(string)\n    tree = Tree(strings)\n\n    for i in range(0,len(strings)):\n        length = int(len(result)/len(strings))\n        print(result[i*length:i*length+length])\n</code></pre>\n<p>对于遍历所有可能的问题，树结构往往会是我第一考虑的解决方法，因为这种结构基本可以将需要的可能都列出来，即使会有累赘的元素，但是所有可能往往都可以很好的列出来，实现起来也很方便。<br>有问题反馈请在评论区留言。<br>GitHub源代码链接：<a href=\"https://github.com/arukione/PythonLearning\" target=\"_blank\" rel=\"noopener\">https://github.com/arukione/PythonLearning</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>假如有一串字符串，要对字符串里所有字符进行排列，列出所有排列组合的可能</strong><br>对于这种获取所有可能性的问题我第一想到的就是用树结构来实现，显然这个问题不能用二叉树，那我们就不用二叉树了，反正也没要求一定要用(hhhhh)</p>\n<p>对于这种问题，我们知道遍历到最后的树叶就是其中的一种结果，所以我们定义一个全局列表来储存全部树叶的结果。<br>对于这个问题，并没有所谓的树根，树的开头就是所有可能的第一个字符。<br>所以我们定义一个树的类来对第一次传入节点进行操作；<br>定义一个节点类来作为树节点，并直接把向下添加的节点写在构造函数里面，只要符合要求就一直向下传入节点，直到全部字符都遍历完，到达树叶的时候将该结果存储起来。</p>\n<pre><code class=\"Python\"># 存储树叶结果\nresult = []\n\n\n# 树结构\nclass Tree:\n\n    def __init__(self,strings):\n        # 树根节点\n        self.nodes = []\n        if strings != []:\n            for index in range(0,len(strings)):\n                # 把字符传入节点\n                node = Node(index,strings[index],strings)\n                # 添加子节点到树根\n                self.nodes.append(node)\n\n\n# 节点结构\nclass Node:\n    def __init__(self,index,string,strings):\n        # 树节点的值\n        self.value = string\n        # 树节点的子节点\n        self.nodes = []\n        # 复制新的字符列表\n        self.strings = strings[:]\n        # 将已拼接入节点值的字符从字符列表里删除\n        self.strings.pop(index)\n        # 如果字符列表为空，则结束添加节点，将当前树叶节点保存的值存进result\n        if len(self.strings) == 0:\n            result.append(self.value)\n        # 不为空，继续将字符存入新节点添加到当前节点的子节点中\n        else:\n            for i in range(0,len(self.strings)):\n                node = Node(i,self.value+self.strings[i],self.strings)\n                self.nodes.append(node)</code></pre>\n<p>以下是执行的主方法<br>先从键盘获取字符串，再将字符串转成列表以便进行遍历，然后将字符列表传入树进行操作<br>最后按照不同字符开头分段打印出结果</p>\n<pre><code class=\"Python\">if __name__ == &quot;__main__&quot;:\n    string = str(input())\n\n    strings = list(string)\n    tree = Tree(strings)\n\n    for i in range(0,len(strings)):\n        length = int(len(result)/len(strings))\n        print(result[i*length:i*length+length])\n</code></pre>\n<p>对于遍历所有可能的问题，树结构往往会是我第一考虑的解决方法，因为这种结构基本可以将需要的可能都列出来，即使会有累赘的元素，但是所有可能往往都可以很好的列出来，实现起来也很方便。<br>有问题反馈请在评论区留言。<br>GitHub源代码链接：<a href=\"https://github.com/arukione/PythonLearning\" target=\"_blank\" rel=\"noopener\">https://github.com/arukione/PythonLearning</a></p>\n"},{"title":"蓝桥杯B组试题B:年号字串","date":"2020-02-05T16:00:00.000Z","_content":"\n第十届蓝桥杯大赛软件类省赛C/C++大学B组\n**试题B: 年号字串**\n**【问题描述】**\n\n**小明用字母A对应数字1, B对应2, 以此类推, 用Z对应26。对于27以上的数字, 小明用两位或者更长的字符串来对应, 例如AA对应27, AB对应28, AZ对应52, LQ对应329。**\n**请问2019对应的字符串是什么？**\n\n这一道题可以看按进制的方式来处理, 但是有几个注意点, 没有0这一数位, 每个字符只能代表1~26, 所以在取值和进位的时候多了一些限制。\n\n另外一些代码在用2019进行测试的时候, 是可以得到正确结果的, 但是如果传入的数对应的字符串存在Z或者邻近Z的情况, 会发现很容易出错, 因为这个原因我也改了挺久的代码。\n\n在计算该位最大取值的时候要算好后面位数可以取的最小值, 否则会出现当前位的字符的数值取完, 剩下的数比后面位数全取A时还小, 这样算法可能不会报错, 但是得出来的结果会比预想的大。\n\n下面是我的Java实现代码, 当然用Python也可以按照同样的思路来实现, 代码可以分为3个大步骤, 在关键的第3步可以分为3个小部分。\n\n```Java\npublic static String B(int num) {\n    // 步骤1\n    char[] S = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\n            'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'};\n    StringBuilder s = new StringBuilder();\n    int sub = 0;\n    // 步骤2\n    for (int count = 0; (Math.pow(26, sub + 1)) + count < num; count += Math.pow(26, sub)) sub++;\n    // 步骤3\n    while (sub >= 0) {\n        // 3.1\n        int fig = 1;\n        int POW = (int) Math.pow(26, sub);\n        int count = 0;\n        for (int i = sub - 1; i >= 0; i--) count += Math.pow(26, i);\n        // 3.2\n        while (num - POW * (fig + 1) >= (POW == 1 ? 0 : count)) fig++;\n        num = num - POW * fig;\n        // 3.3\n        s.append(S[fig - 1]);\n        sub--;\n    }\n    return s.toString();\n}\n```\n\n步骤1: 先初始化好存字符的数组、存字符串的StringBuildfer、以及存储位数的sub变量；\n步骤2: 计算这个数转化成字符串需要多少位个字符(多少位)；\n步骤3.1: 初始化好代表当前位数值的fig, 以及当前位1个fig代表多大的数, 通过for循环来获取当前位后面位数可以存储的最小和count, 以避免后面位数最小取值比剩余值大；\n步骤3.2: 通过循环计算fig可以取得最大值, 当前位不是最后一位时, 剩余值应当大于count, 当前位是最后一位时, 剩余值到达0停止；\n步骤3.3: 把当前位取值对应的字母添加到s里, 进入下一位的循环；\n最后返回s的字符串\n\n接下来传入测试数据来测试结果\n\n```Java\npublic static void main(String[] args){\n    int[] nums = {26, 27, 52, 329, 675, 676, 677, 702, 2019, 2027, 2028, 2029, 17575, 17576, 17577, 18278};\n    for (int num : nums) {\n        System.out.println(num + \"的转化结果\" + B(num));\n    }\n}\n```\n\n输出的结果应当如下所示:\n\n```Text\n26的转化结果Z\n27的转化结果AA\n52的转化结果AZ\n329的转化结果LQ\n675的转化结果YY\n676的转化结果YZ\n677的转化结果ZA\n702的转化结果ZZ\n2019的转化结果BYQ\n2027的转化结果BYY\n2028的转化结果BYZ\n2029的转化结果BZA\n17575的转化结果YYY\n17576的转化结果YYZ\n17577的转化结果YZA\n18278的转化结果ZZZ\n```\n","source":"_posts/蓝桥杯B组试题B：年号字串.md","raw":"---\ntitle: 蓝桥杯B组试题B:年号字串\ndate: 2020-2-6 \ncategories: 算法代码\ntags:\n    - Java\n---\n\n第十届蓝桥杯大赛软件类省赛C/C++大学B组\n**试题B: 年号字串**\n**【问题描述】**\n\n**小明用字母A对应数字1, B对应2, 以此类推, 用Z对应26。对于27以上的数字, 小明用两位或者更长的字符串来对应, 例如AA对应27, AB对应28, AZ对应52, LQ对应329。**\n**请问2019对应的字符串是什么？**\n\n这一道题可以看按进制的方式来处理, 但是有几个注意点, 没有0这一数位, 每个字符只能代表1~26, 所以在取值和进位的时候多了一些限制。\n\n另外一些代码在用2019进行测试的时候, 是可以得到正确结果的, 但是如果传入的数对应的字符串存在Z或者邻近Z的情况, 会发现很容易出错, 因为这个原因我也改了挺久的代码。\n\n在计算该位最大取值的时候要算好后面位数可以取的最小值, 否则会出现当前位的字符的数值取完, 剩下的数比后面位数全取A时还小, 这样算法可能不会报错, 但是得出来的结果会比预想的大。\n\n下面是我的Java实现代码, 当然用Python也可以按照同样的思路来实现, 代码可以分为3个大步骤, 在关键的第3步可以分为3个小部分。\n\n```Java\npublic static String B(int num) {\n    // 步骤1\n    char[] S = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\n            'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'};\n    StringBuilder s = new StringBuilder();\n    int sub = 0;\n    // 步骤2\n    for (int count = 0; (Math.pow(26, sub + 1)) + count < num; count += Math.pow(26, sub)) sub++;\n    // 步骤3\n    while (sub >= 0) {\n        // 3.1\n        int fig = 1;\n        int POW = (int) Math.pow(26, sub);\n        int count = 0;\n        for (int i = sub - 1; i >= 0; i--) count += Math.pow(26, i);\n        // 3.2\n        while (num - POW * (fig + 1) >= (POW == 1 ? 0 : count)) fig++;\n        num = num - POW * fig;\n        // 3.3\n        s.append(S[fig - 1]);\n        sub--;\n    }\n    return s.toString();\n}\n```\n\n步骤1: 先初始化好存字符的数组、存字符串的StringBuildfer、以及存储位数的sub变量；\n步骤2: 计算这个数转化成字符串需要多少位个字符(多少位)；\n步骤3.1: 初始化好代表当前位数值的fig, 以及当前位1个fig代表多大的数, 通过for循环来获取当前位后面位数可以存储的最小和count, 以避免后面位数最小取值比剩余值大；\n步骤3.2: 通过循环计算fig可以取得最大值, 当前位不是最后一位时, 剩余值应当大于count, 当前位是最后一位时, 剩余值到达0停止；\n步骤3.3: 把当前位取值对应的字母添加到s里, 进入下一位的循环；\n最后返回s的字符串\n\n接下来传入测试数据来测试结果\n\n```Java\npublic static void main(String[] args){\n    int[] nums = {26, 27, 52, 329, 675, 676, 677, 702, 2019, 2027, 2028, 2029, 17575, 17576, 17577, 18278};\n    for (int num : nums) {\n        System.out.println(num + \"的转化结果\" + B(num));\n    }\n}\n```\n\n输出的结果应当如下所示:\n\n```Text\n26的转化结果Z\n27的转化结果AA\n52的转化结果AZ\n329的转化结果LQ\n675的转化结果YY\n676的转化结果YZ\n677的转化结果ZA\n702的转化结果ZZ\n2019的转化结果BYQ\n2027的转化结果BYY\n2028的转化结果BYZ\n2029的转化结果BZA\n17575的转化结果YYY\n17576的转化结果YYZ\n17577的转化结果YZA\n18278的转化结果ZZZ\n```\n","slug":"蓝桥杯B组试题B：年号字串","published":1,"updated":"2020-02-06T09:41:02.587Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6ywriwd001b54v5bwc94at2","content":"<p>第十届蓝桥杯大赛软件类省赛C/C++大学B组<br><strong>试题B: 年号字串</strong><br><strong>【问题描述】</strong></p>\n<p><strong>小明用字母A对应数字1, B对应2, 以此类推, 用Z对应26。对于27以上的数字, 小明用两位或者更长的字符串来对应, 例如AA对应27, AB对应28, AZ对应52, LQ对应329。</strong><br><strong>请问2019对应的字符串是什么？</strong></p>\n<p>这一道题可以看按进制的方式来处理, 但是有几个注意点, 没有0这一数位, 每个字符只能代表1~26, 所以在取值和进位的时候多了一些限制。</p>\n<p>另外一些代码在用2019进行测试的时候, 是可以得到正确结果的, 但是如果传入的数对应的字符串存在Z或者邻近Z的情况, 会发现很容易出错, 因为这个原因我也改了挺久的代码。</p>\n<p>在计算该位最大取值的时候要算好后面位数可以取的最小值, 否则会出现当前位的字符的数值取完, 剩下的数比后面位数全取A时还小, 这样算法可能不会报错, 但是得出来的结果会比预想的大。</p>\n<p>下面是我的Java实现代码, 当然用Python也可以按照同样的思路来实现, 代码可以分为3个大步骤, 在关键的第3步可以分为3个小部分。</p>\n<pre><code class=\"Java\">public static String B(int num) {\n    // 步骤1\n    char[] S = {&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;, &#39;H&#39;, &#39;I&#39;, &#39;J&#39;, &#39;K&#39;, &#39;L&#39;, &#39;M&#39;, &#39;N&#39;,\n            &#39;O&#39;, &#39;P&#39;, &#39;Q&#39;, &#39;R&#39;, &#39;S&#39;, &#39;T&#39;, &#39;U&#39;, &#39;V&#39;, &#39;W&#39;, &#39;X&#39;, &#39;Y&#39;, &#39;Z&#39;};\n    StringBuilder s = new StringBuilder();\n    int sub = 0;\n    // 步骤2\n    for (int count = 0; (Math.pow(26, sub + 1)) + count &lt; num; count += Math.pow(26, sub)) sub++;\n    // 步骤3\n    while (sub &gt;= 0) {\n        // 3.1\n        int fig = 1;\n        int POW = (int) Math.pow(26, sub);\n        int count = 0;\n        for (int i = sub - 1; i &gt;= 0; i--) count += Math.pow(26, i);\n        // 3.2\n        while (num - POW * (fig + 1) &gt;= (POW == 1 ? 0 : count)) fig++;\n        num = num - POW * fig;\n        // 3.3\n        s.append(S[fig - 1]);\n        sub--;\n    }\n    return s.toString();\n}</code></pre>\n<p>步骤1: 先初始化好存字符的数组、存字符串的StringBuildfer、以及存储位数的sub变量；<br>步骤2: 计算这个数转化成字符串需要多少位个字符(多少位)；<br>步骤3.1: 初始化好代表当前位数值的fig, 以及当前位1个fig代表多大的数, 通过for循环来获取当前位后面位数可以存储的最小和count, 以避免后面位数最小取值比剩余值大；<br>步骤3.2: 通过循环计算fig可以取得最大值, 当前位不是最后一位时, 剩余值应当大于count, 当前位是最后一位时, 剩余值到达0停止；<br>步骤3.3: 把当前位取值对应的字母添加到s里, 进入下一位的循环；<br>最后返回s的字符串</p>\n<p>接下来传入测试数据来测试结果</p>\n<pre><code class=\"Java\">public static void main(String[] args){\n    int[] nums = {26, 27, 52, 329, 675, 676, 677, 702, 2019, 2027, 2028, 2029, 17575, 17576, 17577, 18278};\n    for (int num : nums) {\n        System.out.println(num + &quot;的转化结果&quot; + B(num));\n    }\n}</code></pre>\n<p>输出的结果应当如下所示:</p>\n<pre><code class=\"Text\">26的转化结果Z\n27的转化结果AA\n52的转化结果AZ\n329的转化结果LQ\n675的转化结果YY\n676的转化结果YZ\n677的转化结果ZA\n702的转化结果ZZ\n2019的转化结果BYQ\n2027的转化结果BYY\n2028的转化结果BYZ\n2029的转化结果BZA\n17575的转化结果YYY\n17576的转化结果YYZ\n17577的转化结果YZA\n18278的转化结果ZZZ</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>第十届蓝桥杯大赛软件类省赛C/C++大学B组<br><strong>试题B: 年号字串</strong><br><strong>【问题描述】</strong></p>\n<p><strong>小明用字母A对应数字1, B对应2, 以此类推, 用Z对应26。对于27以上的数字, 小明用两位或者更长的字符串来对应, 例如AA对应27, AB对应28, AZ对应52, LQ对应329。</strong><br><strong>请问2019对应的字符串是什么？</strong></p>\n<p>这一道题可以看按进制的方式来处理, 但是有几个注意点, 没有0这一数位, 每个字符只能代表1~26, 所以在取值和进位的时候多了一些限制。</p>\n<p>另外一些代码在用2019进行测试的时候, 是可以得到正确结果的, 但是如果传入的数对应的字符串存在Z或者邻近Z的情况, 会发现很容易出错, 因为这个原因我也改了挺久的代码。</p>\n<p>在计算该位最大取值的时候要算好后面位数可以取的最小值, 否则会出现当前位的字符的数值取完, 剩下的数比后面位数全取A时还小, 这样算法可能不会报错, 但是得出来的结果会比预想的大。</p>\n<p>下面是我的Java实现代码, 当然用Python也可以按照同样的思路来实现, 代码可以分为3个大步骤, 在关键的第3步可以分为3个小部分。</p>\n<pre><code class=\"Java\">public static String B(int num) {\n    // 步骤1\n    char[] S = {&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;, &#39;H&#39;, &#39;I&#39;, &#39;J&#39;, &#39;K&#39;, &#39;L&#39;, &#39;M&#39;, &#39;N&#39;,\n            &#39;O&#39;, &#39;P&#39;, &#39;Q&#39;, &#39;R&#39;, &#39;S&#39;, &#39;T&#39;, &#39;U&#39;, &#39;V&#39;, &#39;W&#39;, &#39;X&#39;, &#39;Y&#39;, &#39;Z&#39;};\n    StringBuilder s = new StringBuilder();\n    int sub = 0;\n    // 步骤2\n    for (int count = 0; (Math.pow(26, sub + 1)) + count &lt; num; count += Math.pow(26, sub)) sub++;\n    // 步骤3\n    while (sub &gt;= 0) {\n        // 3.1\n        int fig = 1;\n        int POW = (int) Math.pow(26, sub);\n        int count = 0;\n        for (int i = sub - 1; i &gt;= 0; i--) count += Math.pow(26, i);\n        // 3.2\n        while (num - POW * (fig + 1) &gt;= (POW == 1 ? 0 : count)) fig++;\n        num = num - POW * fig;\n        // 3.3\n        s.append(S[fig - 1]);\n        sub--;\n    }\n    return s.toString();\n}</code></pre>\n<p>步骤1: 先初始化好存字符的数组、存字符串的StringBuildfer、以及存储位数的sub变量；<br>步骤2: 计算这个数转化成字符串需要多少位个字符(多少位)；<br>步骤3.1: 初始化好代表当前位数值的fig, 以及当前位1个fig代表多大的数, 通过for循环来获取当前位后面位数可以存储的最小和count, 以避免后面位数最小取值比剩余值大；<br>步骤3.2: 通过循环计算fig可以取得最大值, 当前位不是最后一位时, 剩余值应当大于count, 当前位是最后一位时, 剩余值到达0停止；<br>步骤3.3: 把当前位取值对应的字母添加到s里, 进入下一位的循环；<br>最后返回s的字符串</p>\n<p>接下来传入测试数据来测试结果</p>\n<pre><code class=\"Java\">public static void main(String[] args){\n    int[] nums = {26, 27, 52, 329, 675, 676, 677, 702, 2019, 2027, 2028, 2029, 17575, 17576, 17577, 18278};\n    for (int num : nums) {\n        System.out.println(num + &quot;的转化结果&quot; + B(num));\n    }\n}</code></pre>\n<p>输出的结果应当如下所示:</p>\n<pre><code class=\"Text\">26的转化结果Z\n27的转化结果AA\n52的转化结果AZ\n329的转化结果LQ\n675的转化结果YY\n676的转化结果YZ\n677的转化结果ZA\n702的转化结果ZZ\n2019的转化结果BYQ\n2027的转化结果BYY\n2028的转化结果BYZ\n2029的转化结果BZA\n17575的转化结果YYY\n17576的转化结果YYZ\n17577的转化结果YZA\n18278的转化结果ZZZ</code></pre>\n"},{"title":"闲着没事造轮子2020/1/30","date":"2020-01-29T18:30:00.000Z","_content":"\n**造轮子背景**\n---\n\n1、之前在开发新年祝福专栏的网页的时候，使用PyMySQL连接数据库，把一些操作给简化和封装了一下\n2、在对文章进行排序的时候，记得list有一个sort函数可以使用，但是我列表里元素类型都是dict，就想着要是有简化对内嵌了其它类型元素的列表操作的工具包就好了\n3、2020新年这段期间是新型冠状病毒2019-nCoV在人与人间传染的非常时期，外出不得，闲着没事干(虽然有人陪我玩游戏)\n4、最近看着空荡荡没有一个开源仓库的GitHub账号，想填充一下GitHub仓库\n**接着，我的造轮子之路开始了**\n\n**Web-MySQL**\n---\n\n一个基于PyMySQL构建出来的简化数据库操作的连接工具，简化是简化了，看起来好像没什么太大意义。\n\n介绍：[基于PyMySQL构建的Web-MySQL](https://www.arukione.com/2020/01/29/%E5%9F%BA%E4%BA%8EPyMySQL%E6%9E%84%E5%BB%BA%E7%9A%84Web-MySQL/)\n\n**NestedList**\n---\n\n一个基于operator构建出来的一个可以对内嵌列表操作的库。\n\n介绍：[基于operator构建的Nest-List](https://www.arukione.com/2020/01/30/%E5%9F%BA%E4%BA%8Eoperator%E6%9E%84%E5%BB%BA%E7%9A%84Nested-List/)\n\n**感谢**\n---\n\n这两个轮子的开发要感谢PyMySQL的开发者和《Python Cookbook》3rd Edition翻译者，开发期间在引用代码和查找资料的时候给了我巨大的帮助，Nested-List的1.0.0版本代码的开发就是在《Python Cookbook》教程中得到的启发。虽然只是短短的几天时间，我却学习到了很多东西。\n\n**相关链接：**\nPyMySQL：[https://github.com/PyMySQL/PyMySQL](https://github.com/PyMySQL/PyMySQL)\nPython Cookbook 3rd Edition：[https://python3-cookbook.readthedocs.io/zh_CN/latest/index.html](https://python3-cookbook.readthedocs.io/zh_CN/latest/index.html\n)\n\n**闲着没事**\n---\n\n其实也不是闲着没事，至少打包后我自己也可以用，不用老是写重复的代码。打包开源也有利于我成长~~\n\n也许，做着做着，就变成大佬了也说不定(想peach)\n","source":"_posts/闲着没事造轮子.md","raw":"---\ntitle: 闲着没事造轮子2020/1/30\ndate: 2020/1/30 2:30\ncategories: 开发记录\n---\n\n**造轮子背景**\n---\n\n1、之前在开发新年祝福专栏的网页的时候，使用PyMySQL连接数据库，把一些操作给简化和封装了一下\n2、在对文章进行排序的时候，记得list有一个sort函数可以使用，但是我列表里元素类型都是dict，就想着要是有简化对内嵌了其它类型元素的列表操作的工具包就好了\n3、2020新年这段期间是新型冠状病毒2019-nCoV在人与人间传染的非常时期，外出不得，闲着没事干(虽然有人陪我玩游戏)\n4、最近看着空荡荡没有一个开源仓库的GitHub账号，想填充一下GitHub仓库\n**接着，我的造轮子之路开始了**\n\n**Web-MySQL**\n---\n\n一个基于PyMySQL构建出来的简化数据库操作的连接工具，简化是简化了，看起来好像没什么太大意义。\n\n介绍：[基于PyMySQL构建的Web-MySQL](https://www.arukione.com/2020/01/29/%E5%9F%BA%E4%BA%8EPyMySQL%E6%9E%84%E5%BB%BA%E7%9A%84Web-MySQL/)\n\n**NestedList**\n---\n\n一个基于operator构建出来的一个可以对内嵌列表操作的库。\n\n介绍：[基于operator构建的Nest-List](https://www.arukione.com/2020/01/30/%E5%9F%BA%E4%BA%8Eoperator%E6%9E%84%E5%BB%BA%E7%9A%84Nested-List/)\n\n**感谢**\n---\n\n这两个轮子的开发要感谢PyMySQL的开发者和《Python Cookbook》3rd Edition翻译者，开发期间在引用代码和查找资料的时候给了我巨大的帮助，Nested-List的1.0.0版本代码的开发就是在《Python Cookbook》教程中得到的启发。虽然只是短短的几天时间，我却学习到了很多东西。\n\n**相关链接：**\nPyMySQL：[https://github.com/PyMySQL/PyMySQL](https://github.com/PyMySQL/PyMySQL)\nPython Cookbook 3rd Edition：[https://python3-cookbook.readthedocs.io/zh_CN/latest/index.html](https://python3-cookbook.readthedocs.io/zh_CN/latest/index.html\n)\n\n**闲着没事**\n---\n\n其实也不是闲着没事，至少打包后我自己也可以用，不用老是写重复的代码。打包开源也有利于我成长~~\n\n也许，做着做着，就变成大佬了也说不定(想peach)\n","slug":"闲着没事造轮子","published":1,"updated":"2020-01-30T18:09:26.726Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6ywriwe001f54v51c046aha","content":"<h2 id=\"造轮子背景\"><a href=\"#造轮子背景\" class=\"headerlink\" title=\"造轮子背景\"></a><strong>造轮子背景</strong></h2><p>1、之前在开发新年祝福专栏的网页的时候，使用PyMySQL连接数据库，把一些操作给简化和封装了一下<br>2、在对文章进行排序的时候，记得list有一个sort函数可以使用，但是我列表里元素类型都是dict，就想着要是有简化对内嵌了其它类型元素的列表操作的工具包就好了<br>3、2020新年这段期间是新型冠状病毒2019-nCoV在人与人间传染的非常时期，外出不得，闲着没事干(虽然有人陪我玩游戏)<br>4、最近看着空荡荡没有一个开源仓库的GitHub账号，想填充一下GitHub仓库<br><strong>接着，我的造轮子之路开始了</strong></p>\n<h2 id=\"Web-MySQL\"><a href=\"#Web-MySQL\" class=\"headerlink\" title=\"Web-MySQL\"></a><strong>Web-MySQL</strong></h2><p>一个基于PyMySQL构建出来的简化数据库操作的连接工具，简化是简化了，看起来好像没什么太大意义。</p>\n<p>介绍：<a href=\"https://www.arukione.com/2020/01/29/%E5%9F%BA%E4%BA%8EPyMySQL%E6%9E%84%E5%BB%BA%E7%9A%84Web-MySQL/\" target=\"_blank\" rel=\"noopener\">基于PyMySQL构建的Web-MySQL</a></p>\n<h2 id=\"NestedList\"><a href=\"#NestedList\" class=\"headerlink\" title=\"NestedList\"></a><strong>NestedList</strong></h2><p>一个基于operator构建出来的一个可以对内嵌列表操作的库。</p>\n<p>介绍：<a href=\"https://www.arukione.com/2020/01/30/%E5%9F%BA%E4%BA%8Eoperator%E6%9E%84%E5%BB%BA%E7%9A%84Nested-List/\" target=\"_blank\" rel=\"noopener\">基于operator构建的Nest-List</a></p>\n<h2 id=\"感谢\"><a href=\"#感谢\" class=\"headerlink\" title=\"感谢\"></a><strong>感谢</strong></h2><p>这两个轮子的开发要感谢PyMySQL的开发者和《Python Cookbook》3rd Edition翻译者，开发期间在引用代码和查找资料的时候给了我巨大的帮助，Nested-List的1.0.0版本代码的开发就是在《Python Cookbook》教程中得到的启发。虽然只是短短的几天时间，我却学习到了很多东西。</p>\n<p><strong>相关链接：</strong><br>PyMySQL：<a href=\"https://github.com/PyMySQL/PyMySQL\" target=\"_blank\" rel=\"noopener\">https://github.com/PyMySQL/PyMySQL</a><br>Python Cookbook 3rd Edition：<a href=\"https://python3-cookbook.readthedocs.io/zh_CN/latest/index.html\" target=\"_blank\" rel=\"noopener\">https://python3-cookbook.readthedocs.io/zh_CN/latest/index.html</a></p>\n<h2 id=\"闲着没事\"><a href=\"#闲着没事\" class=\"headerlink\" title=\"闲着没事\"></a><strong>闲着没事</strong></h2><p>其实也不是闲着没事，至少打包后我自己也可以用，不用老是写重复的代码。打包开源也有利于我成长~~</p>\n<p>也许，做着做着，就变成大佬了也说不定(想peach)</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"造轮子背景\"><a href=\"#造轮子背景\" class=\"headerlink\" title=\"造轮子背景\"></a><strong>造轮子背景</strong></h2><p>1、之前在开发新年祝福专栏的网页的时候，使用PyMySQL连接数据库，把一些操作给简化和封装了一下<br>2、在对文章进行排序的时候，记得list有一个sort函数可以使用，但是我列表里元素类型都是dict，就想着要是有简化对内嵌了其它类型元素的列表操作的工具包就好了<br>3、2020新年这段期间是新型冠状病毒2019-nCoV在人与人间传染的非常时期，外出不得，闲着没事干(虽然有人陪我玩游戏)<br>4、最近看着空荡荡没有一个开源仓库的GitHub账号，想填充一下GitHub仓库<br><strong>接着，我的造轮子之路开始了</strong></p>\n<h2 id=\"Web-MySQL\"><a href=\"#Web-MySQL\" class=\"headerlink\" title=\"Web-MySQL\"></a><strong>Web-MySQL</strong></h2><p>一个基于PyMySQL构建出来的简化数据库操作的连接工具，简化是简化了，看起来好像没什么太大意义。</p>\n<p>介绍：<a href=\"https://www.arukione.com/2020/01/29/%E5%9F%BA%E4%BA%8EPyMySQL%E6%9E%84%E5%BB%BA%E7%9A%84Web-MySQL/\" target=\"_blank\" rel=\"noopener\">基于PyMySQL构建的Web-MySQL</a></p>\n<h2 id=\"NestedList\"><a href=\"#NestedList\" class=\"headerlink\" title=\"NestedList\"></a><strong>NestedList</strong></h2><p>一个基于operator构建出来的一个可以对内嵌列表操作的库。</p>\n<p>介绍：<a href=\"https://www.arukione.com/2020/01/30/%E5%9F%BA%E4%BA%8Eoperator%E6%9E%84%E5%BB%BA%E7%9A%84Nested-List/\" target=\"_blank\" rel=\"noopener\">基于operator构建的Nest-List</a></p>\n<h2 id=\"感谢\"><a href=\"#感谢\" class=\"headerlink\" title=\"感谢\"></a><strong>感谢</strong></h2><p>这两个轮子的开发要感谢PyMySQL的开发者和《Python Cookbook》3rd Edition翻译者，开发期间在引用代码和查找资料的时候给了我巨大的帮助，Nested-List的1.0.0版本代码的开发就是在《Python Cookbook》教程中得到的启发。虽然只是短短的几天时间，我却学习到了很多东西。</p>\n<p><strong>相关链接：</strong><br>PyMySQL：<a href=\"https://github.com/PyMySQL/PyMySQL\" target=\"_blank\" rel=\"noopener\">https://github.com/PyMySQL/PyMySQL</a><br>Python Cookbook 3rd Edition：<a href=\"https://python3-cookbook.readthedocs.io/zh_CN/latest/index.html\" target=\"_blank\" rel=\"noopener\">https://python3-cookbook.readthedocs.io/zh_CN/latest/index.html</a></p>\n<h2 id=\"闲着没事\"><a href=\"#闲着没事\" class=\"headerlink\" title=\"闲着没事\"></a><strong>闲着没事</strong></h2><p>其实也不是闲着没事，至少打包后我自己也可以用，不用老是写重复的代码。打包开源也有利于我成长~~</p>\n<p>也许，做着做着，就变成大佬了也说不定(想peach)</p>\n"},{"title":"2020.2.25 SpringBoot学习笔记","date":"2020-02-25T15:44:00.000Z","_content":"\n## 用IDEA新建一个带数据库依赖的spring boot web项目后运行出错\n\n**运行报错内容如下：**\n\n```Java\nDescription:\n\nFailed to configure a DataSource: 'url' attribute is not specified and no embedded datasource could be configured.\n\nReason: Failed to determine a suitable driver class\n\n\nAction:\n\nConsider the following:\n If you want an embedded database (H2, HSQL or Derby), please put it on the classpath.\n If you have database settings to be loaded from a particular profile you may need to activate it (no profiles are currently active).\n```\n\n上面的报错内容是说DataSource(数据源)配置错误: url没有配置并且嵌入数据源没有配置\n其实就是没有在配置文件里面配置数据库信息\n\n**解决方法：**\n\n在SpringBoot配置文件里面配置数据源就好了, 但是刚开始学习不知道怎么配置数据源, 可以使用另外一种方法, 忽略web项目的数据库依赖, 也就是项目入口注解那里加上exclude传输, 如下:\n\n```Java\n@SpringBootApplication(exclude = DataSourceAutoConfiguration.class)\n```\n\n## 配置thymeleaf3无法正常使用\n\n修改thymeleaf版本是在properties里修改thymeleaf.version和thymeleaf-layout-dialect.version, 但是配置完发现没办法正常使用模板引擎\n\n后来去GitHub查了一下依赖的版本, 把版本都改成新的才解决了这个问题, 所以我认为应该是thymeleaf的布局依赖的版本的问题\n\n```xml\n<thymeleaf.version>3.0.11.RELEASE</thymeleaf.version>\n<thymeleaf-layout-dialect.version>2.4.0</thymeleaf-layout-dialect.version>\n```\n\nGitHub发行地址\n<https://github.com/thymeleaf/thymeleaf/releases>\n<https://github.com/ultraq/thymeleaf-layout-dialect/releases>\n","source":"_posts/2020.2.25 SpringBoot学习笔记.md","raw":"---\ntitle: 2020.2.25 SpringBoot学习笔记\ndate: 2020-2-25 23:44\ncategories: 学习笔记\ntags:\n    - Java\n    - spring-projects\n---\n\n## 用IDEA新建一个带数据库依赖的spring boot web项目后运行出错\n\n**运行报错内容如下：**\n\n```Java\nDescription:\n\nFailed to configure a DataSource: 'url' attribute is not specified and no embedded datasource could be configured.\n\nReason: Failed to determine a suitable driver class\n\n\nAction:\n\nConsider the following:\n If you want an embedded database (H2, HSQL or Derby), please put it on the classpath.\n If you have database settings to be loaded from a particular profile you may need to activate it (no profiles are currently active).\n```\n\n上面的报错内容是说DataSource(数据源)配置错误: url没有配置并且嵌入数据源没有配置\n其实就是没有在配置文件里面配置数据库信息\n\n**解决方法：**\n\n在SpringBoot配置文件里面配置数据源就好了, 但是刚开始学习不知道怎么配置数据源, 可以使用另外一种方法, 忽略web项目的数据库依赖, 也就是项目入口注解那里加上exclude传输, 如下:\n\n```Java\n@SpringBootApplication(exclude = DataSourceAutoConfiguration.class)\n```\n\n## 配置thymeleaf3无法正常使用\n\n修改thymeleaf版本是在properties里修改thymeleaf.version和thymeleaf-layout-dialect.version, 但是配置完发现没办法正常使用模板引擎\n\n后来去GitHub查了一下依赖的版本, 把版本都改成新的才解决了这个问题, 所以我认为应该是thymeleaf的布局依赖的版本的问题\n\n```xml\n<thymeleaf.version>3.0.11.RELEASE</thymeleaf.version>\n<thymeleaf-layout-dialect.version>2.4.0</thymeleaf-layout-dialect.version>\n```\n\nGitHub发行地址\n<https://github.com/thymeleaf/thymeleaf/releases>\n<https://github.com/ultraq/thymeleaf-layout-dialect/releases>\n","slug":"2020.2.25 SpringBoot学习笔记","published":1,"updated":"2020-02-25T15:44:11.886Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck722drh1000034v54s7y9bm1","content":"<h2 id=\"用IDEA新建一个带数据库依赖的spring-boot-web项目后运行出错\"><a href=\"#用IDEA新建一个带数据库依赖的spring-boot-web项目后运行出错\" class=\"headerlink\" title=\"用IDEA新建一个带数据库依赖的spring boot web项目后运行出错\"></a>用IDEA新建一个带数据库依赖的spring boot web项目后运行出错</h2><p><strong>运行报错内容如下：</strong></p>\n<pre><code class=\"Java\">Description:\n\nFailed to configure a DataSource: &#39;url&#39; attribute is not specified and no embedded datasource could be configured.\n\nReason: Failed to determine a suitable driver class\n\n\nAction:\n\nConsider the following:\n If you want an embedded database (H2, HSQL or Derby), please put it on the classpath.\n If you have database settings to be loaded from a particular profile you may need to activate it (no profiles are currently active).</code></pre>\n<p>上面的报错内容是说DataSource(数据源)配置错误: url没有配置并且嵌入数据源没有配置<br>其实就是没有在配置文件里面配置数据库信息</p>\n<p><strong>解决方法：</strong></p>\n<p>在SpringBoot配置文件里面配置数据源就好了, 但是刚开始学习不知道怎么配置数据源, 可以使用另外一种方法, 忽略web项目的数据库依赖, 也就是项目入口注解那里加上exclude传输, 如下:</p>\n<pre><code class=\"Java\">@SpringBootApplication(exclude = DataSourceAutoConfiguration.class)</code></pre>\n<h2 id=\"配置thymeleaf3无法正常使用\"><a href=\"#配置thymeleaf3无法正常使用\" class=\"headerlink\" title=\"配置thymeleaf3无法正常使用\"></a>配置thymeleaf3无法正常使用</h2><p>修改thymeleaf版本是在properties里修改thymeleaf.version和thymeleaf-layout-dialect.version, 但是配置完发现没办法正常使用模板引擎</p>\n<p>后来去GitHub查了一下依赖的版本, 把版本都改成新的才解决了这个问题, 所以我认为应该是thymeleaf的布局依赖的版本的问题</p>\n<pre><code class=\"xml\">&lt;thymeleaf.version&gt;3.0.11.RELEASE&lt;/thymeleaf.version&gt;\n&lt;thymeleaf-layout-dialect.version&gt;2.4.0&lt;/thymeleaf-layout-dialect.version&gt;</code></pre>\n<p>GitHub发行地址<br><a href=\"https://github.com/thymeleaf/thymeleaf/releases\" target=\"_blank\" rel=\"noopener\">https://github.com/thymeleaf/thymeleaf/releases</a><br><a href=\"https://github.com/ultraq/thymeleaf-layout-dialect/releases\" target=\"_blank\" rel=\"noopener\">https://github.com/ultraq/thymeleaf-layout-dialect/releases</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"用IDEA新建一个带数据库依赖的spring-boot-web项目后运行出错\"><a href=\"#用IDEA新建一个带数据库依赖的spring-boot-web项目后运行出错\" class=\"headerlink\" title=\"用IDEA新建一个带数据库依赖的spring boot web项目后运行出错\"></a>用IDEA新建一个带数据库依赖的spring boot web项目后运行出错</h2><p><strong>运行报错内容如下：</strong></p>\n<pre><code class=\"Java\">Description:\n\nFailed to configure a DataSource: &#39;url&#39; attribute is not specified and no embedded datasource could be configured.\n\nReason: Failed to determine a suitable driver class\n\n\nAction:\n\nConsider the following:\n If you want an embedded database (H2, HSQL or Derby), please put it on the classpath.\n If you have database settings to be loaded from a particular profile you may need to activate it (no profiles are currently active).</code></pre>\n<p>上面的报错内容是说DataSource(数据源)配置错误: url没有配置并且嵌入数据源没有配置<br>其实就是没有在配置文件里面配置数据库信息</p>\n<p><strong>解决方法：</strong></p>\n<p>在SpringBoot配置文件里面配置数据源就好了, 但是刚开始学习不知道怎么配置数据源, 可以使用另外一种方法, 忽略web项目的数据库依赖, 也就是项目入口注解那里加上exclude传输, 如下:</p>\n<pre><code class=\"Java\">@SpringBootApplication(exclude = DataSourceAutoConfiguration.class)</code></pre>\n<h2 id=\"配置thymeleaf3无法正常使用\"><a href=\"#配置thymeleaf3无法正常使用\" class=\"headerlink\" title=\"配置thymeleaf3无法正常使用\"></a>配置thymeleaf3无法正常使用</h2><p>修改thymeleaf版本是在properties里修改thymeleaf.version和thymeleaf-layout-dialect.version, 但是配置完发现没办法正常使用模板引擎</p>\n<p>后来去GitHub查了一下依赖的版本, 把版本都改成新的才解决了这个问题, 所以我认为应该是thymeleaf的布局依赖的版本的问题</p>\n<pre><code class=\"xml\">&lt;thymeleaf.version&gt;3.0.11.RELEASE&lt;/thymeleaf.version&gt;\n&lt;thymeleaf-layout-dialect.version&gt;2.4.0&lt;/thymeleaf-layout-dialect.version&gt;</code></pre>\n<p>GitHub发行地址<br><a href=\"https://github.com/thymeleaf/thymeleaf/releases\" target=\"_blank\" rel=\"noopener\">https://github.com/thymeleaf/thymeleaf/releases</a><br><a href=\"https://github.com/ultraq/thymeleaf-layout-dialect/releases\" target=\"_blank\" rel=\"noopener\">https://github.com/ultraq/thymeleaf-layout-dialect/releases</a></p>\n"},{"title":"2020新年的ナナスタ","date":"2020-02-22T16:00:00.000Z","_content":"\n**这是爱和信仰**\n**留作纪念❤**\n\n**看完了[EPISODE 5.0 -Fall in Love-]了**\n这剧情太让人感动了, t7s最近几个故事都很感人\n尤其是白雪在说码农那一段, 我眼睛都泛出泪水了\n保存了结尾封面, 吹爆茂木\n![E5-1](/images/t7s2020/E5-1.jpg)\n![E5-2](/images/t7s2020/E5-2.jpg)\n![E5-3](/images/t7s2020/E5-3.jpg)\n\n**2020年2月19日ナナスタ六周年了**\n本来想着六周年会送5k或者6k星星的, 去年还送了P卷, 今年居然什么都没有, 倒是公布了一个惊人的消息...\n\n毛姆来了一封信\n\n![letter](/images/t7s2020/letter.jpg)\n\n**你7动画化了！**\n以前群友每天都在开玩笑你7火了, 你7动画化了啊, 没想到动画化这一天真的来的\n\n2020年夏天, 东映制作的70分钟剧场版, シリーズ完结篇 EPISODE 6.0, 非常期待\n官方置顶推文: <https://twitter.com/t7s_staff/status/1230069558137876480?s=20>\n官方推文特报: <https://twitter.com/t7s_staff/status/1230401725057470465?s=20>\n宣传视频: <https://www.youtube.com/watch?v=wHblFQVYc2c&feature=youtu.be>\n\n宣传后游戏内也送了5000星, 算是补了周年的？\n\n另一个是消息ハル进了限定池了, 7%的P率, 抽了一发后确信是假概率。\n777和传奇组一样进限定池,是不是也意味着2043的到来, 777也成为过去了, 舍不得老婆カジカ啊, 上次生日池4步后还走了2步EX, 结果还是没出第二张BD, 早知道PJoker可以觉醒BD就不抽了, 浪费星星。\n\n群里大佬抓出来的游戏封面图\n\n![2014](/images/t7s2020/KV-2014.jpg)\n![2015](/images/t7s2020/KV-2015.jpg)\n![2017](/images/t7s2020/KV-2017.jpg)\n![2020](/images/t7s2020/KV-2020.jpg)\n","source":"_posts/2020新年的t7s.md","raw":"---\ntitle: 2020新年的ナナスタ\ndate: 2020-2-23\ncategories: 生活日常\n---\n\n**这是爱和信仰**\n**留作纪念❤**\n\n**看完了[EPISODE 5.0 -Fall in Love-]了**\n这剧情太让人感动了, t7s最近几个故事都很感人\n尤其是白雪在说码农那一段, 我眼睛都泛出泪水了\n保存了结尾封面, 吹爆茂木\n![E5-1](/images/t7s2020/E5-1.jpg)\n![E5-2](/images/t7s2020/E5-2.jpg)\n![E5-3](/images/t7s2020/E5-3.jpg)\n\n**2020年2月19日ナナスタ六周年了**\n本来想着六周年会送5k或者6k星星的, 去年还送了P卷, 今年居然什么都没有, 倒是公布了一个惊人的消息...\n\n毛姆来了一封信\n\n![letter](/images/t7s2020/letter.jpg)\n\n**你7动画化了！**\n以前群友每天都在开玩笑你7火了, 你7动画化了啊, 没想到动画化这一天真的来的\n\n2020年夏天, 东映制作的70分钟剧场版, シリーズ完结篇 EPISODE 6.0, 非常期待\n官方置顶推文: <https://twitter.com/t7s_staff/status/1230069558137876480?s=20>\n官方推文特报: <https://twitter.com/t7s_staff/status/1230401725057470465?s=20>\n宣传视频: <https://www.youtube.com/watch?v=wHblFQVYc2c&feature=youtu.be>\n\n宣传后游戏内也送了5000星, 算是补了周年的？\n\n另一个是消息ハル进了限定池了, 7%的P率, 抽了一发后确信是假概率。\n777和传奇组一样进限定池,是不是也意味着2043的到来, 777也成为过去了, 舍不得老婆カジカ啊, 上次生日池4步后还走了2步EX, 结果还是没出第二张BD, 早知道PJoker可以觉醒BD就不抽了, 浪费星星。\n\n群里大佬抓出来的游戏封面图\n\n![2014](/images/t7s2020/KV-2014.jpg)\n![2015](/images/t7s2020/KV-2015.jpg)\n![2017](/images/t7s2020/KV-2017.jpg)\n![2020](/images/t7s2020/KV-2020.jpg)\n","slug":"2020新年的t7s","published":1,"updated":"2020-02-29T15:41:31.816Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck77ryp2k00003sv58i968vod","content":"<p><strong>这是爱和信仰</strong><br><strong>留作纪念❤</strong></p>\n<p><strong>看完了[EPISODE 5.0 -Fall in Love-]了</strong><br>这剧情太让人感动了, t7s最近几个故事都很感人<br>尤其是白雪在说码农那一段, 我眼睛都泛出泪水了<br>保存了结尾封面, 吹爆茂木<br><img src=\"/images/t7s2020/E5-1.jpg\" alt=\"E5-1\"><br><img src=\"/images/t7s2020/E5-2.jpg\" alt=\"E5-2\"><br><img src=\"/images/t7s2020/E5-3.jpg\" alt=\"E5-3\"></p>\n<p><strong>2020年2月19日ナナスタ六周年了</strong><br>本来想着六周年会送5k或者6k星星的, 去年还送了P卷, 今年居然什么都没有, 倒是公布了一个惊人的消息…</p>\n<p>毛姆来了一封信</p>\n<p><img src=\"/images/t7s2020/letter.jpg\" alt=\"letter\"></p>\n<p><strong>你7动画化了！</strong><br>以前群友每天都在开玩笑你7火了, 你7动画化了啊, 没想到动画化这一天真的来的</p>\n<p>2020年夏天, 东映制作的70分钟剧场版, シリーズ完结篇 EPISODE 6.0, 非常期待<br>官方置顶推文: <a href=\"https://twitter.com/t7s_staff/status/1230069558137876480?s=20\" target=\"_blank\" rel=\"noopener\">https://twitter.com/t7s_staff/status/1230069558137876480?s=20</a><br>官方推文特报: <a href=\"https://twitter.com/t7s_staff/status/1230401725057470465?s=20\" target=\"_blank\" rel=\"noopener\">https://twitter.com/t7s_staff/status/1230401725057470465?s=20</a><br>宣传视频: <a href=\"https://www.youtube.com/watch?v=wHblFQVYc2c&amp;feature=youtu.be\" target=\"_blank\" rel=\"noopener\">https://www.youtube.com/watch?v=wHblFQVYc2c&amp;feature=youtu.be</a></p>\n<p>宣传后游戏内也送了5000星, 算是补了周年的？</p>\n<p>另一个是消息ハル进了限定池了, 7%的P率, 抽了一发后确信是假概率。<br>777和传奇组一样进限定池,是不是也意味着2043的到来, 777也成为过去了, 舍不得老婆カジカ啊, 上次生日池4步后还走了2步EX, 结果还是没出第二张BD, 早知道PJoker可以觉醒BD就不抽了, 浪费星星。</p>\n<p>群里大佬抓出来的游戏封面图</p>\n<p><img src=\"/images/t7s2020/KV-2014.jpg\" alt=\"2014\"><br><img src=\"/images/t7s2020/KV-2015.jpg\" alt=\"2015\"><br><img src=\"/images/t7s2020/KV-2017.jpg\" alt=\"2017\"><br><img src=\"/images/t7s2020/KV-2020.jpg\" alt=\"2020\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>这是爱和信仰</strong><br><strong>留作纪念❤</strong></p>\n<p><strong>看完了[EPISODE 5.0 -Fall in Love-]了</strong><br>这剧情太让人感动了, t7s最近几个故事都很感人<br>尤其是白雪在说码农那一段, 我眼睛都泛出泪水了<br>保存了结尾封面, 吹爆茂木<br><img src=\"/images/t7s2020/E5-1.jpg\" alt=\"E5-1\"><br><img src=\"/images/t7s2020/E5-2.jpg\" alt=\"E5-2\"><br><img src=\"/images/t7s2020/E5-3.jpg\" alt=\"E5-3\"></p>\n<p><strong>2020年2月19日ナナスタ六周年了</strong><br>本来想着六周年会送5k或者6k星星的, 去年还送了P卷, 今年居然什么都没有, 倒是公布了一个惊人的消息…</p>\n<p>毛姆来了一封信</p>\n<p><img src=\"/images/t7s2020/letter.jpg\" alt=\"letter\"></p>\n<p><strong>你7动画化了！</strong><br>以前群友每天都在开玩笑你7火了, 你7动画化了啊, 没想到动画化这一天真的来的</p>\n<p>2020年夏天, 东映制作的70分钟剧场版, シリーズ完结篇 EPISODE 6.0, 非常期待<br>官方置顶推文: <a href=\"https://twitter.com/t7s_staff/status/1230069558137876480?s=20\" target=\"_blank\" rel=\"noopener\">https://twitter.com/t7s_staff/status/1230069558137876480?s=20</a><br>官方推文特报: <a href=\"https://twitter.com/t7s_staff/status/1230401725057470465?s=20\" target=\"_blank\" rel=\"noopener\">https://twitter.com/t7s_staff/status/1230401725057470465?s=20</a><br>宣传视频: <a href=\"https://www.youtube.com/watch?v=wHblFQVYc2c&amp;feature=youtu.be\" target=\"_blank\" rel=\"noopener\">https://www.youtube.com/watch?v=wHblFQVYc2c&amp;feature=youtu.be</a></p>\n<p>宣传后游戏内也送了5000星, 算是补了周年的？</p>\n<p>另一个是消息ハル进了限定池了, 7%的P率, 抽了一发后确信是假概率。<br>777和传奇组一样进限定池,是不是也意味着2043的到来, 777也成为过去了, 舍不得老婆カジカ啊, 上次生日池4步后还走了2步EX, 结果还是没出第二张BD, 早知道PJoker可以觉醒BD就不抽了, 浪费星星。</p>\n<p>群里大佬抓出来的游戏封面图</p>\n<p><img src=\"/images/t7s2020/KV-2014.jpg\" alt=\"2014\"><br><img src=\"/images/t7s2020/KV-2015.jpg\" alt=\"2015\"><br><img src=\"/images/t7s2020/KV-2017.jpg\" alt=\"2017\"><br><img src=\"/images/t7s2020/KV-2020.jpg\" alt=\"2020\"></p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"ck6ywrivg000154v5hego4oeq","category_id":"ck6ywrivk000354v56h050jng","_id":"ck6ywrivv000e54v58c2be62g"},{"post_id":"ck6ywrivj000254v55naf1bqj","category_id":"ck6ywrivk000354v56h050jng","_id":"ck6ywrivy000k54v5b3px8r2g"},{"post_id":"ck6ywrivn000554v5h3se6cwf","category_id":"ck6ywrivk000354v56h050jng","_id":"ck6ywriw2000p54v5ahge3422"},{"post_id":"ck6ywrivy000m54v5d1rkhcmr","category_id":"ck6ywrivx000j54v5hsfxf9lu","_id":"ck6ywriw6000w54v5ansd1lxh"},{"post_id":"ck6ywrivo000654v5ct5fge4x","category_id":"ck6ywrivx000j54v5hsfxf9lu","_id":"ck6ywriw9001154v58ekr79sl"},{"post_id":"ck6ywriw1000o54v53mkg8h5o","category_id":"ck6ywrivk000354v56h050jng","_id":"ck6ywriwb001454v53fic5uek"},{"post_id":"ck6ywriw3000t54v5944odmqd","category_id":"ck6ywrivx000j54v5hsfxf9lu","_id":"ck6ywriwc001854v5a3wv7m9m"},{"post_id":"ck6ywriw6000v54v55d6t0v4r","category_id":"ck6ywrivk000354v56h050jng","_id":"ck6ywriwf001g54v52kh786zq"},{"post_id":"ck6ywriw8001054v586xee192","category_id":"ck6ywrivk000354v56h050jng","_id":"ck6ywriwg001j54v5b9086kx1"},{"post_id":"ck6ywrivs000b54v5gv6u6src","category_id":"ck6ywrivx000j54v5hsfxf9lu","_id":"ck6ywriwg001m54v57j1yfyd0"},{"post_id":"ck6ywrivu000c54v5239j62nt","category_id":"ck6ywriwb001554v54e1jbeth","_id":"ck6ywriwh001p54v506n80ga3"},{"post_id":"ck6ywriwe001f54v51c046aha","category_id":"ck6ywriwb001554v54e1jbeth","_id":"ck6ywriwi001s54v5atpv67o2"},{"post_id":"ck6ywrivv000g54v5fi933jd3","category_id":"ck6ywriw2000q54v59xod7ubv","_id":"ck6ywriwi001t54v59g14czy4"},{"post_id":"ck6ywrivx000i54v55l4bchn9","category_id":"ck6ywrivx000j54v5hsfxf9lu","_id":"ck6ywriwj001v54v5ajzr745s"},{"post_id":"ck6ywriwa001354v5cwpzdw1v","category_id":"ck6ywriwh001r54v58hvdfb9m","_id":"ck6ywriwk001z54v5g49o7cu1"},{"post_id":"ck6ywriwc001754v5dvo5atvv","category_id":"ck6ywriwh001r54v58hvdfb9m","_id":"ck6ywriwk002054v54buvhiw9"},{"post_id":"ck6ywriwd001b54v5bwc94at2","category_id":"ck6ywriwh001r54v58hvdfb9m","_id":"ck6ywriwl002154v51hz62nhx"},{"post_id":"ck722drh1000034v54s7y9bm1","category_id":"ck6ywrivk000354v56h050jng","_id":"ck722drhb000234v5ggbl5t1v"},{"post_id":"ck77ryp2k00003sv58i968vod","category_id":"ck6ywriw2000q54v59xod7ubv","_id":"ck77ryp2q00013sv5fvpt7o86"}],"PostTag":[{"post_id":"ck6ywrivg000154v5hego4oeq","tag_id":"ck6ywrivm000454v571k70fdz","_id":"ck6ywrivs000a54v5ah09e8xr"},{"post_id":"ck6ywrivj000254v55naf1bqj","tag_id":"ck6ywrivr000954v53rmeabp5","_id":"ck6ywrivw000h54v55pmc8e5m"},{"post_id":"ck6ywrivn000554v5h3se6cwf","tag_id":"ck6ywrivv000f54v59wr0hmx5","_id":"ck6ywriw0000n54v50melbxj6"},{"post_id":"ck6ywrivy000m54v5d1rkhcmr","tag_id":"ck6ywrivy000l54v50ajoeqmn","_id":"ck6ywriw3000r54v5f8gtdnyf"},{"post_id":"ck6ywrivo000654v5ct5fge4x","tag_id":"ck6ywrivy000l54v50ajoeqmn","_id":"ck6ywriw5000u54v5fv120jb5"},{"post_id":"ck6ywriw3000t54v5944odmqd","tag_id":"ck6ywrivy000l54v50ajoeqmn","_id":"ck6ywriw7000y54v58tlj0n38"},{"post_id":"ck6ywriw3000t54v5944odmqd","tag_id":"ck6ywrivv000f54v59wr0hmx5","_id":"ck6ywriwa001254v5e9szh4fk"},{"post_id":"ck6ywrivs000b54v5gv6u6src","tag_id":"ck6ywrivy000l54v50ajoeqmn","_id":"ck6ywriwc001654v54rqw5tjx"},{"post_id":"ck6ywriw8001054v586xee192","tag_id":"ck6ywrivy000l54v50ajoeqmn","_id":"ck6ywriwd001a54v590xa2i90"},{"post_id":"ck6ywriwa001354v5cwpzdw1v","tag_id":"ck6ywrivy000l54v50ajoeqmn","_id":"ck6ywriwe001d54v5902m7eh1"},{"post_id":"ck6ywrivu000c54v5239j62nt","tag_id":"ck6ywriw7000z54v56ceo98x0","_id":"ck6ywriwg001i54v5h6oc3n1z"},{"post_id":"ck6ywriwc001754v5dvo5atvv","tag_id":"ck6ywrivy000l54v50ajoeqmn","_id":"ck6ywriwg001k54v5brzuc377"},{"post_id":"ck6ywriwd001b54v5bwc94at2","tag_id":"ck6ywrivm000454v571k70fdz","_id":"ck6ywriwh001o54v5a7xz7zd0"},{"post_id":"ck6ywrivx000i54v55l4bchn9","tag_id":"ck6ywrivy000l54v50ajoeqmn","_id":"ck6ywriwh001q54v5fuf2erg5"},{"post_id":"ck6ywriw6000v54v55d6t0v4r","tag_id":"ck6ywriwf001h54v5djh24oxe","_id":"ck6ywriwj001u54v556we51d9"},{"post_id":"ck6ywriw6000v54v55d6t0v4r","tag_id":"ck6ywriwh001n54v5bvvg8bgp","_id":"ck6ywriwj001x54v5buzl3hwn"},{"post_id":"ck722drh1000034v54s7y9bm1","tag_id":"ck6ywrivm000454v571k70fdz","_id":"ck722drhc000334v52y3z716e"},{"post_id":"ck722drh1000034v54s7y9bm1","tag_id":"ck722drh8000134v57taqfh7h","_id":"ck722drhc000434v5a9y4bu1l"}],"Tag":[{"name":"Java","_id":"ck6ywrivm000454v571k70fdz"},{"name":"Nginx","_id":"ck6ywrivr000954v53rmeabp5"},{"name":"MySQL","_id":"ck6ywrivv000f54v59wr0hmx5"},{"name":"Python","_id":"ck6ywrivy000l54v50ajoeqmn"},{"name":"博客","_id":"ck6ywriw7000z54v56ceo98x0"},{"name":"深度学习","_id":"ck6ywriwf001h54v5djh24oxe"},{"name":"神经网络","_id":"ck6ywriwh001n54v5bvvg8bgp"},{"name":"spring-projects","_id":"ck722drh8000134v57taqfh7h"}]}}